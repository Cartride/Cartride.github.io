<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>使效率倍增的Pandas使用技巧 - MCFON</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MCFON"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MCFON"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文取自Analytics Vidhya的一个帖子12 Useful Pandas Techniques in Python for Data Manipulation，浏览原帖可直接点击链接，中文版可参见Datartisan的用 Python 做数据处理必看：12 个使效率倍增的 Pandas 技巧。这里主要对帖子内容进行检验并记录有用的知识点。"><meta property="og:type" content="blog"><meta property="og:title" content="使效率倍增的Pandas使用技巧"><meta property="og:url" content="https://hunlp.com/posts/4991.html"><meta property="og:site_name" content="MCFON"><meta property="og:description" content="本文取自Analytics Vidhya的一个帖子12 Useful Pandas Techniques in Python for Data Manipulation，浏览原帖可直接点击链接，中文版可参见Datartisan的用 Python 做数据处理必看：12 个使效率倍增的 Pandas 技巧。这里主要对帖子内容进行检验并记录有用的知识点。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://img0.pconline.com.cn/pconline/1202/22/2681570_shujvtoushi.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_1.png"><meta property="og:image" content="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_3.png"><meta property="og:image" content="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_hist.png"><meta property="og:image" content="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_1.png"><meta property="article:published_time" content="2017-06-30T17:35:34.000Z"><meta property="article:modified_time" content="2021-06-08T12:45:54.651Z"><meta property="article:author" content="ฅ´ω`ฅ"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://img0.pconline.com.cn/pconline/1202/22/2681570_shujvtoushi.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hunlp.com/posts/4991.html"},"headline":"使效率倍增的Pandas使用技巧","image":["http://img0.pconline.com.cn/pconline/1202/22/2681570_shujvtoushi.jpg","https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_1.png","https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_3.png","https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_hist.png","https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_1.png"],"datePublished":"2017-06-30T17:35:34.000Z","dateModified":"2021-06-08T12:45:54.651Z","author":{"@type":"Person","name":"ฅ´ω`ฅ"},"publisher":{"@type":"Organization","name":"MCFON","logo":{"@type":"ImageObject","url":"https://hunlp.com/img/logo.png"}},"description":"本文取自Analytics Vidhya的一个帖子12 Useful Pandas Techniques in Python for Data Manipulation，浏览原帖可直接点击链接，中文版可参见Datartisan的用 Python 做数据处理必看：12 个使效率倍增的 Pandas 技巧。这里主要对帖子内容进行检验并记录有用的知识点。"}</script><link rel="canonical" href="https://hunlp.com/posts/4991.html"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?b99420d7a06d2b3361a8efeaf6e20764";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-131608076-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-131608076-1');</script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="MCFON" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>使效率倍增的Pandas使用技巧</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2017-07-01</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2021-06-08</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">1 小时读完 (大约7911个字)</span></div></div><div class="content"><p>本文取自Analytics Vidhya的一个帖子<a target="_blank" rel="noopener" href="http://www.analyticsvidhya.com/blog/2016/01/12-pandas-techniques-python-data-manipulation/">12 Useful Pandas Techniques in Python for Data Manipulation</a>，浏览原帖可直接点击链接，中文版可参见Datartisan的<a target="_blank" rel="noopener" href="http://datartisan.com/article/detail/80.html">用 Python 做数据处理必看：12 个使效率倍增的 Pandas 技巧</a>。这里主要对帖子内容进行检验并记录有用的知识点。 <span id="more"></span> ## 数据集</p>
<p>首先这个帖子用到的数据集是datahack的<a target="_blank" rel="noopener" href="http://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction">贷款预测</a>(load prediction)竞赛数据集，点击链接可以访问下载页面，如果失效只需要注册后搜索loan prediction竞赛就可以找到了。<del>入坑的</del>感兴趣的同学可以前往下载数据集，我就不传上来github了。</p>
<p>先简单看一看数据集结构(此处表格可左右拖动)：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Loan_ID</th>
<th style="text-align: center;">Gender</th>
<th style="text-align: center;">Married</th>
<th style="text-align: center;">Dependents</th>
<th style="text-align: center;">Education</th>
<th style="text-align: center;">Self_Employed</th>
<th style="text-align: center;">ApplicantIncome</th>
<th style="text-align: center;">CoapplicantIncome</th>
<th style="text-align: center;">LoanAmount</th>
<th style="text-align: center;">Loan_Amount_Term</th>
<th style="text-align: center;">Credit_History</th>
<th style="text-align: center;">Property_Area</th>
<th style="text-align: center;">Loan_Status</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">LP001002</td>
<td style="text-align: center;">Male</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Graduate</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">5849</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">360</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Urban</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="even">
<td style="text-align: center;">LP001003</td>
<td style="text-align: center;">Male</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Graduate</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">4583</td>
<td style="text-align: center;">1508</td>
<td style="text-align: center;">128</td>
<td style="text-align: center;">360</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Rural</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="odd">
<td style="text-align: center;">LP001005</td>
<td style="text-align: center;">Male</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Graduate</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">3000</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">66</td>
<td style="text-align: center;">360</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Urban</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="even">
<td style="text-align: center;">LP001006</td>
<td style="text-align: center;">Male</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Not Graduate</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">2583</td>
<td style="text-align: center;">2358</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">360</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Urban</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">LP001008</td>
<td style="text-align: center;">Male</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">Graduate</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">6000</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">141</td>
<td style="text-align: center;">360</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Urban</td>
<td style="text-align: center;">Y</td>
</tr>
</tbody>
</table>
<p>共614条数据记录，每条记录有十二个基本属性，一个目标属性(Loan_Status)。数据记录可能包含缺失值。</p>
<p>数据集很小，直接导入Python环境即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">r&quot;F:\Datahack_Loan_Prediction\Loan_Prediction_Train.csv&quot;</span>, index_col=<span class="string">&quot;Loan_ID&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里我们指定index_col为Loan_ID这一列，所以程序会把csv文件中Loan_ID这一列作为DataFrame的索引。默认情况下index_col为False，程序自动创建int型索引，从0开始。</p>
<h2 id="布尔索引boolean-indexing">1. 布尔索引(Boolean Indexing)</h2>
<p>有时我们希望基于某些列的条件筛选出需要的记录，这时可以使用loc索引的布尔索引功能。比方说下面的代码筛选出全部无大学学历但有贷款的女性列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[(data[<span class="string">&quot;Gender&quot;</span>]==<span class="string">&quot;Female&quot;</span>) &amp; (data[<span class="string">&quot;Education&quot;</span>]==<span class="string">&quot;Not Graduate&quot;</span>) &amp; (data[<span class="string">&quot;Loan_Status&quot;</span>]==<span class="string">&quot;Y&quot;</span>), [<span class="string">&quot;Gender&quot;</span>,<span class="string">&quot;Education&quot;</span>,<span class="string">&quot;Loan_Status&quot;</span>]]</span><br></pre></td></tr></table></figure>
<div>
<table class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
Gender
</th>
<th>
Education
</th>
<th>
Loan_Status
</th>
</tr>
<tr>
<th>
Loan_ID
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
LP001155
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP001669
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP001692
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP001908
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002300
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002314
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002407
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002489
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002502
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002534
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002582
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002731
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002757
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
<tr>
<th>
LP002917
</th>
<td>
Female
</td>
<td>
Not Graduate
</td>
<td>
Y
</td>
</tr>
</tbody>
</table>
</div>
<p>loc索引是优先采用label定位的，label可以理解为索引。前面我们定义了Loan_ID为索引，所以对这个DataFrame使用loc定位时就可以用Loan_ID定位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[<span class="string">&#x27;LP001002&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Gender                   Male</span><br><span class="line">Married                    No</span><br><span class="line">Dependents                  <span class="number">0</span></span><br><span class="line">Education            Graduate</span><br><span class="line">Self_Employed              No</span><br><span class="line">ApplicantIncome          <span class="number">5849</span></span><br><span class="line">CoapplicantIncome           <span class="number">0</span></span><br><span class="line">LoanAmount            <span class="number">129.937</span></span><br><span class="line">Loan_Amount_Term          <span class="number">360</span></span><br><span class="line">Credit_History              <span class="number">1</span></span><br><span class="line">Property_Area           Urban</span><br><span class="line">Loan_Status                 Y</span><br><span class="line">LoanAmount_Bin         medium</span><br><span class="line">Loan_Status_Coded           <span class="number">1</span></span><br><span class="line">Name: LP001002, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们指定了一个Loan_ID，就定位到这个Loan_ID对应的记录。</p>
<p>loc允许四种input方式:</p>
<ol type="1">
<li><p>指定一个label;</p></li>
<li><p>label列表，比如<code>['LP001002','LP001003','LP001004']</code>;</p></li>
<li><p>label切片，比如<code>'LP001002':'LP001003'</code>;</p></li>
<li><p>布尔数组</p></li>
</ol>
<p>我们希望基于列值进行筛选就用到了第4种input方式-布尔索引。<strong>使用()括起筛选条件，多个筛选条件之间使用逻辑运算符<code>&amp;</code>,<code>|</code>,<code>~</code>与或非进行连接</strong>，特别注意，和我们平常使用Python不同，这里用<code>and</code>,<code>or</code>,<code>not</code>是行不通的。</p>
<p>此外，这四种input方式都支持第二个参数，使用一个columns的列表，表示只取出记录中的某些列。上面的例子就是只取出了<code>Gender</code>,<code>Education</code>,<code>Loan_Status</code>这三列，当然，获得的新DataFrame的索引依然是Loan_ID。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/indexing.html">Pandas Selecting and Indexing</a>。</p>
<h2 id="apply函数">2. Apply函数</h2>
<p>Apply是一个方便我们处理数据的函数，可以把我们指定的一个函数应用到DataFrame的每一行或者每一列(使用参数axis设定，默认为0，即应用到每一列)。</p>
<p>如果要应用到特定的行和列只需要先提取出来再apply就可以了，比如<code>data['Gender'].apply(func)</code>。特别地，这里指定的函数可以是系统自带的，也可以是我们定义的(可以用匿名函数)。比如下面这个例子统计每一列的缺失值个数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新函数:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_missing</span>(<span class="params">x</span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sum</span>(x.isnull())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply到每一列:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Missing values per column:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.apply(num_missing, axis=<span class="number">0</span>)) <span class="comment"># axis=0代表函数应用于每一列</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Missing values per column:</span><br><span class="line">Gender               <span class="number">13</span></span><br><span class="line">Married               <span class="number">3</span></span><br><span class="line">Dependents           <span class="number">15</span></span><br><span class="line">Education             <span class="number">0</span></span><br><span class="line">Self_Employed        <span class="number">32</span></span><br><span class="line">ApplicantIncome       <span class="number">0</span></span><br><span class="line">CoapplicantIncome     <span class="number">0</span></span><br><span class="line">LoanAmount           <span class="number">22</span></span><br><span class="line">Loan_Amount_Term     <span class="number">14</span></span><br><span class="line">Credit_History       <span class="number">50</span></span><br><span class="line">Property_Area         <span class="number">0</span></span><br><span class="line">Loan_Status           <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>下面这个例子统计每一行的缺失值个数，因为行数太多，所以使用head函数仅打印出DataFrame的前5行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Apply到每一行:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMissing values per row:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.apply(num_missing, axis=<span class="number">1</span>).head()) <span class="comment"># axis=1代表函数应用于每一行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Missing values per row:</span><br><span class="line">Loan_ID</span><br><span class="line">LP001002    <span class="number">1</span></span><br><span class="line">LP001003    <span class="number">0</span></span><br><span class="line">LP001005    <span class="number">0</span></span><br><span class="line">LP001006    <span class="number">0</span></span><br><span class="line">LP001008    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html#pandas.DataFrame.apply">Pandas Reference (apply)</a></p>
<h2 id="替换缺失值">3. 替换缺失值</h2>
<p>一般来说我们会把某一列的缺失值替换为所在列的平均值/众数/中位数。<code>fillna()</code>函数可以帮我们实现这个功能。但首先要从scipy库导入获取统计值的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先导入一个寻找众数的函数：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> mode</span><br><span class="line"></span><br><span class="line">GenderMode = mode(data[<span class="string">&#x27;Gender&#x27;</span>].dropna())</span><br><span class="line"><span class="built_in">print</span>(GenderMode)</span><br><span class="line"><span class="built_in">print</span>(GenderMode.mode[<span class="number">0</span>],<span class="string">&#x27;:&#x27;</span>,GenderMode.count[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ModeResult(mode=array([<span class="string">&#x27;Male&#x27;</span>], dtype=<span class="built_in">object</span>), count=array([<span class="number">489</span>]))</span><br><span class="line">Male : <span class="number">489</span></span><br><span class="line"></span><br><span class="line">F:\Anaconda3\lib\site-packages\scipy\stats\stats.py:<span class="number">257</span>: RuntimeWarning: The <span class="built_in">input</span> array could <span class="keyword">not</span> be properly checked <span class="keyword">for</span> nan values. nan values will be ignored.</span><br><span class="line">  <span class="string">&quot;values. nan values will be ignored.&quot;</span>, RuntimeWarning)</span><br></pre></td></tr></table></figure>
<p>可以看到对DataFrame的某一列使用mode函数可以得到这一列的众数以及它所出现的次数，由于众数可能不止一个，所以众数的结果是一个列表，对应地出现次数也是一个列表。可以使用<code>.mode</code>和<code>.count</code>提取出这两个列表。</p>
<p><strong>特别留意</strong>，可能是版本原因，我使用的scipy (0.17.0)不支持原帖子中的代码，直接使用<code>mode(data['Gender'])</code>是会报错的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F:\Anaconda3\lib\site-packages\scipy\stats\stats.py:<span class="number">257</span>: RuntimeWarning: The <span class="built_in">input</span> array could <span class="keyword">not</span> be p</span><br><span class="line">roperly checked <span class="keyword">for</span> nan values. nan values will be ignored.</span><br><span class="line">  <span class="string">&quot;values. nan values will be ignored.&quot;</span>, RuntimeWarning)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;F:\Anaconda3\lib\site-packages\scipy\stats\stats.py&quot;</span>, line <span class="number">644</span>, <span class="keyword">in</span> mode</span><br><span class="line">    scores = np.unique(np.ravel(a))       <span class="comment"># get ALL unique values</span></span><br><span class="line">  File <span class="string">&quot;F:\Anaconda3\lib\site-packages\numpy\lib\arraysetops.py&quot;</span>, line <span class="number">198</span>, <span class="keyword">in</span> unique</span><br><span class="line">    ar.sort()</span><br><span class="line">TypeError: unorderable types: <span class="built_in">str</span>() &gt; <span class="built_in">float</span>()</span><br></pre></td></tr></table></figure>
<p>必须使用<code>mode(data['Gender'].dropna())</code>，传入dropna()处理后的DataFrame才可以。虽然Warning仍然存在，但是可以执行得到结果。Stackoverflow里有这个问题的讨论：<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/36239953/scipy-stats-mode-function-gives-type-error-unorderable-types-str-float">Scipy Stats Mode function gives Type Error unorderable types</a>。指出scipy的mode函数无法处理列表中包含混合类型的情况，比方说上面的例子就是包含了缺失值NAN类型和字符串类型，所以无法直接处理。</p>
<p>同时也指出Pandas自带的mode函数是可以处理混合类型的，我测试了一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</span><br><span class="line">Series.mode(data[<span class="string">&#x27;Gender&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    Male</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>确实没问题，不需要使用dropna()处理，但是只能获得众数，没有对应的出现次数。返回结果是一个Pandas的Series对象。可以有多个众数，索引是int类型，从0开始。</p>
<p>掌握了获取众数的方法后就可以使用fiilna替换缺失值了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#值替换:</span></span><br><span class="line">data[<span class="string">&#x27;Gender&#x27;</span>].fillna(GenderMode.mode[<span class="number">0</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">MarriedMode = mode(data[<span class="string">&#x27;Married&#x27;</span>].dropna())</span><br><span class="line">data[<span class="string">&#x27;Married&#x27;</span>].fillna(MarriedMode.mode[<span class="number">0</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">Self_EmployedMode = mode(data[<span class="string">&#x27;Self_Employed&#x27;</span>].dropna())</span><br><span class="line">data[<span class="string">&#x27;Self_Employed&#x27;</span>].fillna(Self_EmployedMode.mode[<span class="number">0</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>先提取出某一列，然后用fillna把这一列的缺失值都替换为计算好的平均值/众数/中位数。inplace关键字用于指定是否直接对这个对象进行修改，默认是False，如果指定为True则直接在对象上进行修改，其他地方调用这个对象时也会收到影响。这里我们希望修改直接覆盖缺失值，所以指定为True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#再次检查缺失值以确认:</span></span><br><span class="line"><span class="built_in">print</span>(data.apply(num_missing, axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Gender                <span class="number">0</span></span><br><span class="line">Married               <span class="number">0</span></span><br><span class="line">Dependents           <span class="number">15</span></span><br><span class="line">Education             <span class="number">0</span></span><br><span class="line">Self_Employed         <span class="number">0</span></span><br><span class="line">ApplicantIncome       <span class="number">0</span></span><br><span class="line">CoapplicantIncome     <span class="number">0</span></span><br><span class="line">LoanAmount           <span class="number">22</span></span><br><span class="line">Loan_Amount_Term     <span class="number">14</span></span><br><span class="line">Credit_History       <span class="number">50</span></span><br><span class="line">Property_Area         <span class="number">0</span></span><br><span class="line">Loan_Status           <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Gender</code>,<code>Married</code>,<code>Self_Employed</code>这几列的缺失值已经都替换成功了，所以缺失值的个数为0。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html#pandas.DataFrame.fillna">Pandas Reference (fillna)</a></p>
<h2 id="透视表">4. 透视表</h2>
<p><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1709397.htm">透视表</a>(Pivot Table)是一种交互式的表，可以动态地改变它的版面布置，以便按照不同方式分析数据，也可以重新安排行号、列标、页字段，比如下面的Excel透视表：</p>
<figure>
<img src="http://img0.pconline.com.cn/pconline/1202/22/2681570_shujvtoushi.jpg" alt="Excel透视表" /><figcaption aria-hidden="true">Excel透视表</figcaption>
</figure>
<p>可以自由选择用来做行号和列标的属性，非常便于我们做不同的分析。Pandas也提供类似的透视表的功能。例如<code>LoanAmount</code>这个重要的列有缺失值。我们不希望直接使用整体平均值来替换，这样太过笼统，不合理。</p>
<p>这时可以用先根据 <code>Gender</code>、<code>Married</code>、<code>Self_Employed</code>分组后，再按各组的均值来分别替换缺失值。每个组 <code>LoanAmount</code>的均值可以用如下方法确定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Determine pivot table</span></span><br><span class="line"></span><br><span class="line">impute_grps = data.pivot_table(values=[<span class="string">&quot;LoanAmount&quot;</span>], index=[<span class="string">&quot;Gender&quot;</span>,<span class="string">&quot;Married&quot;</span>,<span class="string">&quot;Self_Employed&quot;</span>], aggfunc=np.mean)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(impute_grps)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                              LoanAmount</span><br><span class="line">Gender Married Self_Employed</span><br><span class="line">Female No      No             <span class="number">114.691176</span></span><br><span class="line">               Yes            <span class="number">125.800000</span></span><br><span class="line">       Yes     No             <span class="number">134.222222</span></span><br><span class="line">               Yes            <span class="number">282.250000</span></span><br><span class="line">Male   No      No             <span class="number">129.936937</span></span><br><span class="line">               Yes            <span class="number">180.588235</span></span><br><span class="line">       Yes     No             <span class="number">153.882736</span></span><br><span class="line">               Yes            <span class="number">169.395833</span></span><br></pre></td></tr></table></figure>
<p>关键字<code>values</code>用于指定要使用集成函数(字段<code>aggfunc</code>)计算的列，选填，不进行指定时默认对所有index以外符合集成函数处理类型的列进行处理，比如这里使用<code>mean</code>作集成函数，则合适的类型就是数值类型。<code>index</code>是行标，可以是多重索引，处理时会按序分组。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pivot_table.html#pandas.DataFrame.pivot_table">Pandas Reference (Pivot Table)</a></p>
<h2 id="多重索引">5. 多重索引</h2>
<p>不同于DataFrame对象，可以看到上一步得到的Pivot Table每个索引都是由三个值组合而成的，这就叫做多重索引。</p>
<p>从上一步中我们得到了每个分组的平均值，接下来我们就可以用来替换<code>LoanAmount</code>字段的缺失值了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只在带有缺失值的行中迭代：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,row <span class="keyword">in</span> data.loc[data[<span class="string">&#x27;LoanAmount&#x27;</span>].isnull(),:].iterrows():</span><br><span class="line"></span><br><span class="line">  ind = <span class="built_in">tuple</span>([row[<span class="string">&#x27;Gender&#x27;</span>],row[<span class="string">&#x27;Married&#x27;</span>],row[<span class="string">&#x27;Self_Employed&#x27;</span>]])</span><br><span class="line"></span><br><span class="line">  data.loc[i,<span class="string">&#x27;LoanAmount&#x27;</span>] = impute_grps.loc[ind].values[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>特别注意对Pivot Table使用loc定位的方式，Pivot Table的索引是一个tuple。从上面的代码可以看到，先把DataFrame中所有<code>LoanAmount</code>字段缺失的数据记录取出，并且使用iterrows函数转为一个按行迭代的对象，每次迭代返回一个索引(DataFrame里的索引)以及对应行的内容。然后从行的内容中把 <code>Gender</code>、<code>Married</code>、<code>Self_Employed</code>三个字段的值提取出放入一个tuple里，这个tuple就可以用作前面定义的Pivot Table的索引了。</p>
<p>接下来的赋值对DataFrame使用loc定位根据索引定位，并且只抽取<code>LoanAmount</code>字段，把它赋值为在Pivot Table中对应分组的平均值。最后检查一下，这样我们又处理好一个列的缺失值了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#再次检查缺失值以确认：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.apply(num_missing, axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Gender                <span class="number">0</span></span><br><span class="line">Married               <span class="number">0</span></span><br><span class="line">Dependents           <span class="number">15</span></span><br><span class="line">Education             <span class="number">0</span></span><br><span class="line">Self_Employed         <span class="number">0</span></span><br><span class="line">ApplicantIncome       <span class="number">0</span></span><br><span class="line">CoapplicantIncome     <span class="number">0</span></span><br><span class="line">LoanAmount            <span class="number">0</span></span><br><span class="line">Loan_Amount_Term     <span class="number">14</span></span><br><span class="line">Credit_History       <span class="number">50</span></span><br><span class="line">Property_Area         <span class="number">0</span></span><br><span class="line">Loan_Status           <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="二维表">6. 二维表</h2>
<p>二维表这个东西可以帮助我们快速验证一些基本假设，从而获取对数据表格的初始印象。例如，本例中<code>Credit_History</code>字段被认为对会否获得贷款有显著影响。可以用下面这个二维表进行验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.crosstab(data[<span class="string">&quot;Credit_History&quot;</span>],data[<span class="string">&quot;Loan_Status&quot;</span>],margins=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<div>
<table class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
Loan_Status
</th>
<th>
N
</th>
<th>
Y
</th>
<th>
All
</th>
</tr>
<tr>
<th>
Credit_History
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0.0
</th>
<td>
82
</td>
<td>
7
</td>
<td>
89
</td>
</tr>
<tr>
<th>
1.0
</th>
<td>
97
</td>
<td>
378
</td>
<td>
475
</td>
</tr>
<tr>
<th>
All
</th>
<td>
192
</td>
<td>
422
</td>
<td>
614
</td>
</tr>
</tbody>
</table>
</div>
<p><code>crosstab</code>的第一个参数是index，用于行的分组；第二个参数是columns，用于列的分组。代码中还用到了一个<code>margins</code>参数，这个参数默认为False，启用后得到的二维表会包含汇总数据。</p>
<p>然而，相比起绝对数值，百分比更有助于快速了解数据。我们可以用apply函数达到目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">percConvert</span>(<span class="params">ser</span>):</span></span><br><span class="line">  <span class="keyword">return</span> ser/<span class="built_in">float</span>(ser[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">pd.crosstab(data[<span class="string">&quot;Credit_History&quot;</span>],data[<span class="string">&quot;Loan_Status&quot;</span>],margins=<span class="literal">True</span>).apply(percConvert, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<div>
<table class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
Loan_Status
</th>
<th>
N
</th>
<th>
Y
</th>
<th>
All
</th>
</tr>
<tr>
<th>
Credit_History
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0.0
</th>
<td>
0.921348
</td>
<td>
0.078652
</td>
<td>
1.0
</td>
</tr>
<tr>
<th>
1.0
</th>
<td>
0.204211
</td>
<td>
0.795789
</td>
<td>
1.0
</td>
</tr>
<tr>
<th>
All
</th>
<td>
0.312704
</td>
<td>
0.687296
</td>
<td>
1.0
</td>
</tr>
</tbody>
</table>
</div>
<p>从这个二维表中我们可以看到有信用记录 (<code>Credit_History</code>字段为1.0) 的人获得贷款的可能性更高。接近80%有信用记录的人都 获得了贷款，而没有信用记录的人只有大约8% 获得了贷款。令人惊讶的是，如果我们直接利用信用记录进行训练集的预测，在614条记录中我们能准确预测出460条记录 (不会获得贷款+会获得贷款：82+378) ，占总数足足75%。不过呢~在训练集上效果好并不代表在测试集上效果也一样好。有时即使提高0.001%的准确度也是相当困难的，这就是我们为什么需要建立模型进行预测的原因了。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/version/0.17.0/generated/pandas.crosstab.html">Pandas Reference (crosstab)</a></p>
<h2 id="数据框合并">7. 数据框合并</h2>
<p>就像数据库有多个表的连接操作一样，当数据来源不同时，会产生把不同表格合并的需求。这里假设不同的房产类型有不同的房屋均价数据，定义一个新的表格，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prop_rates = pd.DataFrame([<span class="number">1000</span>, <span class="number">5000</span>, <span class="number">12000</span>], index=[<span class="string">&#x27;Rural&#x27;</span>,<span class="string">&#x27;Semiurban&#x27;</span>,<span class="string">&#x27;Urban&#x27;</span>],columns=[<span class="string">&#x27;rates&#x27;</span>])</span><br><span class="line"></span><br><span class="line">prop_rates</span><br></pre></td></tr></table></figure>
<div>
<table class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
rates
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
Rural
</th>
<td>
1000
</td>
</tr>
<tr>
<th>
Semiurban
</th>
<td>
5000
</td>
</tr>
<tr>
<th>
Urban
</th>
<td>
12000
</td>
</tr>
</tbody>
</table>
</div>
<p>农村房产均价只用1000，城郊这要5000，城镇内房产比较贵，均价为12000。我们获取到这个数据之后，希望把它连接到原始表格Loan_Prediction_Train.csv中以便观察房屋均价对预测的影响。在原始表格中有一列Property_Area就是表明贷款人居住的区域的，可以通过这一列进行表格连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_merged = data.merge(right=prop_rates, how=<span class="string">&#x27;inner&#x27;</span>,left_on=<span class="string">&#x27;Property_Area&#x27;</span>,right_index=<span class="literal">True</span>, sort=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">data_merged.pivot_table(values=<span class="string">&#x27;Credit_History&#x27;</span>,index=[<span class="string">&#x27;Property_Area&#x27;</span>,<span class="string">&#x27;rates&#x27;</span>], aggfunc=<span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Property_Area  rates</span><br><span class="line">Rural          <span class="number">1000</span>     <span class="number">179.0</span></span><br><span class="line">Semiurban      <span class="number">5000</span>     <span class="number">233.0</span></span><br><span class="line">Urban          <span class="number">12000</span>    <span class="number">202.0</span></span><br><span class="line">Name: Credit_History, dtype: float64</span><br></pre></td></tr></table></figure>
<p>使用merge函数进行连接,解析一下各个参数：</p>
<ul>
<li><p>参数right即连接操作右端表格；</p></li>
<li><p>参数how指示连接方式，默认是inner，即内连接。可选left、right、outer、inner；</p>
<ul>
<li>left: use only keys from left frame (SQL: left outer join)</li>
<li>right: use only keys from right frame (SQL: right outer join)</li>
<li>outer: use union of keys from both frames (SQL: full outer join)</li>
<li>inner: use intersection of keys from both frames (SQL: inner join)</li>
</ul></li>
<li><p>参数left_on用于指定连接的key的列名，即使key在两个表格中的列名不同，也可以通过left_on和right_on参数分别指定。 如果一样的话，使用on参数就可以了。可以是一个标签(单列)，也可以是一个列表（多列）；</p></li>
<li><p>right_index默认为False，设置为True时会把连接操作右端表格的索引作为连接的key。同理还有left_index；</p></li>
<li><p>sort参数默认为False，指示是否需要按key排序。</p></li>
</ul>
<p>所以上面的代码是把data表格和prop_rates表格连接起来。连接时，data表格用于连接的key是<code>Property_Area</code>，而prop_rates表格用于连接的key是索引，它们的值域是相同的。</p>
<p>连接之后使用了第四小节透视表的方法检验新表格中<code>Property_Area</code>字段和<code>rates</code>字段的关系。后面跟着的数字表示出现的次数。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html#pandas.DataFrame.merge">Pandas Reference (merge)</a></p>
<h2 id="给数据排序">8. 给数据排序</h2>
<p>Pandas可以轻松地基于多列进行排序，方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_sorted = data.sort_values([<span class="string">&#x27;ApplicantIncome&#x27;</span>,<span class="string">&#x27;CoapplicantIncome&#x27;</span>], ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">data_sorted[[<span class="string">&#x27;ApplicantIncome&#x27;</span>,<span class="string">&#x27;CoapplicantIncome&#x27;</span>]].head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<div>
<table class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
ApplicantIncome
</th>
<th>
CoapplicantIncome
</th>
</tr>
<tr>
<th>
Loan_ID
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
LP002317
</th>
<td>
81000
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP002101
</th>
<td>
63337
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP001585
</th>
<td>
51763
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP001536
</th>
<td>
39999
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP001640
</th>
<td>
39147
</td>
<td>
4750.0
</td>
</tr>
<tr>
<th>
LP002422
</th>
<td>
37719
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP001637
</th>
<td>
33846
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP001448
</th>
<td>
23803
</td>
<td>
0.0
</td>
</tr>
<tr>
<th>
LP002624
</th>
<td>
20833
</td>
<td>
6667.0
</td>
</tr>
<tr>
<th>
LP001922
</th>
<td>
20667
</td>
<td>
0.0
</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Notice</strong>：Pandas 的<code>sort</code>函数现在已经不推荐使用，使用 <code>sort_values</code>函数代替。</p>
<p>这里传入了<code>ApplicantIncome</code>和<code>CoapplicantIncome</code>两个字段用于排序，Pandas会先按序进行。先根据<code>ApplicantIncome</code>进行排序，<strong>对于<code>ApplicantIncome</code>相同的记录再根据<code>CoapplicantIncome</code>进行排序。</strong> ascending参数设为False，表示降序排列。不妨再看个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line">df_temp = DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],<span class="string">&#x27;b&#x27;</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]&#125;)</span><br><span class="line">df_sorted = df_temp.sort_values([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],ascending=<span class="literal">False</span>)</span><br><span class="line">df_sorted</span><br></pre></td></tr></table></figure>
<div>
<table class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
a
</th>
<th>
b
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
3
</th>
<td>
4
</td>
<td>
0
</td>
</tr>
<tr>
<th>
2
</th>
<td>
3
</td>
<td>
1
</td>
</tr>
<tr>
<th>
4
</th>
<td>
3
</td>
<td>
1
</td>
</tr>
<tr>
<th>
1
</th>
<td>
2
</td>
<td>
1
</td>
</tr>
<tr>
<th>
5
</th>
<td>
2
</td>
<td>
0
</td>
</tr>
<tr>
<th>
6
</th>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<th>
0
</th>
<td>
1
</td>
<td>
0
</td>
</tr>
</tbody>
</table>
</div>
<p>这里只有a和b两列，可以清晰地看到Pandas的多列排序是先按a列进行排序，a列的值相同则会再按b列的值排序。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values">Pandas Reference (sort_values)</a></p>
<h2 id="绘图箱型图直方图">9. 绘图（箱型图&amp;直方图）</h2>
<p>Pandas除了表格操作之外，还可以直接绘制箱型图和直方图且只需一行代码。这样就不必单独调用matplotlib了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">data.boxplot(column=<span class="string">&quot;ApplicantIncome&quot;</span>,by=<span class="string">&quot;Loan_Status&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_1.png" alt="箱型图1" /><figcaption aria-hidden="true">箱型图1</figcaption>
</figure>
<p>###箱型图</p>
<p>因为之前没怎么接触过箱型图，所以这里单独开一节简单归纳一下。</p>
<p>箱形图（英文：Box-plot），又称为盒须图、盒式图、盒状图或箱线图，是一种用作显示一组数据分散情况资料的统计图。因型状如箱子而得名。详细解析看<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%B1%E5%BD%A2%E5%9C%96">维基百科</a>。</p>
<p>因为上面那幅图不太容易看，用个简单点的例子来说，还是上一小节那个只有a列和b列的表格。按b列对a列进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_temp.boxplot(column=<span class="string">&quot;a&quot;</span>,by=<span class="string">&quot;b&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_3.png" alt="箱型图2" /><figcaption aria-hidden="true">箱型图2</figcaption>
</figure>
<p>定义b列值为0的分组为Group1，b列值为1的分组为Group2。Group1分组有4，2，1三个值，毫无疑问最大值4，最小值1，在箱型图中这两个值对应箱子发出的<strong>虚线顶端的两条实线</strong>。Group2分组有3，3，2，1四个值，由于最大值3和上四分位数3(箱子顶部)相同，所以重合了。</p>
<p>Group1中位数是2，而Group2的中位数则是中间两个数2和3的平均数，也即2.5。在箱型图中由箱子中间的有色线段表示。</p>
<p>###四分位数</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%88%86%E4%BD%8D%E6%95%B0">四分位数</a>是统计学的一个概念。把所有数值由小到大排列好，然后分成四等份，处于三个分割点位置的数值就是四分位数，其中：</p>
<ul>
<li><strong>第一四分位数</strong> (Q1)，又称“<strong>较小四分位数</strong>”或“<strong>下四分位数</strong>”，等于该样本中所有数值由小到大排列后，在四分之一位置的数。</li>
<li><strong>第二四分位数</strong> (Q2)，又称“<strong>中位数</strong>”，等于该样本中所有数值由小到大排列后，在二分之一位置的数。</li>
<li><strong>第三四分位数</strong> (Q3)，又称“<strong>较大四分位数</strong>”或“<strong>上四分位数</strong>”，等于该样本中所有数值由小到大排列后，在四分之三位置的数。</li>
</ul>
<p><strong>Notice：</strong>Q3与Q1的差距又称<strong>四分位距</strong>（InterQuartile Range, IQR）。</p>
<p>计算四分位数时首先计算位置，假设有n个数字，则：</p>
<ul>
<li>Q1位置 = (n-1) / 4</li>
<li>Q2位置 = 2 * (n-1) / 4 = (n-1) / 2</li>
<li>Q3位置 = 3 * (n-1) / 4</li>
</ul>
<p>如果n-1恰好是4的倍数，那么数列中对应位置的就是各个四分位数了。但是，<strong>如果n-1不是4的倍数呢</strong>？</p>
<p>这时位置会是一个带小数部分的数值，四分位数以<strong>距离该值最近的两个位置的加权平均值求出</strong>。其中，距离较近的数，权值为小数部分；而距离较远的数，权值为(1-小数部分)。</p>
<p>再看例子中的Group1，Q1位置为0.5，Q2位置为1，Q3位置为1.5。（<strong>注意：位置从下标0开始！</strong>），所以：</p>
<pre><code>Q1 = 0.5*1+0.5*2 = 1.5
Q2 = 2
Q3 = 0.5*2+0.5*4 = 3</code></pre>
<p>而Group2中，Q1位置为0.75，Q2位置为1.5，Q3位置为2.25。</p>
<pre><code>Q1 = 0.25*1+0.72*2 = 1.75
Q2 = 0.5*2+0.5*3 = 2.5
Q3 = 0.25*3+0.75*3 = 3</code></pre>
<p>这样是否就清晰多了XD 然而，<strong>四分位数的取法还存在分歧</strong>，定义不一，我在学习这篇文章时也曾经很迷茫，<strong>直到阅读了源码！！</strong></p>
<p>因为Pandas库依赖numpy库，所以它计算四分位数的方式自然也是使用了numpy库的。而<strong>numpy中实现计算百分比数的函数为percentile</strong>，代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">percentile</span>(<span class="params">N, percent, key=<span class="keyword">lambda</span> x:x</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Find the percentile of a list of values.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @parameter N - is a list of values. Note N MUST BE already sorted.</span></span><br><span class="line"><span class="string">    @parameter percent - a float value from 0.0 to 1.0.</span></span><br><span class="line"><span class="string">    @parameter key - optional key function to compute value from each element of N.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @return - the percentile of the values</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> N:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k = (<span class="built_in">len</span>(N)-<span class="number">1</span>) * percent</span><br><span class="line">    f = math.floor(k)</span><br><span class="line">    c = math.ceil(k)</span><br><span class="line">    <span class="keyword">if</span> f == c:</span><br><span class="line">        <span class="keyword">return</span> key(N[<span class="built_in">int</span>(k)])</span><br><span class="line">    d0 = key(N[<span class="built_in">int</span>(f)]) * (c-k)</span><br><span class="line">    d1 = key(N[<span class="built_in">int</span>(c)]) * (k-f)</span><br><span class="line">    <span class="keyword">return</span> d0+d1</span><br></pre></td></tr></table></figure>
<p>读一遍源码之后就更加清晰了。最后举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> percentile, mean, median</span><br><span class="line">temp = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] <span class="comment"># 数列包含3个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(temp))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp,<span class="number">25</span>))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp,<span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp,<span class="number">75</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(temp))</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.5</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">temp2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] <span class="comment"># 数列包含4个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(temp2))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp2,<span class="number">25</span>))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp2,<span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp2,<span class="number">75</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(temp2))</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.75</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">temp3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="comment"># 数列包含5个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(temp2))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp3,<span class="number">25</span>))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp3,<span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(percentile(temp3,<span class="number">75</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(temp3))</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="number">4.0</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>不熟悉的话就再手撸一遍！！！不要怕麻烦！！！这一小节到此Over~</p>
<p>###直方图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.hist(column=<span class="string">&quot;ApplicantIncome&quot;</span>,by=<span class="string">&quot;Loan_Status&quot;</span>,bins=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_hist.png" alt="直方图" /><figcaption aria-hidden="true">直方图</figcaption>
</figure>
<p>直方图比箱型图熟悉一些，这里就不详细展开了。结合箱型图和直方图，我们可以看出获得贷款的人和未获得贷款的人没有明显的收入差异，也即收入不是决定性因素。</p>
<p>###离群点</p>
<p>特别地，从直方图上我们可以看出这个数据集在收入字段上，比较集中于一个区间，区间外部有些散落的点，这些点我们称为离群点(Outlier)。前面将箱型图时没有细说，现在再回顾一下箱型图：</p>
<figure>
<img src="https://raw.githubusercontent.com/familyld/learnpython/master/graph/pandas_box_1.png" alt="箱型图1" /><figcaption aria-hidden="true">箱型图1</figcaption>
</figure>
<p>可以看到除了箱子以及最大最小值之外，还有很多横线，这些横线其实就表示离群点。那么可能又会有新的疑问了？<strong>怎么会有离群点在最大最小值外面呢</strong>？这样岂不是存在比最大值大，比最小值小的情况了吗？</p>
<p>其实之前提到一下，有一个概念叫四分位距（IQR），数值上等于Q3-Q1，记作ΔQ。定义：</p>
<ul>
<li><strong>最大值区间</strong>： Q3+1.5ΔQ</li>
<li><strong>最小值区间</strong>： Q1-1.5ΔQ</li>
</ul>
<p>也就是说最大值必须出现在这两个区间内，<strong>区间外的值被视为离群点</strong>，并显示在图上。这样做我们可以避免被过分偏离的数据点带偏，更准确地观测到数据的真实状况，或者说普遍状况。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.hist.html#pandas.DataFrame.hist">Pandas Reference (hist)</a> | <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.boxplot.html#pandas.DataFrame.boxplot">Pandas Reference (boxplot)</a></p>
<p>##10. 用Cut函数分箱</p>
<p>有时把数值聚集在一起更有意义。例如，如果我们要为交通状况（路上的汽车数量）根据时间（分钟数据）建模。具体的分钟可能不重要，而时段如“上午”“下午”“傍晚”“夜间”“深夜”更有利于预测。如此建模更直观，也能避免过度拟合。 这里我们定义一个简单的、可复用的函数，轻松为任意变量分箱。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分箱:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binning</span>(<span class="params">col, cut_points, labels=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#Define min and max values:</span></span><br><span class="line"></span><br><span class="line">  minval = col.<span class="built_in">min</span>()</span><br><span class="line"></span><br><span class="line">  maxval = col.<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">#利用最大值和最小值创建分箱点的列表</span></span><br><span class="line"></span><br><span class="line">  break_points = [minval] + cut_points + [maxval]</span><br><span class="line"></span><br><span class="line">  <span class="comment">#如果没有标签，则使用默认标签0 ... (n-1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> labels:</span><br><span class="line"></span><br><span class="line">    labels = <span class="built_in">range</span>(<span class="built_in">len</span>(cut_points)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#使用pandas的cut功能分箱</span></span><br><span class="line"></span><br><span class="line">  colBin = pd.cut(col,bins=break_points,labels=labels,include_lowest=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> colBin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#为年龄分箱:</span></span><br><span class="line"></span><br><span class="line">cut_points = [<span class="number">90</span>,<span class="number">140</span>,<span class="number">190</span>]</span><br><span class="line"></span><br><span class="line">labels = [<span class="string">&quot;low&quot;</span>,<span class="string">&quot;medium&quot;</span>,<span class="string">&quot;high&quot;</span>,<span class="string">&quot;very high&quot;</span>]</span><br><span class="line"></span><br><span class="line">data[<span class="string">&quot;LoanAmount_Bin&quot;</span>] = binning(data[<span class="string">&quot;LoanAmount&quot;</span>], cut_points, labels)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pd.value_counts(data[<span class="string">&quot;LoanAmount_Bin&quot;</span>], sort=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">low          <span class="number">104</span></span><br><span class="line">medium       <span class="number">273</span></span><br><span class="line">high         <span class="number">146</span></span><br><span class="line">very high     <span class="number">91</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>解析以下这段代码，首先定义了一个cut_points列表，里面的三个点用于把<code>LoanAmount</code>字段分割成四个段，对应地，定义了labels列表，四个箱子(段)按贷款金额分别为低、中、高、非常高。然后把用于分箱的<code>LoanAmount</code>字段，cut_points，labels传入定义好的binning函数。</p>
<p>binning函数中，首先拿到分箱字段的最小值和最大值，把这两个点加入到break_points列表的一头一尾，这样用于切割的所有端点就准备好了。如果labels没有定义就默认按0~段数-1命名箱子。 最后借助pandas提供的cut函数进行分箱。</p>
<p>cut函数原型是<code>cut(x, bins, right=True, labels=None, retbins=False, precision=3, include_lowest=False)</code>，x是分箱字段，bins是区间端点，right指示区间右端是否闭合，labels不解释..retbins表示是否需要返回bins，precision是label存储和显示的精度，include_lowest指示第一个区间的左端是否闭合。</p>
<p>在把返回的列加入到data后，使用value_counts函数，统计了该列的各个离散值出现的次数，并且指定不需要对结果进行排序。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/version/0.17.1/generated/pandas.cut.html">Pandas Reference (cut)</a></p>
<h2 id="为分类变量编码">11.为分类变量编码</h2>
<p>有时，我们会面对要改动分类变量的情况。原因可能是：</p>
<p>有些算法（如logistic回归）要求所有输入项目是数字形式。所以分类变量常被编码为0, 1….(n-1) 有时同一个分类变量可能会有两种表现方式。如，温度可能被标记为“High”， “Medium”， “Low”，“H”， “low”。这里 “High” 和 “H”都代表同一类别。同理， “Low” 和“low”也是同一类别。但Python会把它们当作不同的类别。 <strong>一些类别的频数非常低，把它们归为一类是个好主意</strong>。</p>
<p>这里我们定义了一个函数，以字典的方式输入数值，用‘replace’函数进行编码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Pandas replace函数定义新函数：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coding</span>(<span class="params">col, codeDict</span>):</span></span><br><span class="line"></span><br><span class="line">  colCoded = pd.Series(col, copy=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> key, value <span class="keyword">in</span> codeDict.items():</span><br><span class="line"></span><br><span class="line">    colCoded.replace(key, value, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> colCoded</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#把贷款状态LoanStatus编码为Y=1, N=0:</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before Coding:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pd.value_counts(data[<span class="string">&quot;Loan_Status&quot;</span>]))</span><br><span class="line"></span><br><span class="line">data[<span class="string">&quot;Loan_Status_Coded&quot;</span>] = coding(data[<span class="string">&quot;Loan_Status&quot;</span>], &#123;<span class="string">&#x27;N&#x27;</span>:<span class="number">0</span>,<span class="string">&#x27;Y&#x27;</span>:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\nAfter Coding:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pd.value_counts(data[<span class="string">&quot;Loan_Status_Coded&quot;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Before Coding:</span><br><span class="line">Y    <span class="number">422</span></span><br><span class="line">N    <span class="number">192</span></span><br><span class="line">Name: Loan_Status, dtype: int64</span><br><span class="line"></span><br><span class="line">After Coding:</span><br><span class="line"><span class="number">1</span>    <span class="number">422</span></span><br><span class="line"><span class="number">0</span>    <span class="number">192</span></span><br><span class="line">Name: Loan_Status_Coded, dtype: int64</span><br></pre></td></tr></table></figure>
<p>在coding函数中第二个参数是一个dict，定义了需要编码的字段中每个值对应的编码。 实现上首先把传入的列转换为Series对象，copy参数表示是否要进行复制，关于copy可以看我另一篇笔记：<a target="_blank" rel="noopener" href="https://github.com/familyld/learnpython/blob/master/Difference_between_DeepCopy_and_ShallowCopy.md">深拷贝与浅拷贝的区别</a>。</p>
<p>copy得到的Series对象不会影响到原本DataFrame传入的列，所以可以放心修改，这里replace函数中的inplace参数表示是否直接在调用对象上作出更改，我们选择是，那么colCoded对像在调用replace后就会被修改为编码形式了。最后，把编码后的列加入到data中，比较编码前后的效果。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.replace.html#pandas.DataFrame.replace">Pandas Reference (replace)</a></p>
<h2 id="在一个数据框的各行循环迭代">12. 在一个数据框的各行循环迭代</h2>
<p>有时我们会需要用一个for循环来处理每行。比方说下面两种情况：</p>
<ol type="1">
<li>带数字的分类变量被当做数值。</li>
<li>带文字的数值变量被当做分类变量。</li>
</ol>
<p>先看看data表格的数据类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查当前数据类型：</span></span><br><span class="line"></span><br><span class="line">data.dtypes</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Gender                 <span class="built_in">object</span></span><br><span class="line">Married                <span class="built_in">object</span></span><br><span class="line">Dependents             <span class="built_in">object</span></span><br><span class="line">Education              <span class="built_in">object</span></span><br><span class="line">Self_Employed          <span class="built_in">object</span></span><br><span class="line">ApplicantIncome         int64</span><br><span class="line">CoapplicantIncome     float64</span><br><span class="line">LoanAmount            float64</span><br><span class="line">Loan_Amount_Term      float64</span><br><span class="line">Credit_History        float64</span><br><span class="line">Property_Area          <span class="built_in">object</span></span><br><span class="line">Loan_Status            <span class="built_in">object</span></span><br><span class="line">LoanAmount_Bin       category</span><br><span class="line">Loan_Status_Coded       int64</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>可以看到Credit_History这一列被当作浮点数，而实际上我们原意是分类变量。所以通常来说手动定义变量类型是个好主意。那这种情况下该怎么办呢？这时我们需要<strong>逐行迭代</strong>了。</p>
<p>首先创建一个包含变量名和类型的csv文件，读取该文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#载入文件:</span></span><br><span class="line">colTypes = pd.read_csv(<span class="string">r&#x27;F:\Datahack_Loan_Prediction\datatypes.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(colTypes)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">              feature         <span class="built_in">type</span></span><br><span class="line"><span class="number">0</span>             Loan_ID  categorical</span><br><span class="line"><span class="number">1</span>              Gender  categorical</span><br><span class="line"><span class="number">2</span>             Married  categorical</span><br><span class="line"><span class="number">3</span>          Dependents  categorical</span><br><span class="line"><span class="number">4</span>           Education  categorical</span><br><span class="line"><span class="number">5</span>       Self_Employed  categorical</span><br><span class="line"><span class="number">6</span>     ApplicantIncome   continuous</span><br><span class="line"><span class="number">7</span>   CoapplicantIncome   continuous</span><br><span class="line"><span class="number">8</span>          LoanAmount   continuous</span><br><span class="line"><span class="number">9</span>    Loan_Amount_Term   continuous</span><br><span class="line"><span class="number">10</span>     Credit_History  categorical</span><br><span class="line"><span class="number">11</span>      Property_Area  categorical</span><br><span class="line"><span class="number">12</span>        Loan_Status  categorical</span><br></pre></td></tr></table></figure>
<p>载入这个文件之后，我们能对它的逐行迭代，然后使用astype函数来设置表格的类型。这里把离散值字段都设置为categorical类型(对应np.object)，连续值字段都设置为continuous类型（对应np.float）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#迭代每行，指派变量类型。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注，astype函数用于指定变量类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, row <span class="keyword">in</span> colTypes.iterrows(): <span class="comment">#i: dataframe索引; row: 连续的每行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> row[<span class="string">&#x27;type&#x27;</span>]==<span class="string">&quot;categorical&quot;</span> <span class="keyword">and</span> row[<span class="string">&#x27;feature&#x27;</span>]!=<span class="string">&quot;Loan_ID&quot;</span>:</span><br><span class="line">        data[row[<span class="string">&#x27;feature&#x27;</span>]]=data[row[<span class="string">&#x27;feature&#x27;</span>]].astype(np.<span class="built_in">object</span>)</span><br><span class="line">    <span class="keyword">elif</span> row[<span class="string">&#x27;type&#x27;</span>]==<span class="string">&quot;continuous&quot;</span>:</span><br><span class="line">        data[row[<span class="string">&#x27;feature&#x27;</span>]]=data[row[<span class="string">&#x27;feature&#x27;</span>]].astype(np.<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.dtypes)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Gender                <span class="built_in">object</span></span><br><span class="line">Married               <span class="built_in">object</span></span><br><span class="line">Dependents            <span class="built_in">object</span></span><br><span class="line">Education             <span class="built_in">object</span></span><br><span class="line">Self_Employed         <span class="built_in">object</span></span><br><span class="line">ApplicantIncome      float64</span><br><span class="line">CoapplicantIncome    float64</span><br><span class="line">LoanAmount           float64</span><br><span class="line">Loan_Amount_Term     float64</span><br><span class="line">Credit_History        <span class="built_in">object</span></span><br><span class="line">Property_Area         <span class="built_in">object</span></span><br><span class="line">Loan_Status           <span class="built_in">object</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>
<p>可以看到现在信用记录(<code>Credit_History</code>)这一列的类型已经变成了‘object’ ，这在Pandas中代表分类变量。</p>
<p>特别地，无论是中文教程还是原版英文教程这个地方都出错了.. 中文教材代码中判断条件是错的，英文教程中没有考虑到<code>Loan_ID</code>这个字段，由于它被设定为表格的索引，所以它的类型是不被考虑的。</p>
<p>想了解更多请阅读 <a target="_blank" rel="noopener" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows">Pandas Reference (iterrows)</a></p>
<p>##结语</p>
<p>嗷，暂时没想到写啥，这篇拖了蛮久的时间才把后半部分给补上，因为前阵子实在太忙了... 不过确实学习了这些Pandas技巧之后，使用python处理数据的效率高了很多！！最重要的还是多多练习呗~</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>使效率倍增的Pandas使用技巧</p><p><a href="https://hunlp.com/posts/4991.html">https://hunlp.com/posts/4991.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ฅ´ω`ฅ</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2017-07-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-06-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记 </a></div></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wx.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/19036.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Pandas 学习</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/16175.html"><span class="level-item">深拷贝与浅拷贝的区别</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "65bef8fa828757fdc759643502ccc392",
            repo: "Cartride.github.io",
            owner: "Cartride",
            clientID: "8f4a2426c347380a6ee4",
            clientSecret: "8dc8cd44b071426b35d0bd60634941371170b798",
            admin: ["Cartride"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#布尔索引boolean-indexing"><span class="level-left"><span class="level-item">1</span><span class="level-item">1. 布尔索引(Boolean Indexing)</span></span></a></li><li><a class="level is-mobile" href="#apply函数"><span class="level-left"><span class="level-item">2</span><span class="level-item">2. Apply函数</span></span></a></li><li><a class="level is-mobile" href="#替换缺失值"><span class="level-left"><span class="level-item">3</span><span class="level-item">3. 替换缺失值</span></span></a></li><li><a class="level is-mobile" href="#透视表"><span class="level-left"><span class="level-item">4</span><span class="level-item">4. 透视表</span></span></a></li><li><a class="level is-mobile" href="#多重索引"><span class="level-left"><span class="level-item">5</span><span class="level-item">5. 多重索引</span></span></a></li><li><a class="level is-mobile" href="#二维表"><span class="level-left"><span class="level-item">6</span><span class="level-item">6. 二维表</span></span></a></li><li><a class="level is-mobile" href="#数据框合并"><span class="level-left"><span class="level-item">7</span><span class="level-item">7. 数据框合并</span></span></a></li><li><a class="level is-mobile" href="#给数据排序"><span class="level-left"><span class="level-item">8</span><span class="level-item">8. 给数据排序</span></span></a></li><li><a class="level is-mobile" href="#绘图箱型图直方图"><span class="level-left"><span class="level-item">9</span><span class="level-item">9. 绘图（箱型图&amp;直方图）</span></span></a></li><li><a class="level is-mobile" href="#为分类变量编码"><span class="level-left"><span class="level-item">10</span><span class="level-item">11.为分类变量编码</span></span></a></li><li><a class="level is-mobile" href="#在一个数据框的各行循环迭代"><span class="level-left"><span class="level-item">11</span><span class="level-item">12. 在一个数据框的各行循环迭代</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="MCFON" height="28"></a><p class="is-size-7"><span>&copy; 2021 ฅ´ω`ฅ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>