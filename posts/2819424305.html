<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>动态规划专题 - MCFON</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MCFON"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MCFON"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="DP 问题的一般思路  DP 定义 ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果 初始化 ——初始值可以通过一个简单的特例来确定 递推公式 + 边界条件 DP 优化 （可选）  Reference  常见的动态规划问题分析与求解 - 五岳 - 博客园 什么是动态规划？动态规划的意义是什么？ - 知乎"><meta property="og:type" content="blog"><meta property="og:title" content="动态规划专题"><meta property="og:url" content="https://hunlp.com/posts/2819424305.html"><meta property="og:site_name" content="MCFON"><meta property="og:description" content="DP 问题的一般思路  DP 定义 ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果 初始化 ——初始值可以通过一个简单的特例来确定 递推公式 + 边界条件 DP 优化 （可选）  Reference  常见的动态规划问题分析与求解 - 五岳 - 博客园 什么是动态规划？动态规划的意义是什么？ - 知乎"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kgyjxv2j30il0f5jvn.jpg"><meta property="article:published_time" content="2017-09-23T11:50:53.000Z"><meta property="article:modified_time" content="2019-11-17T22:30:18.482Z"><meta property="article:author" content="ฅ´ω`ฅ"><meta property="article:tag" content="动态规划"><meta property="article:tag" content="专题"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hunlp.com/posts/2819424305.html"},"headline":"动态规划专题","image":["https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg","https://tva1.sinaimg.cn/large/006y8mN6ly1g78kgyjxv2j30il0f5jvn.jpg"],"datePublished":"2017-09-23T11:50:53.000Z","dateModified":"2019-11-17T22:30:18.482Z","author":{"@type":"Person","name":"ฅ´ω`ฅ"},"publisher":{"@type":"Organization","name":"MCFON","logo":{"@type":"ImageObject","url":"https://hunlp.com/img/logo.png"}},"description":"DP 问题的一般思路  DP 定义 ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果 初始化 ——初始值可以通过一个简单的特例来确定 递推公式 + 边界条件 DP 优化 （可选）  Reference  常见的动态规划问题分析与求解 - 五岳 - 博客园 什么是动态规划？动态规划的意义是什么？ - 知乎"}</script><link rel="canonical" href="https://hunlp.com/posts/2819424305.html"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?b99420d7a06d2b3361a8efeaf6e20764";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-131608076-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-131608076-1');</script><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="MCFON" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/friend">友链</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-09-23T11:50:53.000Z" title="2017/9/23 下午7:50:53">2017-09-23</time>发表</span><span class="level-item"><time dateTime="2019-11-17T22:30:18.482Z" title="2019/11/18 上午6:30:18">2019-11-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a></span><span class="level-item">1 小时读完 (大约7593个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">动态规划专题</h1><div class="content"><h2 id="dp-问题的一般思路">DP 问题的一般思路</h2>
<ul>
<li><strong>DP 定义</strong> ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果</li>
<li><strong>初始化</strong> ——初始值可以通过一个简单的特例来确定</li>
<li><strong>递推公式</strong> + <strong>边界条件</strong></li>
<li><strong>DP 优化</strong> （可选）</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyuegb2312/p/3281264.html">常见的动态规划问题分析与求解 - 五岳</a> - 博客园</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189">什么是动态规划？动态规划的意义是什么？</a> - 知乎 <span id="more"></span> ## 背包问题</li>
</ul>
<h3 id="注关于恰好装满">【注】关于“恰好装满”</h3>
<ul>
<li><strong>如果要求恰好装满背包</strong>，可以在初始化时将 <code>dp[0] / dp[i][0]</code> 初始化 <code>0</code>，其他初始化为 <code>-INF</code>。这样即可保证最终得到的 <code>dp[N] / dp[N][M]</code> 是一种恰好装满背包的解；</li>
<li><strong>如果不要求恰好装满</strong>，则全部初始化为 <code>0</code> 即可。</li>
<li>可以这样理解：初始化的 dp 数组实际上就是在没有任何物品可以放入背包时的合法状态。
<ul>
<li>如果要求背包恰好装满，那么此时只有<strong>容量为 0</strong> 的背包可能被<strong>价值为 0</strong> 的物品“<strong>恰好装满</strong>”，其它容量的背包均<strong>没有合法的解</strong>，属于未定义的状态，它们的值就都应该是 <code>-INF</code> 。</li>
<li>如果背包并非必须被装满，那么任何容量的背包都有一个合法解，即“什么都不装”，这个解的价值为0，所以初始时状态的值也全部为 0 。</li>
</ul></li>
</ul>
<h3 id="背包">01 背包</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2602">HDOJ - 2602</a></p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有 n 个重量个价值分别为 w_i, v_i 的物品。</span><br><span class="line">从这些物品中选出总重量不超过 W 的物品，使其总价值最大。</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">1                // 用例数</span><br><span class="line">5 10             // 物品数 背包容量 N &lt;= 1000 , V &lt;= 1000</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line"></span><br><span class="line">14</span><br></pre></td></tr></table></figure></p>
<h4 id="二维-dp无优化">二维 DP（无优化）</h4>
<ul>
<li><strong>定义</strong>：<code>dp[i][j] := 从前 i 个物品中选取总重量不超过 j 的物品时总价值的最大值</code> &gt; <code>i</code> 从 1 开始计，包括第 <code>i</code> 个物品</li>
<li><strong>初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[0][j] = 0</span><br></pre></td></tr></table></figure></li>
<li><strong>状态转移</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j]            if j &lt; w[i] （当前剩余容量不够放下第 i 个物品）</span><br><span class="line">         = max&#123;                  else （取以下两种情况的最大值）</span><br><span class="line">                dp[i-1][j],             // 不拿第 i 个物品</span><br><span class="line">                dp[i-1][j-w[i]] + w[j]  // 拿第 i 个物品</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDOJ 地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> V, vector&lt;<span class="type">int</span>&gt;&amp; v, vector&lt;<span class="type">int</span>&gt;&amp; w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V + <span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// 不要求装满，初始化为 0 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;  <span class="comment">// 可能存在重量为 0，但有价值的物品</span></span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j)               <span class="comment">// 如果当前物品的重量大于剩余容量</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;      <span class="comment">// 用例数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N, V;                   <span class="comment">// N: 物品数量；V: 背包容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 保存每个物品的价值</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 保存每个物品的重量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">solve</span>(N, V, v, w);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二维-dp滚动数组">二维 DP（滚动数组）</h4>
<ul>
<li>在上述递推式中，<code>dp[i+1]</code> 的计算实际只用到了 <code>dp[i+1]</code> 和 <code>dp[i]</code>；</li>
<li>因此可以结合<strong>奇偶</strong>，通过两个数组滚动使用来实现重复利用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDOJ 地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> V, vector&lt;<span class="type">int</span>&gt;&amp; v, vector&lt;<span class="type">int</span>&gt;&amp; w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector&lt;vector&lt;int&gt; &gt; dp(N + 1, vector&lt;int&gt;(V + 1, 0));  // 不要求装满，初始化为 0 即可</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V + <span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// N+1 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;  <span class="comment">// 可能存在重量为 0，但有价值的物品</span></span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j)               <span class="comment">// 如果当前物品的重量大于剩余容量</span></span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = <span class="built_in">max</span>(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N &amp; <span class="number">1</span>][V];  <span class="comment">// 这里别忘了 N &amp; 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数略</span></span><br></pre></td></tr></table></figure>
<h4 id="一维-dp">一维 DP</h4>
<ul>
<li><strong>定义</strong>：<code>dp[j] := 重量不超过 j 公斤的最大价值</code></li>
<li><strong>递推公式</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max&#123;dp[j], dp[j-w[i]] + v[i]&#125;     若 j &gt; w[i]</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDOJ 地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602</span></span><br><span class="line"><span class="comment">// 一维 DP（滚动数组）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> V, vector&lt;<span class="type">int</span>&gt;&amp; v, vector&lt;<span class="type">int</span>&gt;&amp; w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(V + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= w[i]; j--) &#123;           <span class="comment">// 递推方向发生了改变</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数略</span></span><br></pre></td></tr></table></figure>
<h3 id="完全背包">完全背包</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://nyoj.top/problem/311">NYOJ - 311</a></p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01 背包中每个物品只有一个，所以只存在选或不选；</span><br><span class="line">完全背包中每个物品可以选取任意件。</span><br><span class="line"></span><br><span class="line">注意：本题要求是背包恰好装满背包时，求出最大价值总和是多少。如果不能恰好装满背包，输出 NO</span><br></pre></td></tr></table></figure></p>
<h4 id="二维-dp无优化-1">二维 DP（无优化）</h4>
<ul>
<li><strong>直观思路</strong>：在 01 背包的基础上在加一层循环</li>
<li><strong>递推关系</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0][j] = 0</span><br><span class="line">dp[i][j] = max&#123;dp[i - 1][j - k * w[i]] + k * v[i] | 0 &lt;= k&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt;= V; j++) &#123;  // 可能存在重量为 0 的物品</span><br><span class="line">        for (int k = 0; k * w[i] &lt;= j; k++)</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i-1][j - k*w[i]] + k*v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 <code>k</code> 的循环最坏可能从 0 到 <code>V</code>，因此时间复杂度为 <code>O(N*V^2)</code></li>
</ul></li>
<li><strong>注意到</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max&#123;dp[i - 1][j - k*w[i]] + k*v[i] | 0 &lt;= k&#125;</span><br><span class="line">                                                ------</span><br><span class="line">         = max&#123;dp[i - 1][j], max&#123;dp[i - 1][j - k*w[i]] + k*v[i]&#125; | 1 &lt;= k&#125;</span><br><span class="line">                                                                   ------</span><br><span class="line">         = max&#123;dp[i - 1][j], max&#123;dp[i - 1][(j-w[i]) - k*w[i]] + k*v[i] | 0 &lt;= k&#125; + v[i]&#125;</span><br><span class="line">                                           --------                      ------  ------</span><br><span class="line">                             ---------------------------------------------------</span><br><span class="line">         = max&#123;dp[i - 1][j], dp[i][j - w[i]] + v[i]&#125;</span><br><span class="line">                             ---------------</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt;= V; j++) &#123;</span><br><span class="line">        if (w[i] &gt; j)</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line">        else</span><br><span class="line">            dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">        //  dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); // 对比 01 背包</span><br><span class="line">        //                               ---------（唯一区别）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>完整代码</strong>
<ul>
<li>注意，这里要求的是恰好装满时的情况，所以需要将 <code>dp[i][0]</code> 全部初始化为 0，其他初始化为 <code>-INF</code> &gt; 以下代码因<strong>超内存</strong>无法通过 NYOJ 311； &gt; &gt; 可以 AC 的代码，请参考 <a href="#完全背包一维-dp">完全背包（一维 DP）</a> 和 <a href="#完全背包滚动数组">完全背包（滚动数组）</a> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NYOJ 311 会报超内存，所以无法测试</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N, V;       <span class="comment">// N 表示物品种类的数目，V 表示背包的总容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">w</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">v</span><span class="params">(N + <span class="number">1</span>)</span></span>;  <span class="comment">// w 表示重量，v 表示价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(V + <span class="number">1</span>, inf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[N][V] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[N][V]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="二维-dp滚动数组-1">二维 DP（滚动数组）</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NYOJ 311-完全背包: http://nyoj.top/problem/311 （未通过测试，报运行时错误）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_V = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N, V;       <span class="comment">// M 表示物品种类的数目，V 表示背包的总容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; w(N + 1), v(N + 1);  // w 表示重量，v 表示价值</span></span><br><span class="line">        <span class="comment">//for (int i = 1; i &lt;= N; i++)</span></span><br><span class="line">        <span class="comment">//    scanf(&quot;%d%d&quot;, &amp;w[i], &amp;v[i]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(V + 1, -inf));</span></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>][MAX_V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fill</span>(dp[i], dp[i] + MAX_V, -inf);</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> w, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w)</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = <span class="built_in">max</span>(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j], dp[i &amp; <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[N][V] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[N &amp; <span class="number">1</span>][V]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一维-dp-1">一维 DP</h4>
<ul>
<li>核心代码与 01 背包一致，只有第二层循环的<strong>递推方向不同</strong></li>
<li><strong>完整代码</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NYOJ 311-完全背包: http://nyoj.top/problem/311</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_V = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N, V;       <span class="comment">// M 表示物品种类的数目，V 表示背包的总容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; w(N + 1), v(N + 1);  // w 表示重量，v 表示价值</span></span><br><span class="line">        <span class="comment">//for (int i = 1; i &lt;= N; i++)</span></span><br><span class="line">        <span class="comment">//    scanf(&quot;%d%d&quot;, &amp;w[i], &amp;v[i]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; dp(V + 1, inf);   // 注意 NYOJ 的系统开辟稍大的 vector 就会导致超时</span></span><br><span class="line">        <span class="type">int</span> dp[MAX_V];</span><br><span class="line">        <span class="built_in">fill</span>(dp, dp + MAX_V, inf);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> w, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;v);      <span class="comment">// 避免开辟新的内存 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = w; j &lt;= V; j++) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[V] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[V]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多重背包-todo">多重背包 TODO</h3>
<h2 id="硬币问题">硬币问题</h2>
<h3 id="硬币找零">硬币找零</h3>
<blockquote>
<p>LeetCode - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/description/">322. 零钱兑换</a></p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。</span><br><span class="line">编写一个函数来计算可以凑成总金额所需的最少的硬币个数。</span><br><span class="line">如果没有任何一种硬币组合能组成总金额，返回 -1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">    输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">    输出: 3 </span><br><span class="line">    解释: 11 = 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">    输入: coins = [2], amount = 3</span><br><span class="line">    输出: -1</span><br><span class="line">    </span><br><span class="line">说明:</span><br><span class="line">    你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路</strong> - <strong>定义</strong>：<code>dp[i] := 组成总金额 i 时的最少硬币数</code> - <strong>初始化</strong>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = 0       若 i=0</span><br><span class="line">      = INF     其他</span><br></pre></td></tr></table></figure> - <strong>状态转移</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = min&#123; dp[j-coins[i]] + 1 | i=0,..,n-1 &#125;</span><br><span class="line">    </span><br><span class="line">其中 coins[i] 表示硬币的币值，共 n 种硬币</span><br></pre></td></tr></table></figure></p>
<p><strong>C++</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> INF = n + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=c; i&lt;=n; i++) &#123;            <span class="comment">//  i &gt;= c</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n] &lt; INF ? dp[n] : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="硬币组合">硬币组合</h3>
<blockquote>
<p>LeetCode - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/description/">518. 零钱兑换 II</a></p>
</blockquote>
<p><strong>C++</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = coins.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="最长公共子序列lcs">最长公共子序列（LCS）</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/c996bbb77dd447d681ec6907ccfb488a">最长公共子序列</a>_牛客网 - 求两个序列的最长公共字序列 - 示例：s1: "<strong>B</strong>D<strong>C</strong>A<strong>BA</strong>" 与 s2："A<strong>BCB</strong>D<strong>A</strong>B" 的<strong>一个</strong>最长公共字序列为 "BCBA" - 最长公共子序列不唯一，但是它们的长度是一致的 - 子序列不要求连续</p>
</blockquote>
<p><strong>思路</strong> - <strong>DP 定义</strong> - <strong>记</strong> <code>s[0:i] := s 长度为 i 的**前缀**</code> - <strong>定义</strong> <code>dp[i][j] := s1[0:i] 和 s2[0:j] 最长公共子序列的长度</code> - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 0    当 i=0 或 j=0 时</span><br></pre></td></tr></table></figure> - <strong>DP 更新</strong> - 当 <code>s1[i] == s2[j]</code> 时 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure> - 当 <code>s1[i] != s2[j]</code> 时 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure> - <strong>完整递推公式</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 0                              当 i=0 或 j=0 时</span><br><span class="line">         = dp[i-1][j-1] + 1               当 `s1[i-1] == s2[j-1]` 时</span><br><span class="line">         = max(dp[i-1][j], dp[i][j-1])    当 `s1[i-1] != s2[j-1]` 时</span><br></pre></td></tr></table></figure> - <strong>Code - C++</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LCS</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLCS</span><span class="params">(string A, <span class="type">int</span> n, string B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 已经初始化为全 0，就不必再手动初始化 DP 了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">                <span class="keyword">if</span> (A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])  <span class="comment">// 注意下标问题</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长公共子串">最长公共子串</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602">最长公共子串</a>_牛客网</p>
</blockquote>
<p><strong>题目描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于两个字符串，请设计一个时间复杂度为`O(m*n)`的算法，求出两串的最长公共子串的长度。</span><br><span class="line">（这里的 m 和 n 为两串的长度）</span><br></pre></td></tr></table></figure></p>
<p><strong>思路 - 暴力求解</strong></p>
<div data-align="center">
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg" height="300" />
</div>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Longest_common_substring_problem">Longest common substring problem</a> - Wikipedia</p>
</blockquote>
<p>暴力求解思路：每当找到一对元素相同时就<strong>斜向比较</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestSubstring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(string A, <span class="type">int</span> n, string B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> tmp_ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;  <span class="comment">// 每当找到一对元素相同</span></span><br><span class="line">                    tmp_ret += <span class="number">1</span>;    <span class="comment">// 斜向比较</span></span><br><span class="line">                    <span class="type">int</span> tmp_i = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> tmp_j = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (tmp_i &lt; n &amp;&amp; tmp_j &lt; m &amp;&amp; A[tmp_i++] == B[tmp_j++])  <span class="comment">// 注意边界</span></span><br><span class="line">                        tmp_ret++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, tmp_ret);  <span class="comment">// 记录最大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> - 注意：如果两个串完全相同的话，时间复杂度将退化为 <code>O(N^3)</code></p>
<strong>思路 - DP</strong> - <strong>DP 定义</strong> - <strong>记</strong> <code>s[0:i] := s 长度为 i 的**前缀**</code> - <del><strong>定义</strong> <code>dp[i][j] := s1[0:i] 和 s2[0:j] 最长公共子串的长度</code></del> - <code>dp[i][j]</code> 只有当 <code>s1[i] == s2[j]</code> 的情况下才是 <code>s1[0:i] 和 s2[0:j] 最长公共子串的长度</code> - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 0    当 i=0 或 j=0 时</span><br></pre></td></tr></table></figure> - <strong>DP 更新</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1     if s[i] == s[j]</span><br><span class="line">         = ;                    else pass</span><br></pre></td></tr></table></figure> - <strong>Code</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestSubstring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(string A, <span class="type">int</span> n, string B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 已经初始化为全 0，就不必再手动初始化 DP 了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, dp[i][j]);         <span class="comment">// 相比最长公共子序列，增加了这行</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ;                                 <span class="comment">// 去掉了这行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> - <strong>DP 优化</strong>：空间复杂度 <code>O(N)</code> - 好不容易找到的优化为 <code>O(N)</code> 的代码；多数优化直接优化到了 <code>O(1)</code> - 因为内层循环是逆序的，所以有点不好理解，可以画一个矩阵手推 DP 的更新过程，很巧妙 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestSubstring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(string A, <span class="type">int</span> n, string B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(n, m);</span><br><span class="line">            <span class="built_in">swap</span>(A, B);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] != B[j]) &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> - <strong>DP 优化</strong>：空间复杂度 <code>O(1)</code> - 两个字符串的比较总是按一行一行或一列一列来比较，因此至少要保存一行的数据 - 而如果是按照斜向遍历，其实只要保存一个数据即可
<div data-align="center">
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kgyjxv2j30il0f5jvn.jpg" height="300" />
</div>
<p>斜向遍历的策略很多，下面的代码是从右上角（<code>row=0, col=m-1</code>）开始遍历 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestSubstring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(string A, <span class="type">int</span> n, string B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>, col = m - <span class="number">1</span>; row &lt; n;) &#123;</span><br><span class="line">            <span class="type">int</span> i = row;</span><br><span class="line">            <span class="type">int</span> j = col;</span><br><span class="line">            <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i++] == B[j++])  <span class="comment">// 注意：无论走哪个分支，i 和 j 都会 ++ 一次</span></span><br><span class="line">                    dp += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col &gt; <span class="number">0</span>) </span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码其实就是把下面的两段循环合并了 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LongestSubstring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(string A, <span class="type">int</span> n, string B, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col = m<span class="number">-1</span>; col &gt;= <span class="number">0</span>; col--) &#123;</span><br><span class="line">            dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = col; i &lt; n &amp;&amp; j &lt; m; i++, j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">                    dp += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; n; row++) &#123;</span><br><span class="line">            dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = row, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++, j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">                    dp += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="最长递增子序列lis">最长递增子序列（LIS）</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/585d46a1447b4064b749f08c2ab9ce66">最长递增子序列</a>_牛客网</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/description/">最长上升子序列</a> - LeetCode &gt; 牛客假设给定的数组中不存在重复元素，LeetCode 可能存在重复元素</p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于一个数字序列，请设计一个复杂度为O(nlogn)的算法，返回该序列的最长上升子序列的长度</span><br><span class="line"></span><br><span class="line">测试样例：</span><br><span class="line">  [2,1,4,3,1,5,6],7</span><br><span class="line">返回：</span><br><span class="line">  4</span><br><span class="line">说明：</span><br><span class="line">  [1,3,5,6] 是其中一个最长递增子序列</span><br></pre></td></tr></table></figure></p>
<p><strong>思路0 - <code>O(N^2)</code></strong> - LIS 可以转化成 LCS (最长公共子序列) 问题 - 用另一个序列保存给定序列的<strong>排序</strong>结果 - <code>O(NlogN)</code> - 则问题转化为求这两个序列的 LCS 问题 - <code>O(N^2)</code></p>
<strong>思路1 - <code>O(N^2)</code>解法</strong> - <strong>DP 定义</strong> - <strong>记</strong> <code>nums[0:i] := 序列 nums 的前 i 个元素构成的子序列</code> - <strong>定义</strong> <code>dp[i] := nums[0:i] 中 LIS 的长度</code> - 实际并没有严格按照这个定义，中间使用一个变量记录当前全局最长的 LIS - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[:] = 1  // 最长上升子序列的长度最短为 1</span><br></pre></td></tr></table></figure> - <strong>DP 更新 - <code>O(N^2)</code>的解法</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max&#123;dp[j]&#125; + 1,  if nums[i] &gt; nums[j]</span><br><span class="line">      = max&#123;dp[j]&#125;,      else</span><br><span class="line">where 0 &lt;= j &lt; i</span><br></pre></td></tr></table></figure> 如果只看这个递推公式，很可能会写出如下的<strong>错误代码</strong>
<details>
<p><summary><b>错误代码（点击展开）</b></summary></p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AscentSequence</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> - 这段代码的问题在于 <code>dp[i]</code> 应该等于 <code>max&#123;dp[j]&#125;</code> 对应的那个 <code>dp[j]+1</code>，且<strong>只增加一次</strong> - 这么写可能会导致 <code>dp[i]</code> 被增加多次 &gt; <a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5597658.html">动态规划求解最长递增子序列的长度 - hapjin</a> - 博客园</p>
</details>
<ul>
<li>下面是网上比较流行的一种<strong>递推公式</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[j] + 1,  if nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + 1</span><br><span class="line">      = pass,       else</span><br><span class="line">where 0 &lt;= j &lt; i</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：此时并没有严格按照定义处理 dp，它只记录了当 <code>nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + 1</code> 时的 LIS；不满足该条件的情况<strong>跳过</strong>了；所以需要额外一个变量记录当前已知全局的 LIS</li>
</ul></li>
<li><strong>Code</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AscentSequence</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>思路2 - <code>O(NlogN)</code></strong> - 该解法的<strong>思想</strong>是：长度为 <code>i</code> 的 LIS 的<strong>尾元素</strong>应该大于长度为 <code>i-1</code> 的尾元素 - <strong>DP 定义</strong> - <strong>定义</strong> <code>dp[i] := 长度为 i 的 LIS 的最小尾元素</code> - <strong>DP 更新</strong> - 二分查找 nums[j] 在 dp 中的 <del>upper_bound 位置</del> <strong>lower_bound 位置</strong> - upper_bound 位置指的是序列中第一个大于 nums[j] 的元素所在的位置 - lower_bound 位置指的是序列中第一个大于等于 nums[j] 的元素所在的位置 - C++ 中分别实现了 upper_bound 和 lower_bound，定义在 <code>&lt;algorithm&gt;</code> 中 - 如果在末尾，则插入；反之则替换 - upper_bound 只能用于不存在重复元素的情况；而 lower_bound 可以兼容两种情况</p>
<ul>
<li><strong>Code</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AscentSequence</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongest</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 这里用 upper_bound 也可以</span></span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[j]);</span><br><span class="line">            <span class="keyword">if</span> (it == dp.<span class="built_in">end</span>())</span><br><span class="line">                dp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 这里只能使用 lower_bound</span></span><br><span class="line">            <span class="keyword">auto</span> it_l = <span class="built_in">lower_bound</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), nums[j]);</span><br><span class="line">            <span class="comment">// auto it_u = upper_bound(dp.begin(), dp.end(), nums[j]);</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (it_l == dp.<span class="built_in">end</span>())</span><br><span class="line">                dp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it_l = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最长回文子序列">最长回文子序列</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/">最长回文子序列</a> - LeetCode</p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">  输入:</span><br><span class="line">    &quot;bbbab&quot;</span><br><span class="line">  输出:</span><br><span class="line">    4</span><br><span class="line">  一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路</strong> - 相比最长回文子串，最长回文子序列更像<strong>最长公共子序列</strong>，只是改变了循环方向 - <strong>DP 定义</strong> - <strong>记</strong> <code>s[i:j] := 字符串 s 在区间 [i:j] 上的子串</code> - <strong>定义</strong> <code>dp[i][j] := s[i:j] 上回文序列的长度</code> - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][i]   = 1  // 单个字符也是一个回文序列</span><br></pre></td></tr></table></figure> - <strong>DP 更新</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1] + 2,              if s[i] == s[j]</span><br><span class="line">         = max(dp[i+1][j], dp[i][j-1]),   else</span><br><span class="line"></span><br><span class="line">比较一下 LCS 的递推公式</span><br><span class="line">dp[i][j] = 0                              当 i=0 或 j=0 时</span><br><span class="line">         = dp[i-1][j-1] + 1               当 `s1[i-1] == s2[j-1]` 时</span><br><span class="line">         = max(dp[i-1][j], dp[i][j-1])    当 `s1[i-1] != s2[j-1]` 时</span><br></pre></td></tr></table></figure> - <strong>Code</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)             <span class="comment">// 子串结束位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = j<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;     <span class="comment">// 子串开始位置</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长回文子串">最长回文子串</h3>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/b4525d1d84934cf280439aeecc36f4af">最长回文子串</a>_牛客网</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/">最长回文子串</a> - LeetCode &gt; 牛客网只需要输出长度；LeetCode 还需要输出一个具体的回文串</p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">  输入: &quot;babad&quot;</span><br><span class="line">  输出: &quot;bab&quot;</span><br><span class="line">  注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure></p>
<p><strong>思路 - <code>O(N^2)</code></strong> - <strong>DP 定义</strong> - <strong>记</strong> <code>s[i:j] := 字符串 s 在区间 [i:j] 上的子串</code> - <strong>定义</strong> <code>dp[i][j] := s[i:j] 是否是一个回文串</code> - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][i]   = 1  // 单个字符也是一个回文串</span><br></pre></td></tr></table></figure> - <strong>DP 更新</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1],  if s[i] == s[j]</span><br><span class="line">         = 0,             else</span><br><span class="line"></span><br><span class="line">注意到：如果 j - i &lt; 2 的话（比如 j=2, i=1），dp[i+1][j-1]=dp[2][1] 会出现不符合 DP 定义的情况</span><br><span class="line">所以需要添加边界条件</span><br><span class="line">  </span><br><span class="line">  dp[i][i+1] = 1,  if s[i] == s[i+1]</span><br><span class="line">             = 0,  else</span><br><span class="line">  </span><br><span class="line">该边界条件可以放在初始化部分完成；但是建议放在递推过程中完成过更好（为了兼容牛客和LeetCode）</span><br></pre></td></tr></table></figure> - <strong>Code</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网 AC</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Palindrome</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLongestPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;         <span class="comment">// 子串结束位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=j<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;  <span class="comment">// 子串开始位置</span></span><br><span class="line">                <span class="keyword">if</span> (j-i &lt; <span class="number">2</span>)</span><br><span class="line">                    dp[i][j] = (s[i]==s[j]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;  <span class="comment">// 因为 dp 全局初始化就是 0，这里其实可以不写</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; len)</span><br><span class="line">                    len = j-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode - 只要添加一个记录开始位置的变量即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>;    <span class="comment">// 记录开始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;         <span class="comment">// 子串结束位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=j<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;  <span class="comment">// 子串开始位置</span></span><br><span class="line">                <span class="keyword">if</span> (j-i &lt; <span class="number">2</span>)</span><br><span class="line">                    dp[i][j] = (s[i]==s[j]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;  <span class="comment">// 因为 dp 全局初始化就是 0，这里其实可以不写</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; len) &#123;</span><br><span class="line">                    beg = i;  <span class="comment">// 保存开始位置</span></span><br><span class="line">                    len = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(beg, len);  <span class="comment">// 截取子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>Manacher 算法 - <code>O(N)</code></strong> &gt; <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Stay-Hungry-Stay-Foolish/p/7622496.html">算法-最长回文子串(Manacher算法)</a> - 琼珶和予 - 博客园</p>
<h2 id="最大连续子序列和">最大连续子序列和</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/afe7c043f0644f60af98a0fba61af8e7">最大连续子序列</a>_牛客网 &gt; 牛客网要求同时输出最大子序列的首尾元素</p>
</blockquote>
<strong>思路 - 基本问题：只输出最大连续子序列和</strong> - <strong>DP 定义</strong> - <strong>记</strong> <code>a[0:i] := 序列 a 在区间 [0:i] 上的子序列</code> - <strong>定义</strong> <code>dp[i] := a[0:i] 上的最大子序列和</code> - 实际并没有严格按照上面的定义，中间使用一个变量记录当前全局的最大连续子序列和 - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[0] = a[0]</span><br></pre></td></tr></table></figure> - <strong>DP 更新</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 只要 dp[i] &gt; 0 就一直累加下去，一旦小于 0 就重新开始</span><br><span class="line">dp[i] = dp[i-1] + a[i],     if dp[i-1] &gt; 0</span><br><span class="line">      = a[i],               else</span><br><span class="line"></span><br><span class="line">ret = max&#123;ret, dp[i]&#125;       // 只要大于 0 就累加会导致 dp[i] 保存的并不是 a[0:i] 中的最大连续子序列和</span><br><span class="line">                            // 所以需要一个变量保存当前全局的最大连续子序列和</span><br></pre></td></tr></table></figure>
<details>
<p><summary><b>直观实现-无优化-空间复杂度<code>O(N)</code>（点击展开）</b></summary></p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = a[i];</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 5 -3 2 4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1 -2 3 4 -10 6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">-3 -1 -2 -5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
</details>
<ul>
<li><p><strong>DP 优化</strong></p>
<p>注意到每次递归实际只用到了 <code>dp[i-1]</code>，实际只要用到一个变量，空间复杂度 <code>O(1)</code> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = INT_MIN;</span><br><span class="line">        <span class="type">int</span> max_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; <span class="number">0</span>)       <span class="comment">// 如果大于 0 就一直累加</span></span><br><span class="line">                max_cur += a[i];</span><br><span class="line">            <span class="keyword">else</span>                   <span class="comment">// 一旦小于 0 就重新开始</span></span><br><span class="line">                max_cur = a[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; ret)     <span class="comment">// 保存找到的最大结果</span></span><br><span class="line">                ret = max_cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以上可以简写成下面两行代码</span></span><br><span class="line">            <span class="comment">//max_cur = max(max_cur + a[i], a[i]);</span></span><br><span class="line">            <span class="comment">//ret = max(ret, max_cur);</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong>思路 - 输出区间/首尾</strong> - 增加两个变量即可 - 注意：题目要求，如果序列中全是负数，则输出 0，以及整个序列的首尾元素 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网 AC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = INT_MIN;</span><br><span class="line">        <span class="type">int</span> max_cur = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> beg = a[<span class="number">0</span>], end = a[n<span class="number">-1</span>];  <span class="comment">// 输出首尾</span></span><br><span class="line">        <span class="comment">// int beg = 0, end = n-1;     // 输出区间</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tmp_beg;  <span class="comment">// 保存临时 beg</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max_cur += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                max_cur = a[i];</span><br><span class="line">                tmp_beg = a[i];</span><br><span class="line">                <span class="comment">// tmp_beg = i;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; ret) &#123;  <span class="comment">// &gt; 表明保存的是第一次出现的最大和，&gt;= 则为最后一次（未验证）</span></span><br><span class="line">                ret = max_cur;</span><br><span class="line">                beg = tmp_beg;</span><br><span class="line">                end = a[i];  <span class="comment">// 输出首尾</span></span><br><span class="line">                <span class="comment">// end = i;  // 输出区间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, <span class="number">0</span>, a[<span class="number">0</span>], a[n<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d\n&quot;, 0, 0, n-1);</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, ret, beg, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编辑距离">编辑距离</h2>
<blockquote>
<p>LeetCode-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/description/">编辑距离</a></p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数。</span><br><span class="line"></span><br><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line">  插入一个字符</span><br><span class="line">  删除一个字符</span><br><span class="line">  替换一个字符</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">  输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">  输出: 3</span><br><span class="line">  解释: </span><br><span class="line">  horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">  rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">  rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure> - <strong>注意</strong>：编辑距离指的是将 <strong>word1 转换成 word2</strong></p>
<p><strong>思路</strong> - 用一个 dp 数组维护两个字符串的<strong>前缀</strong>编辑距离 - <strong>DP 定义</strong> - <strong>记</strong> <code>word[0:i] := word 长度为 i 的**前缀子串**</code> - <strong>定义</strong> <code>dp[i][j] := 将 word1[0:i] 转换为 word2[0:j] 的操作数</code> - <strong>初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = i  // 每次从 word1 删除一个字符</span><br><span class="line">dp[0][j] = j  // 每次向 word1 插入一个字符</span><br></pre></td></tr></table></figure> - <strong>递推公式</strong> - <code>word1[i] == word1[j]</code> 时 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1]</span><br></pre></td></tr></table></figure> - <code>word1[i] != word1[j]</code> 时，有三种更新方式，<strong>取最小</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// word[1:i] 表示 word 长度为 i 的前缀子串</span><br><span class="line">dp[i][j] = min(&#123; dp[i-1][j]   + 1 ,     // 将 word1[1:i-1] 转换为 word2[1:j] 的操作数 + 删除 word1[i] 的操作数(1)</span><br><span class="line">                 dp[i][j-1]   + 1 ,     // 将 word1[0:i] 转换为 word2[0:j-1] 的操作数 + 将 word2[j] 插入到 word1[0:i] 之后的操作数(1)</span><br><span class="line">                 dp[i-1][j-1] + 1 &#125;)    // 将 word1[0:i-1] 转换为 word2[0:j-1] 的操作数 + 将 word1[i] 替换为 word2[j] 的操作数(1)</span><br></pre></td></tr></table></figure> <!-- - **注意到** `dp[i][j]` 是单调的，因此可以将整个过程归纳为
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    dp[i][j] = min(&#123; dp[i-1][j]   + 1 ,</span><br><span class="line">                     dp[i][j-1]   + 1 ,</span><br><span class="line">                     dp[i-1][j-1] + (int)(word1[i] == word1[j]) &#125;)</span><br><span class="line">    ``` --&gt;</span><br><span class="line">- **C++**</span><br><span class="line">  ```C++</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      int minDistance(string word1, string word2) &#123;</span><br><span class="line">          int m = word1.length();</span><br><span class="line">          int n = word2.length();</span><br><span class="line">          vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line"></span><br><span class="line">          // 初始化 dp</span><br><span class="line">          for (int i = 1; i &lt;= m; i++)</span><br><span class="line">              dp[i][0] = i;</span><br><span class="line">          for (int j = 1; j &lt;= n; j++)</span><br><span class="line">              dp[0][j] = j;</span><br><span class="line"></span><br><span class="line">          // 更新 dp</span><br><span class="line">          for (int i = 1; i &lt;=m; i++)</span><br><span class="line">              for (int j = 1; j &lt;= n; j++)</span><br><span class="line">                  if (word1[i - 1] == word2[j - 1])</span><br><span class="line">                      dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                  else</span><br><span class="line">                      dp[i][j] = min(&#123; dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] &#125;)  + 1;</span><br><span class="line">              </span><br><span class="line">          return dp[m][n];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>DP 优化</strong></p>
<ul>
<li>注意到每次更新 <code>dp[i][j]</code> 只需要用到 <code>dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]</code>。因此实际上不需要用到二维 DP</li>
<li>具体见下方代码</li>
</ul>
<details>
<p><summary><b>Code - 优化为一维 DP（点击展开）</b></summary></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            cur[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> pre = cur[<span class="number">0</span>];</span><br><span class="line">            cur[<span class="number">0</span>] = j;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="type">int</span> temp = cur[i];</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    cur[i] = pre;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    cur[i] = <span class="built_in">min</span>(pre + <span class="number">1</span>, <span class="built_in">min</span>(cur[i] + <span class="number">1</span>, cur[i - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                pre = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[m]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<h2 id="矩阵中的最大正方形">矩阵中的最大正方形</h2>
<blockquote>
<p>LeetCode-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/description/">221. 最大正方形</a></p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在一个由 0 和 1 组成的二维矩阵 M 内，找到只包含 1 的最大正方形，并返回其面积。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><strong>思路</strong> - <strong>DP 定义</strong>：<code>dp[i][j] := 以 M[i][j] 为正方形**右下角**所能找到的最大正方形的边长</code> - 注意保存的是边长 - 因为 <code>dp</code> 保存的不是全局最大值，所以需要用一个额外变量更新结果 - <strong>初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = M[i][0]</span><br><span class="line">dp[0][j] = M[0][j]</span><br></pre></td></tr></table></figure> - <strong>递推公式</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min&#123;dp[i-1][j], </span><br><span class="line">               dp[i][j-1], </span><br><span class="line">               dp[i-1][j-1]&#125; + 1  若 M[i][j] == 1</span><br><span class="line">         = 0                      否则</span><br></pre></td></tr></table></figure> &gt; 注意到，本题的递推公式与 <a href="#编辑距离">编辑距离</a> 完全一致</p>
<p><strong>C++</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (M.<span class="built_in">empty</span>() || M[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> row = M.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> col = M[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(row, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = M[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, dp[i][<span class="number">0</span>]);         <span class="comment">// 别忘了这里也要更新 mx</span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = M[<span class="number">0</span>][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, dp[<span class="number">0</span>][j]);         <span class="comment">// 别忘了这里也要更新 mx</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;row; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123; dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &#125;) + <span class="number">1</span>;</span><br><span class="line">                    mx = <span class="built_in">max</span>(mx, dp[i][j]); <span class="comment">// 更新 mx</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mx * mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="鹰蛋问题">鹰蛋问题</h2>
<blockquote>
<p>Power Eggs http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1894</p>
</blockquote>
<p><strong>问题描述</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">教授手上有`M`个一模一样的鹰蛋，教授想研究这些蛋的硬度`E`，测试方法是将蛋从高为`N`层的楼上不断自由落下；</span><br><span class="line">每个蛋在`E+1`层及以上掉下都会碎，而在`E`层及以下不会碎；每个蛋可以重复测试直到它碎了为止。</span><br><span class="line"></span><br><span class="line">例如：蛋从第 1 层掉下碎了，则`E=0`；蛋从第`N`层掉下未碎，则`E=N`。</span><br><span class="line"></span><br><span class="line">求在给定`M`和`N`下为了确定`E`在**最坏情况下**需要测试的最少次数。</span><br><span class="line">如果比较的次数大于 32，输出 &quot;Impossible&quot;。</span><br><span class="line"></span><br><span class="line">范围：1 ≤ N ≤ 2000000007，1 ≤ K ≤ 32</span><br><span class="line"></span><br><span class="line">示例：`N=10, K=1`，则`ans=10`</span><br><span class="line">说明：如果只有一个蛋，那么只能将这个蛋一层层往上尝试；</span><br><span class="line">  因此在最坏情况下，它最少要测试 10 次才能确定 `E`</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong> - 如果只有 <code>M=1</code> 个蛋，那么只能从第一层开始一层一层往上尝试，最坏情况下的最少次数为 <code>N</code> - 如果蛋的数量足够多，那么问题转变为二分查找，最坏情况下的最少次数为 <strong><code>logN</code> 上取整</strong></p>
<p><strong>思路</strong> - <strong>DP 定义</strong>：<code>dp[i][j] := i 个蛋比较 j 次所能确定的最高楼层</code> - <strong>DP 初始化</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1] = 1  // i 个蛋比较 1 次所能确定的最高楼层是 1</span><br><span class="line">dp[1][j] = j  // 1 个蛋比较 j 次所能确定的最高楼层为 j</span><br></pre></td></tr></table></figure> - <strong>DP 更新</strong> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j-1] + dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure> <strong>说明</strong>：TODO（不理解是如何得到这个递推式的）</p>
<ul>
<li><strong>C++</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OJ 地址：http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1894</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_K = <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_T = <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line">LL dp[MAX_K][MAX_T];          <span class="comment">// 使用 LL 防止溢出，long 不保证比 int 更大</span></span><br><span class="line"><span class="comment">// dp[i][j] := i 个蛋比较 j 次所能确定的最高楼层</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_K; i++)</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; MAX_T; j++)</span><br><span class="line">        dp[<span class="number">1</span>][j] = j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAX_K; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; MAX_T; j++)</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">//printf(&quot;%lld&quot;, dp[32][32]);  // 4294967295 == 2^32 - 1，用 int 会溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T;          <span class="comment">// 1 ≤ T ≤ 10000</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N, K;   <span class="comment">// 1 ≤ N ≤ 2000000007 &lt; 2^31, 1 ≤ K ≤ 32</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; MAX_T; j++) &#123;</span><br><span class="line">            <span class="comment">// 注意：dp[i][j] 表示的是 i 个蛋比较 j 次所能确定的最高楼层</span></span><br><span class="line">            <span class="keyword">if</span> (dp[K][j] &gt;= N) &#123;</span><br><span class="line">                ret = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Reference</strong> - <a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/7d57940ef12d2af90242e6ac.html">从《鹰蛋》一题浅析对动态规划算法的优化</a>_百度文库</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>动态规划专题</p><p><a href="https://hunlp.com/posts/2819424305.html">https://hunlp.com/posts/2819424305.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ฅ´ω`ฅ</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2017-09-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-11-18</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><a class="link-muted mr-2" rel="tag" href="/tags/%E4%B8%93%E9%A2%98/">专题</a></div><div class="bdsharebuttonbox"><a class="bds_more" href="#" data-cmd="more"></a><a class="bds_qzone" href="#" data-cmd="qzone" title="分享到QQ空间"></a><a class="bds_tsina" href="#" data-cmd="tsina" title="分享到新浪微博"></a><a class="bds_tqq" href="#" data-cmd="tqq" title="分享到腾讯微博"></a><a class="bds_renren" href="#" data-cmd="renren" title="分享到人人网"></a><a class="bds_weixin" href="#" data-cmd="weixin" title="分享到微信"></a></div><script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wx.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/1475683312.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Numpy笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/2232347017.html"><span class="level-item">Python惯例</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><script src="https://cdn.jsdelivr.net/npm/@waline/client@1.5.4/dist/Waline.min.js"></script><script>Waline({
            el: '#waline-thread',
            serverURL: "https://waline-server-gilt.vercel.app",
            path: window.location.pathname,
            lang: "zh-CN",
            visitor: false,
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],
            dark: "auto",
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "enable",
            
            pageSize: 10,
            
            
            math: false,
            copyright: true,
            locale: {"placeholder":"Comment here..."},
        });</script></div></div></div><div class="column column-left  order-1 is-sticky"><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="MCFON" height="28"></a><p class="is-size-7"><span>&copy; 2022 ฅ´ω`ฅ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>