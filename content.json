{"pages":[],"posts":[{"title":"第一篇 监督学习","text":"笔记摘要 统计学习或机器学习一般包括监督学习、无监督学习、强化学习，有时还包括半监督学习、主动学习监督学习 监督学习指从标注数据中学习预测模型的机器学习问题，其本质是学习输入到输出的映射的统计规律。 输入变量$X$和输出变量$Y$有不同的类型，可以是连续或是离散的。根据输入输出变量的不同类型，对预测任务给予不同的名称：输入与输出均为连续变量的预测问题称为回归问题；输出变量为有限个离散变量的预测问题称为分类问题；输入与输出变量均为变量序列的预测问题称为标注问题。 无监督学习 无监督学习指从无标注数据中学习预测模型的机器学习问题，其本质是学习数据中的统计规律或内在结构。 无监督学习旨在从假设空间中选出在给定评价标准下的最优模型，模型可以实现对数据的聚类、降维或是概率估计。强化学习 强化学习指智能系统在与环境的连续互动中学习最优行为策略的机器学习问题，其本质是学习最优的序贯决策。 智能系统的目标不是短期奖励的最大化，而是长期累积奖励的最大化。强化学习过程中，系统不断地试错，以达到学习最优策略地目的。 半监督学习与主动学习 半监督学习指利用标注数据和未标注数据学习预测模型地机器学习问题。其旨在利用未标注数据中的信息，辅助标注数据，进行监督学习，以较低的成本达到较好的学习效果。 主动学习是指机器不断主动给出实例让教师进行标注，然后利用标注数据学习预测模型的机器学习问题。主动学习的目标是找出对学习最有帮助的实例让教师标注，以较小的标注代价达到较好的学习效果。 这两种学习更接近监督学习。 实现统计学习方法的步骤 得到一个有限的训练数据集合 确定包含所有可能的模型的假设空间，即学习模型的集合 确定模型选择的准则，即学习的策略 实现求解最优模型的算法，即学习的算法 通过学习方法选择最优的模型 利用学习的最优模型对新数据进行预测或分析 在上述步骤中涵盖了统计学习方法三要素：模型，策略，算法 在监督学习过程中，模型就是所要学习的条件概率分布或者决策函数。注意书中的这部分描述，整理了一下到表格里： 假设空间$\\mathcal F$ 输入空间$\\mathcal X$ 输出空间$\\mathcal Y$ 参数空间 决策函数 $\\mathcal F ={f$|$Y=f_{\\theta}(x), \\theta \\in \\bf R \\it ^n}$ 变量 变量 $\\bf R\\it ^n$ 条件概率分布 $\\mathcal F ={P$|$P_\\theta(Y$|$X), \\theta \\in \\bf R \\it ^n}$ 随机变量 随机变量 $\\bf R\\it ^n$ 损失函数与风险函数 损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。 损失函数(loss function)或代价函数(cost function)定义为给定输入$X$的预测值$f(X)$和真实值$Y$之间的非负实值函数，记作$L(Y,f(X))$。 风险函数(risk function)或期望损失(expected loss)和模型的泛化误差的形式是一样的$R_{exp}(f)=E_p[L(Y, f(X))]=\\int_{\\mathcal X\\times\\mathcal Y}L(y,f(x))P(x,y), {\\rm d}x{\\rm d}y$上式是模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失(期望损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是期望，以及平均意义下的。这个表示其实就是损失的均值，反映了对整个数据的预测效果的好坏。 经验风险(empirical risk)或经验损失(empirical loss) $R_{emp}(f)=\\frac{1}{N}\\sum^{N}_{i=1}L(y_i,f(x_i))$ 上式是模型$f$关于训练样本集的平均损失。根据大数定律，当样本容量N趋于无穷大时，经验风险趋于期望风险。 结构风险(structural risk) $R_{srm}(f)=\\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i))+\\lambda J(f)$ 其中$J(f)$为模型复杂度, $\\lambda \\geqslant 0$是系数，用以权衡经验风险和模型复杂度。 常用损失函数损失函数数值越小，模型就越好 0-1损失 $L(Y,f(X))=\\begin{cases}1, Y \\neq f(X) \\0, Y=f(X) \\end{cases}$ 平方损失 $L(Y,f(X))=(Y-f(X))^2$ 绝对损失 $L(Y,f(X))=|Y-f(X)|$ 对数损失$L(Y,P(Y|X))=−logP(Y|X)$ ERM与SRM经验风险最小化(ERM)与结构风险最小化(SRM) 极大似然估计是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计，下面习题1.2中给出了证明。 结构风险最小化等价于正则化 贝叶斯估计中的最大后验概率估计是结构风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化等价于最大后验概率估计。 算法 算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么杨的计算方法来求解最优模型。 模型评估与选择 训练误差和测试误差是模型关于数据集的平均损失。 注意：统计学习方法具体采用的损失函数未必是评估时使用的损失函数。 过拟合是指学习时选择的模型所包含的参数过多，以至出现这一模型对已知数据预测得很好，但对未知数据预测得很差的现象。可以说模型选择旨在避免过拟合并提高模型的预测能力。 正则化与交叉验证 模型选择的典型方法是正则化.。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化就越大。比如，正则化项可以是模型参数向量的范数。 $L(w)=\\frac{1}{N}\\sum_{i=1}^{N}(f(x_i;w)-y_i)^2+\\frac{\\lambda}{2}|w|^2$ $|w|$表示向量$w$的$L_2$范数 正则化符合奥卡姆剃刀原理：如无必要，勿增实体。在应用于模型选择中时，可以理解为：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单的才是最好的模型，也是应该选择的模型。 交叉验证的基本想法时重复地利用数据；把给定地数据进行切分，将切分的数据集组合为训练集和测试集，在此基础上反复地进行训练、测试以及模型选择。 主要有简单交叉验证，S折交叉验证，留一交叉验证三种。 在算法学习的过程中，测试集可能是固定的，但是验证集和训练集可能是变化的。比如S折交叉验证的情况下，分成S折之后，其中的S-1折作为训练集，1折作为验证集，计算这S个模型每个模型的平均测试误差，最后选择平均测试误差最小的模型。这个过程中用来验证模型效果的那一折数据就是验证集。 生成模型与判别模型监督学习方法可分为生成方法(generative approach)与判别方法(discriminative approach) 生成方法(generative approach) 可以还原出联合概率分布$P(X,Y)$ 收敛速度快, 当样本容量增加时, 学到的模型可以更快收敛到真实模型 当存在隐变量时仍可以用 判别方法(discriminative approach) 直接学习条件概率$P(Y|X)$或者决策函数$f(X)$ 直接面对预测, 往往学习准确率更高 可以对数据进行各种程度的抽象, 定义特征并使用特征, 可以简化学习问题 习题解答 1.1 说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学方法三要素 伯努利模型是定义在取值为0与1的随机变量上的概率分布。统计学分为两派：经典统计学派和贝叶斯统计学派。两者的不同主要是，经典统计学派认为模型已定，参数未知，参数是固定的，只是还不知道；贝叶斯统计学派是通过观察到的现象对概率分布中的主观认定不断进行修正。 极大似然估计用的是经典统计学派的策略，贝叶斯估计用的是贝叶斯统计学派的策略；为了得到使经验风险最小的参数值，使用的算法都是对经验风险求导，使导数为0。 定义随机变量$A$为一次伯努利试验的结果，$A$的取值为${0,1}$，概率分布为$P(A)$： $$P(A=1)=θ，P(A=0)=1-θ$$ * 极大似然估计 $$L(θ)=\\prod_{i=1}^nP(A_i)=θ^k(1-θ)^{n-k}$$$$θ=\\arg\\max_{θ}L(θ)=\\frac{k}{n}$$上述估计通过取对数求导得到，$A_i$为第$i$次随机试验 贝叶斯估计$$P(θ|A_1,A_2,…，A_n)=\\frac{P(A_1,A_2,…，A_n|θ)P(θ)}{P(A_1,A_2,…，A_n)}$$ 根据观察到的结果修正$θ$，也就是假设$θ$是随机变量，$θ$服从β分布，有很多个可能的取值，我们要取的值是在已知观察结果的条件下使$θ$出现概率最大的值。上式分母是不变的，求分子最大就可以。 $$\\begin{aligned}\\theta&amp;=arg\\max \\limits_\\theta {P(A_1,A_2,…,A_n|\\theta)P(\\theta)} \\&amp;= arg\\max \\limits_\\theta {\\prod_{i=1}^{n}P(A_i|\\theta)P(\\theta)} \\&amp;=arg \\max \\limits_\\theta {\\theta^k(1-\\theta)^{n-k}\\theta^{a-1}(1-\\theta)^{b-1}} \\&amp;=\\frac{k+(a-1)}{n+(a-1)+(b-1)}\\end{aligned}$$ β分布是一个作为伯努利分布和二项式分布的共轭先验分布的密度函数，是指一组定义在$(0,1)$区间的连续概率分布，有两个参数α，β&gt;0。选定参数后就可以确定$\\theta$。 统计学习方法的三要素为模型，策略，算法。 1.2 通过经验风险最小化推导极大似然估计。证明模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。 模型是条件概率分布：$P_θ(Y|X)$，损失函数是对数损失函数：$L(Y,P_θ(Y|X))=−logP_θ(Y|X)$经验风险为：$$ \\begin{aligned}R_{emp}(f)&amp;=\\frac{1}{N}\\sum_{i=1}^{N}L(y_i,f(x_i)) \\&amp;=\\frac{1}{N}\\sum_{i=1}^{N}-logP(y_i|x_i) \\&amp;=-\\frac{1}{N}\\sum_{i=1}^{N}logP(y_i|x_i)\\end{aligned}$$ 极大似然估计的似然函数为：$$L(\\theta)=\\prod_DP_{\\theta}(Y|X)$$ * 取对数$$log(L(\\theta))=\\sum_DlogP_{\\theta}(Y|X)$$$$arg\\max_\\theta\\sum_DlogP_{\\theta}(Y|X)=arg\\min_{\\theta}\\sum_D-logP_{\\theta}(Y|X)$$ 因此，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。","link":"/2021/05/23/%E7%AC%AC%E4%B8%80%E7%AF%87-%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"title":"CYK算法详解与代码实现","text":"概述在计算机科学领域，CYK算法（也称为Cocke–Younger–Kasami算法）是一种用来对上下文无关文法（CFG，Context Free Grammar）进行语法分析（parsing）的算法。该算法最早由John Cocke, Daniel Younger and Tadao Kasami分别独立提出，其中John Cocke还是1987年度的图灵奖得主。CYK算法是基于动态规划思想设计的一种自底向上语法分析算法。 乔姆斯基范式我们首先来谈谈CNF的话题。通常把一门语言定义成一些由单词组成的词串（也就是句子）构成的集合。所以如果问两种语法（或文法）是否等价，其实就是要考察它们能否生成完全一样的词串集合。事实上，两个完全不同的CFG是不可能生成相同语言的。 而谈到两种语法“等价”，我们又可以定义弱等价和强等价两种类型的等价： 如果两种语法能够生成相同的词串集合，且为每个句子都赋与相同的短语结构（phrase structure），也就是说仅允许对non-terminal symbols进行重命名，那么它们就是强等价的。 如果两种语法能够生成相同的词串集合，但不会为每个句子都赋与相同的短语结构，那么它们就是弱等价的。 CNF(Chomsky Normal Form)是一种这样的语法标准： 如果一个$CFG是 \\varepsilon-free$，而且它的规则只有如下两种形式: $A\\rightarrow BC$ $A\\rightarrow a$ 那么这个CFG就是CNF形式的，可见CNF语法都是二分叉的。任何语法都可以转化成一个弱等价的CNF形式，具体方法如下： Step 1: Convert $A\\rightarrow Bc$ to $A\\rightarrow BC$,$C\\rightarrow c$ Step 2: Convert $A\\rightarrow BCD$ to $A\\rightarrow BX,X\\rightarrow CD$ CYK算法CYK算法处理的语法必须是CNF形式的，所以如果输入的是任意文法，那么需要按照前面的步骤把CFG转换成CNF形式。 CYK算法是用来判断一个字符串是否属于某个CNF语法，故设输入的字符串w长度为n。 接下来我们需要用程序填一个动态规划的状态转移表，这里我们叫这个表parse table。 parse table的规模为$(n + 1) \\times n$ 算法原理注意，我们前面说过CYK是一种自底向上的算法，这里的自底向上意思是从单词开始，朝向 S(句子)工作。所以在上图我们填写的大方向是从左到右填写的。S 位于表的右上角，表示成功。算法描述如下：其中，i 和 j 指示的内容如下图所示： 我们定义$PT[n + 1][n]$表示parse table，且$PT[n, :]$依次存储字符串w中的每一个符号$a_1, a_2, \\dots, a_n$。$$\\begin{bmatrix}&amp; &amp;\\dots &amp; \\&amp; \\vdots &amp; \\ddots &amp; \\a_1 &amp; a_2 &amp; \\dots &amp;a_n\\end{bmatrix} %]]&gt;$$我们设根据给定CNF，即G能推导出w中第i到第j个字符的串的集合为$x_{i,j}$ 为了填写这个表，我们一行一行，自下而上地处理。每一行对应一种长度的子串。最下面一行对应长度为1的子串，倒数第二行对应长度为2的子串，以此类推。最上面一行就对应长度为n的子串，即w本身。计算该表的任何一个表项的方法如下： 对于最下面一行的元素，即$x_{i,i}$，是使得$A \\rightarrow a_i$是G的产生式的变元A的集合。 对于不在最下面一行的元素，我们需要找到符合以下条件的变元A的集合： 1、整数k满足$i \\leq k &lt; j$ 2、$B \\in X_{i,k}$ 3、$C \\in X_{k+1, j}$ 4、$A \\rightarrow BC$是G的产生式 根据这样的方法，我们可以填出一个下三角矩阵。 例如： CNF文法G的产生式：$$S \\rightarrow AB|BC \\A \\rightarrow BA|a \\B \\rightarrow CC|b \\C \\rightarrow AB|a$$对L(G)测试字符串$w = baaba$的成员性构造Parse Table如下：$$\\begin{bmatrix}x_{1,5}={S, A,C} &amp; &amp; &amp; &amp; \\&amp; x_{2,5}={S, A, C} &amp; &amp; &amp; \\&amp; x_{2,4}={B} &amp; x_{3,5}={B} &amp; &amp; \\x_{1,2} = {S, A} &amp; x_{2,3}={B} &amp; x_{3,4}={S, C} &amp; x_{4,5}={S, A} &amp;\\x_{1,1} = {B} &amp; x_{2,2} = {A, C} &amp; x_{3,3} ={A, C} &amp; x_{4,4}={B } &amp; x_{5,5}={A,C} \\a_1 = b &amp; a_2 = a &amp; a_3 = a &amp; a_4 = b &amp; a_5 = a\\end{bmatrix} %]]&gt;$$最终得到$x_{1,5}$集合之后，判断起始变元$S$是否属于$x_{1,5}$。如果是，则w可被G接受，反之不接受。 代码实现cyk.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!usr/bin/env/python 3.6.5#-*- coding: utf-8 -*-'''Python 3.6.5installed module: - tkinter'''import reimport itertoolsimport tkinterfrom tkinter import ttkclass CNF(object): def __init__(self): self.__rules = {} def read_file(self, filename): with open(filename, 'r') as inFile: for line in inFile.readlines(): line = re.sub('[\\n\\t ]', '', line) rec_begin = line[:line.find('-')] for element in line[line.find('&gt;') + 1:].split('|'): if element in self._CNF__rules: self.__rules[element].append(rec_begin) else: self._CNF__rules[element] = [rec_begin] def get_inf(self, tar): if isinstance(tar, list) == False: exit() inf_set = [] for tarEle in tar: inf_set.extend(self.__rules.get(tarEle, [])) return list(set(inf_set))class CYK(object): def __init__(self, filename): if isinstance(filename, str) == False: exit() self.__str = '' self.__srtlen = 0 self.__canvas = [] self.__myCNF = CNF() self.__myCNF.read_file(filename) def get_str(self): self._CYK__str = input('input string:\\n').strip() if len(self._CYK__str) == 0: exit() self._CYK__srtlen = len(self._CYK__str) # MaxRow == MaxCol + 1 self._CYK__canvas = list(list([] for tmp in range(self._CYK__srtlen)) for tmp in range(self._CYK__srtlen + 1)) for iter in range(self._CYK__srtlen): self._CYK__canvas[self._CYK__srtlen][iter].append(self._CYK__str[iter]) def CYK_process(self): # for lowest level for col in range(self._CYK__srtlen): self._CYK__canvas[self._CYK__srtlen - 1][col].extend(self._CYK__myCNF.get_inf(self._CYK__canvas[self._CYK__srtlen][col])) # for upper level for row in range(self._CYK__srtlen - 2, -1, -1): for col in range(row + 1): mid_set = set() idx_i, idx_j = col + 1, col - row + self._CYK__srtlen for mid_k in range(idx_i, idx_j): fir_row, fir_col = idx_i - mid_k - 1 + self._CYK__srtlen, idx_i - 1 sec_row, sec_col = mid_k - idx_j + self._CYK__srtlen, mid_k mid_set |= set(obj[0] + obj[1] for obj in itertools.product(self._CYK__canvas[fir_row][fir_col], self._CYK__canvas[sec_row][sec_col])) self._CYK__canvas[row][col].extend(self._CYK__myCNF.get_inf(list(mid_set))) # get answer if 'S' in self._CYK__canvas[0][0]: print ('%s can be accepted.' % self._CYK__str) else: print ('%s can not be accepted.' % self._CYK__str) def GUI_show(self): def exc(line, step, row): if isinstance(line, list) == False and isinstance(line[0], list) == False: exit() for col in range(len(line)): line[col] = str('{' + '%s, ' * (len(line[col]) - 1) + '%s' * (len(line[col]) &gt; 0) + '}') % (tuple(line[col])) if col &lt;= row: line[col] = 'X%d,%d = ' % (col + 1, step + col + 1) + line[col] return (line) # default window = tkinter.Tk() window.geometry('800x400') window.title('CYK algorithm') table = ttk.Treeview(window, height = 10, show = 'headings') table['columns'] = (list(elem for elem in range(self._CYK__srtlen))) for col in range(self._CYK__srtlen): table.column(str(col), width = 100) # y&amp;x scrollbar yscrollbar = tkinter.Scrollbar(window, orient = tkinter.VERTICAL, command = table.yview) table.configure(yscrollcommand = yscrollbar.set) yscrollbar.pack(side = tkinter.RIGHT, fill = tkinter.Y) xscrollbar = tkinter.Scrollbar(window, orient = tkinter.HORIZONTAL, command = table.xview) table.configure(xscrollcommand = xscrollbar.set) xscrollbar.pack(side = tkinter.TOP, fill = tkinter.X) # insert information for row in range(self._CYK__srtlen): table.insert('', row, values = exc(self._CYK__canvas[row], self._CYK__srtlen - row - 1, row)) table.insert('', self._CYK__srtlen, values = (self._CYK__canvas[self._CYK__srtlen])) # end table.pack(side = tkinter.TOP, expand = 1, fill = tkinter.BOTH) window.mainloop()def main(): myCYK = CYK('./CNF.cfg') myCYK.get_str() myCYK.CYK_process() myCYK.GUI_show()if __name__ == '__main__': main() 实验效果 参考文献概率上下文无关文法PCFG Tagging Problems, and Hidden Markov Models NLP底层技术之语言模型","link":"/2018/07/15/CYK%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"统计学习方法","slug":"统计学习方法","link":"/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"监督学习","slug":"监督学习","link":"/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"},{"name":"CYK","slug":"CYK","link":"/tags/CYK/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"NLP","slug":"深度学习/NLP","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/"}]}