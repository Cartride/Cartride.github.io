{"pages":[{"title":"","text":"6649bb90de78fc0b38a5269b4e0c8cc2","link":"/baidu_verify_code-X0OEA0Cq6O.html"},{"title":"","text":"关于 我的足迹 我的足迹 个人简介 Cal EECS Phd Candidate","link":"/about/index.html"}],"posts":[{"title":"标识符","text":"关键字（25个） 1234if for func case struct import go type chan defer default packagemap const else break select interfacevar goto range return switch continue fallthrough 预定义名字（30+个） 123456789101112内建常量： true false iota nil内建类型： int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64bool： byte rune string error内建函数： make delete complex panic append copy close len cap real imag new recover 变量 变量声明 Go变量声明的三种方式： 123var a int // 声明一个变量，默认为0var b = 10 // 声明并初始化，且自动推导类型c := 20 // 初始化，且自动推导 注意： - :=定义变量只能在函数内部使用，所以经常用var定义全局变量 - Go对已经声明但未使用的变量会在编译阶段报错：** not used - Go中的标识符以字母或者下划线开头，大小写敏感 - Go推荐使用驼峰命名 多变量声明 12345678var a,b string var a1,b1 string = &quot;哼&quot;,&quot;哈&quot; var a2,b2 int = 1,2 //类型可以直接省略c,d := 1,2var( e int f bool) 零值机制 Go变量初始化会自带默认值，不像其他语言为空，下面列出各种数据类型对应的0值： 1234567891011int 0int8 0int32 0int64 0uint 0x0rune 0 //rune的实际类型是 int32byte 0x0 // byte的实际类型是 uint8float32 0 //长度为 4 bytefloat64 0 //长度为 8 bytebool falsestring &quot;&quot; 变量值互换 12m,n = n,m //变量值互换temp,_ = m,n //匿名变量：变量值互换，且丢弃变量n _丢弃变量 _是个特殊的变量名，任何赋予它的值都会被丢弃。该变量不占用命名空间，也不会分配内存。 1_, b := 34, 35 //将值`35`赋予`b`，并同时丢弃`34`： := 声明的注意事项 下面是正确的代码示例： 12in, err := os.Open(file)out, err := os.Create(file) // 此处的 err其实是赋值 但是如果在第二行赋值的变量名全部和第一行一致，则编译不通过： 12in, err := os.Open(file)in, err := os.Create(file) // 即 := 必须确保至少有一个变量是用于声明 :=只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么:=将会在当前词法域重新声明一个新的变量。 常量 常量：在编译阶段就确定下来的值，程序运行时无法改变。 定义方式： 1234const A = 3const PI float32 = 3.1415const mask = 1 &lt;&lt; 3 //常量与表达式//const Home = os.GetEnv(“HOME”); //错误写法：常量赋值是一个编译期行为，右边的值不能出现在运行时才能得到结果的值。 数据类型 值类型与引用类型 12345678910111213141516值类型： 整型（int8,uint等） # 基础类型之数字类型 浮点型（float32，float64） # 基础类型之数字类型 复数() # 基础类型之数字类型 布尔型（bool） # 基础类型 字符串（string） # 基础类型 数组 # 复合类型 结构体（struct） # 复合类型引用类型：即保存的是对程序中一个变量的或状态的间接引用，对其修改将影响所有该引用的拷贝 指针 切片（slice） 字典（map） 函数 管道（chan） 接口（interface） 注意： - 基本数据类型是Go语言实际的原子 - 复合数据类型是由不同的方式组合基本类型构造出来的数据类型，如：数组，slice，map，结构体 - 没有字符型，使用byte来保存单个字母 类型判断： 1fmt.Printf(&quot;%T&quot;,a); //输出a的类型 注意：int32和int是两种不同的类型，编译器不会自动转换，需要类型转换。 常见格式化输出 1234567891011%% %字面量%b 二进制整数值，基数为2，或者是一个科学记数法表示的指数为2的浮点数%c 字符型%d 十进制数值，基数为10%e 科学记数法e表示的浮点或者复数%E 科学记数法E表示的浮点或者附属%f 标准计数法表示的浮点或者附属%o 8进制度%p 十六进制表示的一个地址值%s 字符串%T 输出值的类型 类型别名 12type bigint int64 //支持使用括号，同时起多个别名var a bigint 多数据分组书写 123456789101112const( i = 100 pi = 3.1415 prefix = &quot;Go_&quot;)var( i int pi float32 prefix string) 关键字iota 关键字iota声明初始值为0，每行递增1： 12345678910111213141516171819const ( a = iota // 0 b = iota // 1 c = iota // 2)const ( d = iota // 0 e // 1 f // 2)//如果iota在同一行，则值都一样const ( g = iota //0 h,i,j = iota,iota,iota // 1,1,1 // 此处不能定义缺省常量，如 k = 3 会编译错误 ) 内存结构","link":"/posts/8632.html"},{"title":"流程控制之-条件语句","text":"判断语句 if if判断示例： 123//初始化与判断写在一起： if a := 10; a == 10if i == '3' { } if的特殊写法： 12if err := Connect(); err != nil { // 这里的 err!=nil 才是真正的if判断表达式} 分支语句 switch 示例： 12345678switch num { case 1: // case 中可以是表达式 fmt.Println(&quot;111&quot;) case 2: fmt.Println(&quot;222&quot;) default: fmt.Println(&quot;000&quot;)} 贴士： - Go保留了break，用来跳出switch语句，上述案例的分支中默认就书写了该关键字 - Go也提供fallthrough，代表不跳出switch，后面的语句无条件执行 流程控制之-循环语句 for循环 Go只支持for一种循环语句，但是可以对应很多场景： 1234567891011121314151617181920212223//传统的for循环for init,condition;post{}//for循环简化var i intfor ; ; i++ { if(i &gt; 10){ break; }}//类似while循环for condition {}//死循环for{}//for range:一般用于遍历数组、切片、字符串、map、管道for k, v := range []int{1,2,3} {} 跳出循环 常用的跳出循环关键字： - break用于函数内跳出当前for、switch、select语句的执行 - continue用于跳出for循环的本次迭代。 - goto可以退出多层循环 break跳出循环案例(continue同下)： 1234567891011121314OuterLoop: for i := 0; i &lt; 2; i++ { for j := 0; j &lt; 5; j++ { switch j { case 2: fmt.Println(i,j) break OuterLopp case 3: fmt.Println(i,j) break OuterLopp } } } goto跳出多重循环案例： 123456789101112for x:=0; x&lt;10; x++ { for y:=0; y&lt;10; x++ { if y==2 { goto breakHere } } }breakHere: fmt.Println(&quot;break&quot;) 贴士：goto也可以用来统一错误处理。 123456if err != nil { goto onExit}onExit: fmt.Pritln(err) exitProcess()","link":"/posts/36713.html"},{"title":"运算符","text":"运算符汇总 123456算术运算符： + - * / % ++ -- 关系运算符： == != &lt;= &gt;= &lt; &gt; 逻辑运算符： ! &amp;&amp; ||位运算： &amp;（按位与） |（按位或） ^（按位取反） &lt;&lt;（左移） &gt;&gt;（右移）赋值运算符： = += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=其他运算符： &amp;（取地址） *（取指针值） &lt;-（Go Channel相关运算符） Go自增自减少 Go中只有后--和后++，且自增自减不能用于表达式中，只能独立使用： 123a = i++ //错误用法if i++ &gt; 0 {} //错误用法i++ //正确用法 位运算 12345&amp; 按位与，参与运算的两个数二进制位相与：同时为1，结果为1，否则为0| 按位或，参与运算的两个数二进制位相或：有一个为1，结果为1，否则为0^ 按位异或：二进位不同，结果为1，否则为0&lt;&lt; 按位左移：二进位左移若干位，高位丢弃，低位补0，左移n位其实就是乘以2的n次方&gt;&gt; 按位右移：二进位右移若干位，右移n位其实就是除以2的n次方 优先级","link":"/posts/4074.html"},{"title":"高级特性","text":"在Python中，代码越少越简单约好。基于这一思想，后面的几个篇章介绍Python一些非常有用的高级特性。 比方说构造一个1~99的奇数列表，可以简单地用循环实现： 12345L = []n = 1while n &lt;= 99: L.append(n) n = n + 2 切片 切片即取一个list或tuple部分元素的操作。 当我们需要取列表前n个元素，即索引0~N-1的元素时，有两种方法： 1.方法1是用循环 12345678&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])...&gt;&gt;&gt; r['Michael', 'Sarah', 'Tracy'] 2.方法2是利用切片操作符 12&gt;&gt;&gt; L[0:3]['Michael', 'Sarah', 'Tracy'] 如果经常要取指定的索引范围，用循环就显得太过繁琐了，Python提供了切片操作来简化这个过程。注意，切片操作的索引左闭右开。 如果索引从0开始，还可以改写为 L[:3]。 如果索引到列表最后结束，同样可以简略写为 L[0:]。 此外，Python还支持倒数切片。列表最后一项的索引在倒数中为-1。 1234&gt;&gt;&gt; L[-2:]['Bob', 'Jack']&gt;&gt;&gt; L[-2:-1]['Bob'] 特别地，切片操作还支持每隔k个元素取1个这样的操作。先创建一个0~99的整数列表： 123&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 取后10个只需起始索引为-10即可： 12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前十个数隔两个取一个： 12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 所有数，隔五个取一个： 12&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 注意！对list进行切片操作得到的还是list；对tuple进行切片操作得到的还是tuple。 特别地，字符串也可看为一种list，同样可以使用切片操作。 迭代 Python中可迭代的对象包括字符串，list，tuple，dict，set和文件等等。 对这些可迭代对象可以使用 for...in 循环来遍历。Python对for循环的抽象程度高于Java和C，所以即使没有下标也能迭代。 比如循环遍历一个dict： 1234567&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}&gt;&gt;&gt; for key in d:... print(key, d[key])...a 1c 3b 2 直接打印key会打印所有dict中的key，更改迭代的写法为 for value in d.values() 就变为迭代dict中所有的value。 如果同时要访问key和value，还可以使用 for k, v in d.items()。 字符串同样可以用for循环迭代： 123456&gt;&gt;&gt; for ch in 'ABC':... print(ch)...ABC 要判断一个对象是否可迭代对象可以通过collections模块的 Iterable 类型来判断： 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 正如上面迭代dict一样，for循环可以同时引用两个甚至多个变量： 12345678910111213&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 例子里的 enumerate 方法通过enumerate官方文档了解，它返回一个枚举对象，并且传入参数可迭代时它就是一个可迭代的对象。 可以用 list(enumerate(可迭代对象)) 把一个可迭代对象变为元素为tuple类型的list，每个tuple有两个元素，形式如：(序号，原可迭代对象内容)。 并且使用enumerate时可以指定开始的序号，enumerate(iterable, start=0)，不写时默认参数为0，即序号从0开始。 可以自己指定为其他数。 列表生成式 列表生成式即List Comprehensions，是Python内置的用于创建list的方式。 比方说生成1到10，可以： 12&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 要生成 [1x1, 2x2, 3x3, ..., 10x10]平方序列，笨办法是用循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 用列表生成式只用一个语句就可以了： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 写列表生成式时，把要生成的元素 x * x 放到前面，后面跟for循环，就可以把list创建出来。 在for循环后面还可以加上if判断，比方说这个例子用于筛选出偶数的平方数： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 使用两层循环还可以生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 列出当前目录下所有文件和目录名也非常简单： 123&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录['.emacs.d', '.Trash', 'Applications', 'Desktop', 'Documents'] 前面一节提到for循环迭代可以同时用两个变量，这里列表生成式同样可以用两个变量来生成list。 123&gt;&gt;&gt; d = {'x': 'A', 'y': 'B', 'z': 'C' }&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] 把list中所有字符串的大写字母换成小写： 123&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']&gt;&gt;&gt; [s.lower() for s in L]['hello', 'world', 'ibm', 'apple'] 生成器 通过列表生成式可以简单地创建列表，但受到内存限制，列表容量是有限的。如果列表元素很多，而我们仅需访问前面一部分元素，则会造成很大的存储空间的浪费。 生成器(generator)就意在解决这个问题，允许在循环过程中不断推算出后续元素，而不用创建完整的list。在Python中，这种边循环边计算的机制称为生成器。 和列表生成式的区别很简单，仅仅是把外层的[]方括号换成()圆括号。 123456&gt;&gt;&gt; L = [x * x for x in range(5)]&gt;&gt;&gt; L[0, 1, 4, 9, 16]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 生成器无法通过索引访问，因为它保存的是算法，要遍历生成器需要通过 next() 函数。 1234567891011121314&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; next(g)16&gt;&gt;&gt; next(g)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 当到达最后一个元素时，再使用 next() 就会出现 StopIteration 错误。 当然，实际遍历生成器时不会这样一个一个用 next() 方法遍历，用for循环进行迭代即可。 123456789&gt;&gt;&gt; g = (x * x for x in range(5))&gt;&gt;&gt; for n in g:... print(n)...014916 当算法比较复杂，用简单for循环无法写出来时，还可以通过函数来实现： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done' 比方说这个计算斐波那契数列的函数，稍微改写一下即可变成generator： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b #只修改这里 a, b = b, a + b n = n + 1 return 'done' 这是定义generator的另一种方法，如果一个函数定义中包含yield关键字，则该函数就变为一个generator。 123&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt; 函数是顺序执行，遇到return语句或到达最后一行函数语句就返回。而变成generator的函数，在每次调用 next() 的时候执行，遇到yield就返回，下次执行会从yield的地方开始。 123456789&gt;&gt;&gt; for n in fib(6):... print(n)...112358 同样地，把函数改成generator后，我们不需要用next()方法获取写一个返回值，而是只借用for循环进行迭代。 但是这样就拿不到fib函数return语句的值(即字符串done)，要获取这个值必须捕获 StopIteration 这个错误，它的value就是我们返回的值： 12345678910111213141516&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:... try:... x = next(g)... print('g:', x)... except StopIteration as e:... print('Generator return value:', e.value)... break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 生成器的工作原理是：在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。 对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句就结束generator，for循环随之结束。 普通函数和生成器函数可以通过调用进行区分，调用普通函数会直接返回结果，调用生成器函数则会返回一个生成器对象。 杨辉三角 要求使用生成器生成1~10行的杨辉三角。 提示：把每一行当作一个list。 1234567def triangles(max): n = 0 b = [1] while n &lt; max: yield b b = [1] + [ b[i] + b[i + 1] for i in range(len(b) - 1)] + [1] n = n + 1 这段代码非常短，但是已经充分实现了题目要求，值得欣赏! 123456789&gt;&gt;&gt; for L in triangles(6):... L...[1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1] 代码里面有两个窍门，一是列表相加，注意不是列表元素相加。 列表相加相当于把后一个列表的元素全部append到前一个列表。如： 1234&gt;&gt;&gt; L = [1,2]&gt;&gt;&gt; R = [3,4]&gt;&gt;&gt; L+R[1, 2, 3, 4] 上面代码中的b即把每一行当作一个list，因为每一行的开头结尾都是1，所以可以每一行的list看作三个list的相加，一头一尾两个list是只有1个元素1的list，中间的list用列表生成式生成。 另一个窍门就是这里的列表生成式。 注意这里计算时还没赋值，引用列表b的内容是上一行的信息，所以能巧妙地借助上一行计算相邻两数之和，最终得到含有n-2项的中间列表。 补充解析一下代码执行的过程： 123456b = [1], n = 0b = [1] + [1] = [1,1], n = 1 # 无中间列表b = [1] + [1+1] + [1], n = 2 # 中间列表包含1个元素b = [1] + [1+2, 2+1] + [1], n = 3 # 中间列表包含2个元素b = [1] + [1+3, 3+3, 3+1] + [1], n = 4 # 中间列表包含4个元素... ... 迭代器 迭代器即Iterator， 前面说到可以通过collections模块的Iterable类型来判断一个对象是否可迭代对象。 这里引入Iterator的概念，可以通过类似的方式判断。 list，dict，str虽然都Iterable，却不是Iterator。 生成器都是Iterator。Iterator的特性允许对象通过next()函数不断返回下一个值。 123456789&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance({}, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False 要把list，dict，str变为Iterator可以使用 iter() 函数： 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True Python的Iterator对象表示的其实是一个数据流，Iterator对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。 可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算，也因此能够节省空间。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 小结 凡是可作用于for循环的对象都是 Iterable 类型； 凡是可作用于 next() 函数的对象都是 Iterator 类型，它们表示一个惰性计算的序列； 集合数据类型如list、dict、str等是 Iterable 但不是 Iterator，不过可以通过 iter() 函数获得一个 Iterator 对象。 Python的for循环本质上就是通过不断调用 next() 函数实现的，例如： 12for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于： 12345678910# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break","link":"/posts/49058.html"},{"title":"进制与转换","text":"常见进制 二进制：只有0和1，Go中不能直接使用二进制表示整数 八进制：0-7，以数字0开头 十进制：0-9 十六进制：0-9以及A-F，以0X开头，A-F以及X不区分大小写 #### 任意进制转换为十进制 二进制转十进制：从最低位开始，每个位上数乘以2（位数-1）次方然后求和 &gt; 1011 = 1*20 + 1*21 + 0*22 + 1*23 = 11 八进制转十进制：从最低位开始，每个位上数乘以8（位数-1）次方然后求和 &gt; 0123 = 3*80 + 2*81 + 1*82 + 0*83 = 83 其他进制转十进制同理。 十进制转其他进制 十进制转二进制：不断除以2，直到0为止,余数倒过来即可，如图： 十进制转八进制：不断除以8，直到0为止，余数倒过来即可。 十进制转十六进制：同上 其他进制互转 二进制转换八进制：将二进制数从低位开始，每三位一组，转换成八进制数即可 二进制转十六进制：将二进制数从低位开始，每四位一组，转换成十六进制数即可 八进制转换二进制：将八进制数每1位转换成一个3位的二进制数（首位0除外） 十六进制转二进制：将十六进制每1位转换成对应的一个4位的二进制数即可 反码补码 对于有符号数而言，二进制的最高为是符号位：0表示正数，1表示负数。 比如 1在二进制中： 121 二进制位：0000 0001-1 二进制位：1000 0001 正数的原码、反码、补码都一样，负数的反码=原码符号位不变，其他位取反，补码是反码+1 1234 1 -1原码 0000 0001 1000 0001反码 0000 0001 1111 1110补码 0000 0001 1111 1111 常见理解： - 0的反码补码都是0 - 计算机中是以补码形式运算的","link":"/posts/4263.html"},{"title":"数值类型","text":"整数类型 整数类型有无符号(如int)和带符号(如uint)两种,这两种类型的长度相同，但具体长度取决于不同编译器的实现。 int8、int16、int32和int64四种有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，同样uint8、uint16、uint32和uint64对应四种无符号整数类型。 123456789101112131415# 有符号类型：int 32位系统占据4个字节（范围和int32一样），64位系统占据8个字节（范围和int64一样） int8 占据1字节 范围 -128 ~ 127int16 占据2字节 范围 -2(15次方) ~ 2（15次方）-1int32 占据4字节 范围 -2(31次方) ~ 2（31次方）-1int64 占据8字节 范围 -2(63次方) ~ 2（63次方）-1rune int32的别称# 无符号类型：uint 32位系统占据4个字节（范围和uint32一样），64位系统占据8个字节（范围和uint64一样） uint8 占据1字节 范围 0 ~ 255uint16 占据2字节 范围 0 ~ 2（16次方）-1uint32 占据4字节 范围 0 ~ 2（32次方）-1uint64 占据8字节 范围 0 ~ 2（64次方）-1byte uint8的别称 注意： - 上述类型的变量之间不允许互相赋值或操作，且int的长度是32 bit, 但int 与 int32并不可以互用。 - Go默认的整型类型是int - 查看数据所占据的字节数方法：unsafe.Sizeof() 浮点类型 浮点类型的分类： 12float32 单精度 占据4字节 范围 -3.403E38 ~ 3.403E38 (math.MaxFloat32)float64 双精度 占据8字节 范围 -1.798E208 ~ 1.798E308 (math.MaxFloat64) 由上看出： - 浮点数是有符号的，浮点数在机器中存放形式是：浮点数=符号位+指数位+尾数位 - 浮点型的范围是固定的，不受操作系统限制 - .512 这样数可以识别为 0.512 - 科学计数法：5.1234e2 = 5.12 * 10 的 2 次方 5.12E-2 = 5.12/10 的 2 次方 精度损失：float32可以提供大约6个十进制数的精度，float64大约可以提供15个十进制的精度（一般选择float64） 1234var num1 float32 = -123.0000901var num2 float64 = -123.0000901 fmt.Println(&quot;num1=&quot;,num1) //-123.00009fmt.Println(&quot;num2=&quot;,num2) //-123.0000901 使用 == 号判断浮点数，是不可行的，替代方案如下： 123func isEqual(f1,f2,p float64) bool { return math.Abs(f1-f2) &lt; p //p为用户自定义精度，如：0.00001} go中的NaN非数： 12var z float64fmt.Println(z, -z, 1/z, -1/z, z/z) // &quot;0 -0 +Inf -Inf NaN&quot; 注意：函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。 12nan := math.NaN()fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // &quot;false false false&quot; 复数 Go还支持复数。它的默认类型是complex128（64位实数+64位虚数）。如果需要小一些的，也有complex64(32位实数+32位虚数)。复数的形式为RE + IMi，其中RE是实数部分，IM是虚数部分，而最后的i是虚数单位。 如下所示： 12345var t complex128t = 2.1 + 3.14it1 = complex(2.1,3.14) //结果同上 fmt.Println(real(t)) //实部：2.1fmt.Println(imag(t)) //虚部：3.14","link":"/posts/51604.html"},{"title":"字符串","text":"字符型 Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存，且使用单引号包裹。 字符类型可以以d%打印为整型。 123456789var c1 byte = 'a'var c2 byte = '0'fmt.Println(&quot;c1=&quot;, c1) //输出 97fmt.Println(&quot;c2=&quot;, c2) //输出48 fmt.Printf(&quot;c1=%c,c2=%c\\n&quot;, c1, c2) //输出原值 a 0 //var c3 byte = '北'//fmt.Printf(&quot;c3=%c&quot;, c3) //溢出错误 说明： - 如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte - 如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存 - 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1) - 字符可以和整型进行运算 基本使用 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的。 字符串在Go语言中是基本类型，内容在初始化后不能修改。Go中的字符串都是采用UTF-8字符集编码，使用一对双引号（\"\"）或反引号定义。 使用``可以额外解析换行，即其没有字符转义功能。 123456str := &quot;Hello &quot; str2 := &quot; World!&quot; // str[0] = 'c' //编译报错： cannot assign to 因为字符串不可变 fmt.Println(str[0]) //输出字符串第一个字符 72 fmt.Println(len(str)) //输出长度 6 fmt.Println(str + str2) //输出不带空格的 字符串修改 Go中的字符串不可改变，有两种修改办法： 办法一：通过转换为[]byte类型，构造一个临时字符串 1234str := &quot;hello&quot;strTemp := []byte(str)strTemp[0] = 'c';strResult := string(strTemp) 办法二：字符串可以进行切片操作 12str := &quot;hello&quot;str = &quot;c&quot;+ str[1:] // 1: 表示从第1位开始到最后 Go和Java等语言一样，字符串默认是不可变的，这样保证了线程安全，大家使用的都是只读对象，无须加锁，且能很方便的共享内存，不必使用写时复制。 字符串遍历 遍历方式一：使用字节数组，注意每个中文在UTF-8中占据3个字节 1234str := &quot;hello&quot;for i := 0; i &lt; len(str); i++ { fmt.Println(i,str[i])} 遍历方式二：range关键字只是第一种遍历方式的简写 1234str := &quot;你好&quot;for i,ch := range str { fmt.Println(i,ch)} 注意：Unicode字符遍历需要使用range，原因见len()函数部分讲解。 字符串转换 字符串转化的函数在strconv中，如下也只是列出一些常用的： Append 系列函数将整数等转换为字符串后，添加到现有的字节数组中。 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() { str := make([]byte, 0, 100) str = strconv.AppendInt(str, 4567, 10) str = strconv.AppendBool(str, false) str = strconv.AppendQuote(str, &quot;abcdefg&quot;) str = strconv.AppendQuoteRune(str, '单') fmt.Println(string(str))} Format 系列函数把其他类型的转换为字符串 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() { a := strconv.FormatBool(false) b := strconv.FormatFloat(123.23, 'g', 12, 64) c := strconv.FormatInt(1234, 10) d := strconv.FormatUint(12345, 10) e := strconv.Itoa(1023) fmt.Println(a, b, c, d, e)} Parse 系列函数把字符串转换为其他类型 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func checkError(e error){ if e != nil{ fmt.Println(e) }}func main() { a, err := strconv.ParseBool(&quot;false&quot;) checkError(err) b, err := strconv.ParseFloat(&quot;123.23&quot;, 64) checkError(err) c, err := strconv.ParseInt(&quot;1234&quot;, 10, 64) checkError(err) d, err := strconv.ParseUint(&quot;12345&quot;, 10, 64) checkError(err) e, err := strconv.Atoi(&quot;1023&quot;) checkError(err) fmt.Println(a, b, c, d, e)} len()函数 len()函数是go语言的内建函数，可以用来获取切片、字符串、通道等的长度。 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() { str1 := &quot;hello world&quot; str2 := &quot;你好，&quot; fmt.Println(len(str1)) // 11 fmt.Println(len(str2)) // 9 fmt.Println(utf8.RuneCountInString(str2)) // 3} 第一个函数输出11很容易理解，第二个函数却输出了9，理论上我们会认为应该是3才对。这时因为Go的字符串都是以UTF-8格式保存，每个中文占据3个字节。Go中计算UTF-8字符串格式的长度应该使用utf8.RuneCountInString。 字符串索引 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello,world!&quot; index := strings.Index(str, &quot;w&quot;) fmt.Println(index) // 6 fmt.Println(str[index]) // 119 ASCII中的值 fmt.Println(str[index:]) // world!} strings.Index: 正向搜索字符串 strings.LastIndex: 反向搜索字符串 字符串连接 使用+能够连接字符串。但是该操作并不高效。Go中也拥有类似Java的StringBuilder机制来进行高效字符串连接： 123456789101112str1 := &quot;hellow&quot;str2 := &quot; world&quot;//创建字节缓冲var stringBuilder bytes.Buffer//把字符串写入缓冲stringBuilder.WriteString(str1)stringBuilder.WriteString(str2)//将缓冲以字符串形式输出fmt.Println(stringBuilder.String()) 注意：bytes.Buffer可以写入各种字节数组，字符串也是一种字节数组。 其他操作 123456789101112131415161718//查找s在字符串str中的索引Index(str, s string) int 示例：strings.Index(str, &quot;,&quot;)//判断str是否包含sContains(str, s string) bool//通过字符串str连接切片 sJoin(s []string, str string) string//替换字符串str中old字符串为new字符串，n表示替换的次数，小于0全部替换Replace(str,old,new string,n int) string//字符串str按照s分割，返回切片Splite(str,s string)[]string//Append系列函数将整数等转换为字符串后，添加到现有的字节数组中//Format系列函数可以把其他类型转换为字符串//Trim函数可以去除头部、尾部指定的字符串//Fields函数可以去除空格，返回切片","link":"/posts/47564.html"},{"title":"数据类型转换","text":"显式转换 Go在不同类型的变量之间赋值时需要显式转换。也就是说Golang中数据类型不能自动转换。 数值类型转换 123var i int32 = 100var n1 float64 = float64(i) fmt.Printf(&quot;n1=%v&quot;, n1) //输出100 注意：在转换中，比如将int64转成int8【-128---127】，编译时不会报错，只是转换的结果是按溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围。 基本数据类型与字符串转换 基本数据类型转字符串：fmt.Sprintf();该函数会返回转换后的字符串 12345var b bool = truevar str stringstr = fmt.Sprintf(&quot;%t&quot;, b) fmt.Printf(str) //true 字符串转基本数据类型：使用包strconv 1234var str string = &quot;true&quot;var b boolb, _ = strconv.ParseBool(str) fmt.Printf(&quot;%v&quot;, b) 注意：在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据，比如可以把\"123\",转成一个整数，但不能转换\"hello\"，如果这样做，Golang 直接将其转成0，其它类型也是一样的道理，如：float =&gt; 0 bool =&gt; false。 类型别名 类型别名的使用 Go在1.9版本加入了类型别名。主要用于代码升级、迁移中类型的兼容问题（C/C++中使用宏来解决重构升级带来的问题）。 Go1.9之前的版本内建类型： 12type byte uint8type rune int32 Go1.9之后的版本内建类型： 12type byte = uint8type rune = int32 类型定义是定义了一个全新的类型的类型。类型别名只是某个类型的小名，并非创造了新的类型。 12345678910// 自定义两个类型type MyInt inttype AliasInt = intvar a1 MyIntfmt.Printf(&quot;a1 type: %T\\n&quot;, a1) //main.MyIntvar a2 AliasIntfmt.Printf(&quot;a2 type: %T\\n&quot;, a2) //int 不同包下的类型别名 注意：不能为不在同一个包中的类型上定义方法。 123456789101112131415package mainimport ( &quot;time&quot;)type MyDuration = time.Durationfunc (m MyDuration) Test(str string) {}func main() {} 解决方案：使用别名定义（type MyDuration time.Duration），且将定义放在time包中","link":"/posts/42985.html"},{"title":"数组","text":"数组的声明 数组是一段固定长度的连续内存区域。数组的长度定义后不可更改，长度使用 len() 获取。 123456var arr1 [10]int //定义长度为10的整型数组，很少这样使用arr2 [5]int := [5]int{1,2,3,4,5} //定义并初始化arr3 := [5]int{1,2,3,4,5} //自动推导并初始化arr4 := [5]int{1,2} //指定总长度，前几位被初始化，没有的使用零值arr5 := [5]int{2:10, 4:11} //有选择的初始化，没被初始化的使用零值arr6 := [...]int{2,3,4} //自动计算长度 数组常用操作 1234arr[:] 代表所有元素arr[:5] 代表前五个元素，即区间的左闭右开arr[5:] 代表从第5个开始（不包含第5个）len(arr) 数组的长度 贴士：上述操作会引发类型的变化，数组将会转化为Go中新的数据类型slice，见09节 数组的遍历 方式一：for循环遍历 12345arr := [3]int{1,2,3}for i := 0; i &lt; len(arr); i++ { fmt.Println(arr[i])} 方式二：for-range遍历 123456arr := [3]int{1,2,3}for i, v := range arr { fmt.Println(i) //元素位置 fmt.Println(v) //元素值} 数组使用注意事项 数组创建完长度就固定，不可以再追加元素； 长度是数组类型的一部分，因此[3]int与[4]int是不同的类型； 数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该函数的副本，而不是他的指针。","link":"/posts/32766.html"},{"title":"无类型常量","text":"一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB/ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）： 1fmt.Println(YiB/ZiB) // &quot;1024&quot; 另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi 如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换： 12345const Pi64 float64 = math.Pivar x float32 = float32(Pi64)var y float64 = Pi64var z complex128 = complex128(Pi64) 对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和\\u0000虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。 前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果： 1234var f float64 = 212fmt.Println((f - 32) * 5 / 9) // &quot;100&quot;; (f - 32) * 5 is a float64fmt.Println(5 / 9 * (f - 32)) // &quot;0&quot;; 5/9 is an untyped integer, 0fmt.Println(5.0 / 9.0 * (f - 32)) // &quot;100&quot;; 5.0/9.0 is an untyped float 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。 1234var f float64 = 3 + 0i // untyped complex -&gt; float64f = 2 // untyped integer -&gt; float64f = 1e123 // untyped floating-point -&gt; float64f = 'a' // untyped rune -&gt; float64 上面的语句相当于: 1234var f float64 = float64(3 + 0i)f = float64(2)f = float64(1e123)f = float64('a') 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理： 123456789const ( deadbeef = 0xdeadbeef // untyped int with value 3735928559 a = uint32(deadbeef) // uint32 with value 3735928559 b = float32(deadbeef) // float32 with value 3735928576 (rounded up) c = float64(deadbeef) // float64 with value 3735928559 (exact) d = int32(deadbeef) // compile error: constant overflows int32 e = float64(1e309) // compile error: constant overflows float64 f = uint(-1) // compile error: constant underflows uint) 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子： 1234i := 0 // untyped integer; implicit int(0)r := '\\000' // untyped rune; implicit rune('\\000')f := 0.0 // untyped floating-point; implicit float64(0.0)c := 0i // untyped complex; implicit complex128(0i) 注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。 如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样： 12var i = int8(0)var i int8 = 0 当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。 1234fmt.Printf(&quot;%T\\n&quot;, 0) // &quot;int&quot;fmt.Printf(&quot;%T\\n&quot;, 0.0) // &quot;float64&quot;fmt.Printf(&quot;%T\\n&quot;, 0i) // &quot;complex128&quot;fmt.Printf(&quot;%T\\n&quot;, '\\000') // &quot;int32&quot; (rune)","link":"/posts/5895.html"},{"title":"结构体","text":"谈谈go设计思想 Go语言通过用自定义的方式形成新的类型。Go语言使用结构体和结构体成员来描述真实世界。 Go语言没有类的概念，也不支持类的继承等面向对象思想。Go语言的结构体内嵌配合接口比面向对象具有更高的扩展性和灵活性。 Go语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。 ### 结构体的作用 结构体可以用来声明新的类型，作为其他类型的属性/字段的容器，如下定义一个学生结构体： 1234567891011121314151617181920type Student struct { name string age int}//按顺序初始化：每个成员都必须初始化var s1 Student = Student{&quot;lisi&quot;, 20}//制定成员初始化：没有被初始化的，自动赋零值s2 := Student{age:30}//new 申请结构体s3 := new(Student) //被new生成的结构体实例其实是指针类型s3.name = &quot;zs&quot; //这里的.语法只是语法糖，将s3.name转换成了(*s3).names3.age = 27//直接声明var s4 Students4.name = &quot;ww&quot;s4.age = 30 struct的结构中的类型可以是任意类型，且存储空间是连续的，其字段按照声明时的顺序存放。 如果结构体的所有的成员都是可以比较的，那么结构体本身也是可以比较的，使用 == != ，不支持 &gt; 和 &lt;。 注意：如果结构体的成员要被包外调用，需要大写首字母。\b 取结构体地址与实例化 前面说过，对结构体的new其实是生成了一个指针类型。其实对结构体进行&amp;取地址操作时，也可以视为对该类型进行一次new的实例化操作。 1234ins := &amp;T{}# T是结构体类型# ins为结构体的实例，类型为*T，是指针类型 匿名字段 struct的字段名与类型一一对应，如果不提供名字，则为匿名字段。 如果匿名字段是一个struct时，这个struct拥有的全部字段都被隐式引入了当前的struct。 12345678910type Human struct { name string age int weight int}type Student struct { Human // 匿名字段，那么默认Student就包含了Human的所有字段 speciality string} 不仅仅是struct，其他所有内置类型和自定义类型都可以作为匿名字段： 12345678910111213141516171819202122232425262728293031type Human struct { name string age int weight int}type Student struct { Human // 匿名字段，struct Skills // 匿名字段，自定义的类型string slice int // 内置类型作为匿名字段 speciality string}func main() { // 初始化学生Jane jane := Student{Human:Human{&quot;Jane&quot;, 35, 100}, speciality:&quot;Biology&quot;} // 现在我们来访问相应的字段 fmt.Println(&quot;Her name is &quot;, jane.name) fmt.Println(&quot;Her age is &quot;, jane.age) fmt.Println(&quot;Her weight is &quot;, jane.weight) fmt.Println(&quot;Her speciality is &quot;, jane.speciality) // 我们来修改他的skill技能字段 jane.Skills = []string{&quot;anatomy&quot;} fmt.Println(&quot;Her skills are &quot;, jane.Skills) fmt.Println(&quot;She acquired two new ones &quot;) jane.Skills = append(jane.Skills, &quot;physics&quot;, &quot;golang&quot;) fmt.Println(&quot;Her skills now are &quot;, jane.Skills) // 修改匿名内置类型字段 jane.int = 3 fmt.Println(&quot;Her preferred number is&quot;, jane.int)} 这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？ Go里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过student.phone访问的时候，是访问student里面的字段，而不是human里面的字段。 内嵌结构体 当前结构体可以直接访问其内嵌结构体的内部字段： 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport &quot;fmt&quot;type Animal struct { Age int}type Person struct { Animal Name string}type Student struct { Person ClassName string}func main() { // 初始化方式1 s1 := Student{ Person{ Animal: Animal { Age: 15, }, Name:&quot;lisi&quot;, }, &quot;一班&quot;, } fmt.Println(s1.Age) // 正确输出15 fmt.Println(s1.Person.Name) // 正确输出lisi // 初始化方式2 var s2 Student s2.Name = &quot;zs&quot; s2.Age = 30 s2.ClassName = &quot;二班&quot; fmt.Println(s2.Age) // 正确输出30 fmt.Println(s2.Person.Name) // 正确输出zs}","link":"/posts/6880.html"},{"title":"切片初识","text":"切片介绍 在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫slice。 切片解决了数组长度不能扩展，以及基本类型数组传递时产生副本的问题。 ### 切片\b创建 常用创建方式： 1234var s1 []int // 和声明数组一样，只是没有长度，但是这样做没有意义，因为底层的数组指针为nils2 := []byte {'a','b','c'}fmt.Println(s1) //输出 []fmt.Print(s2) //输出 [97 98 99] 从数组创建：slice可以从一个数组再次声明。slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i: 12345678910// 声明一个含有10个元素元素类型为byte的数组var arr = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}// 声明两个含有byte的slicevar a, b []byte// a指向数组的第3个元素开始，并到第五个元素结束，现在a含有的元素: ar[2]、ar[3]和ar[4]a = arr[2:5] // b是数组arr的另一个slicre,b的元素是：ar[3]和ar[4]b = arr[3:5] 注意：声明数组时，方括号内写明了数组的长度或使用...自动计算长度，而声明slice时，方括号内没有任何字符。 从切片创建： 12oldSlice := []int{1,2,3}newSlice := oldSlice[:6] //基于切片前6个元素创建，没有的默认0 注意：如果选择的旧切片长度超出了旧切片的cap()值（切片存储长度），则不合法。 使用make函数创建： 123slice1 := make([]int,5) // 创建初始值为0，个数为5的切片slice2 := make([]int,5,10) //创建初始值为10，个数为5的切片slice3 := []int{1,2,3,4,5} //创建并初始化 切片常见操作 切片常见内置函数 切片常用内置函数： - len() 返回切片长度 - cap() 返回切片底层数组容量 - append() 对切片追加元素 - func copy(dst, src []Type) int：将src中数据拷贝到dst中，返回拷贝的元素个数 切片空间与元素个数： 1234slice1 := make([]int, 5, 10)fmt.Println(len(slice1)) // 5fmt.Println(cap(slice1)) // 10fmt.Println(slice1) // [0 0 0 0 0] 切片操作 123456789101112131415161718192021222324252627282930//切片增加slice1 = append(slice1,1,2)fmt.Println(slice1) //输出[0 0 0 0 0 1 2]//切片增加一个新切片sliceTemp := make([]int,3)slice1 = append(slice1,sliceTemp...)fmt.Println(slice1) //输出[0 0 0 0 0 1 2 0 0 0]//切片拷贝s1 := []int{1,3,6,9}s2 := make([]int, 10) //必须给与充足的空间num := copy(s2, s1)fmt.Println(s1) //[1 3 6 9]fmt.Println(s2) //[1 3 6 9 0 0 0 0 0 0]fmt.Println(num) //4//切片中删除元素s1 := []int{1,3,6,9}index := 2 //删除该位置元素s1 = append(s1[:index], s1[index+1:]...)fmt.Println(s1) //[1 3 9]// 切片拷贝s1 := []int{1,2,3,4,5}s2 := []int{6,7,8}copy(s1,s2) //复制s2前三个元素到slice1前3位置copy(s2,s1) //复制s1前三个元素到slice2 注意：没有...会编译错误，默认第二个参数后是元素值，传入切片需要展开。如果追加的长度超过当前已分配的存储空间，切片会自动分配更大的内存。 切片的一些简便操作 slice的默认开始位置是0，ar[:n]等价于ar[0:n] slice的第二个序列默认是数组的长度，ar[n:]等价于ar[n:len(ar)] 如果从一个数组里面直接获取slice，可以这样ar[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)] 切片的遍历可以使用for循环，也可以使用range函数 123456789101112131415161718192021222324252627282930313233// 声明一个数组var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}// 声明两个slicevar aSlice, bSlice []byte// 演示一些简便操作aSlice = array[:3] // 等价于aSlice = array[0:3] aSlice包含元素: a,b,caSlice = array[5:] // 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,jaSlice = array[:] // 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素// 从slice中获取sliceaSlice = array[3:7] // aSlice包含元素: d,e,f,g，len=4，cap=7bSlice = aSlice[1:3] // bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,fbSlice = aSlice[:3] // bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,fbSlice = aSlice[0:5] // 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,hbSlice = aSlice[:] // bSlice包含所有aSlice的元素: d,e,f,g``` ### 切片的截取- `s[n]`：切片s中索引为位置为n的项- `s[:]`：从切片s的索引位置0到`len(s)-1`所获得的切片- `s[low:]`：从切片s的索引位置low到`len(s)-1`所获得的切片- `s[:high]`：从切片s的索引位置0到high所获得的切片- `s[low:high]`：从切片s的索引位置low到high所获得的切片- `s[low:high:max]`：从low到high的切片，且容量`cap=max-low`### 字符串转切片 ```go str := &quot;hello,世界&quot; a := []byte(str) //字符串转换为[]byte类型切片 b := []rune(str) //字符串转换为[]rune类型切片 切片存储结构 与数组相比，切片多了一个存储能力值的概念，即元素个数与分配空间可以是两个不同的值，其结构如下所示： 12345type slice struct { arrary = unsafe.Pointer //指向底层数组的指针 len int //切片元素数量 cap int //底层数组的容量} 所以切片通过内部的指针和相关属性引用数组片段，实现了变长方案，Slice并不是真正意义上的动态数组。 合理设置存储能力，可以大幅提升性能，比如知道最多元素个数为50，那么提前设置为50，而不是先设为30，可以明显减少重新分配内存的操作。","link":"/posts/29902.html"},{"title":"集合map","text":"算法贴士 需要使用任意类型的关联，就需要用到集合，比如学号和名字。Go语言提供了映射关系容器是map，内部使用散列表（hash）实现。 大多数语言中映射关系容器使用两种算法：散列表和平衡树。 散列表可以简单的描述为一个数组，数组的每个元素都是列表，根据散列函数获得每个元素的特征值，将特征值作为映射的键。如果特征值重复，表示元素发生了碰撞，需要尽量避免碰撞，这样就需要多容器扩容，每次扩容，元素都需要重新放入，较为耗时。 平衡树类似于有父子关系的一棵数据数，每个元素在放入树时，都要与一些节点进行比较。 map的创建 Go内置了map类型，map是一个无序键值对集合（也有一些书籍翻译为字典）。 普通创建： 123//声明一个map类型，[]内的类型指任意可以进行比较的类型 int指值类型m := map[string]int{&quot;a&quot;:1,&quot;b&quot;:2}fmt.Print(m[&quot;a&quot;]) make方式创建map： 123456789101112131415type Person struct{ ID string Name string}func main() { var m map[string] Person m = make(map[string] Person) m[&quot;123&quot;] = Person{&quot;123&quot;,&quot;Tom&quot;} p,isFind := m[&quot;123&quot;] fmt.Println(isFind) //true fmt.Println(p) //{123 Tom}} 注意：key 可以是什么类型？ golang 中的 map，的 key 可以是很多种类型，比如 bool, 数字，string, 指针, channel , 还可以是只 包含前面几个类型的 接口, 结构体, 数组。 通常 key 为 int 、string。 注意: slice， map 还有 function 不可以，因为他们不能使用 == 来判断 map的使用 map的读取和设置也类似slice一样，通过key来操作，只是slice的index只能是｀int｀类型，而map多了很多类型，可以是int，可以是string及所有完全定义了==与!=操作的类型。 12345678910// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化var numbers map[string]int// 另一种map的声明方式numbers = make(map[string]int)numbers[&quot;one&quot;] = 1 //赋值numbers[&quot;ten&quot;] = 10 //赋值numbers[&quot;three&quot;] = 3fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据// 打印出来如:第三个数字是: 3 map的遍历：同数组一样，使用for-range 的结构遍历 注意： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取； map的长度是不固定的，也就是和slice一样，也是一种引用类型 内置的len函数同样适用于map，返回map拥有的key的数量 map的值可以很方便的修改，通过numbers[\"one\"]=11可以很容易的把key为one的字典值改为11 map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制 删除元素 1234567891011// 初始化一个字典rating := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为truecsharpRating, ok := rating[&quot;C#&quot;]if ok { fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)} else { fmt.Println(&quot;We have no rating associated with C# in the map&quot;)}delete(rating, &quot;C&quot;) // 删除key为C的元素 注意：go没有提供清空元素的方法，可以重新make一个新的map，不用担心垃圾回收的效率，因为go中并行垃圾回收效率比写一个清空函数高效很多。 sync.Mpa Go内置的map只读是线程安全的，读写是线程不安全的，并发安全的map可以使用标准包sync中的map。 演示并发读写map的问题： 123456789101112131415161718192021package mainfunc main() { m := make(map[int]int) go func() { for { //无限写入 m[1] = 1 } }() go func() { for { //无限读取 _ = m[1] } }() for {} //无限循环，让并发程序在后台执行} 错误提示：fatal error: concurrent map read and map write，即出现了并发读写，因为用两个并发程序不断的对map进行读和写，产生了竞态问题。map内部会对这种错误进行检查并提前发现。 需要并发读写时，一般都是加锁，但是这样做性能不高，在go1.9版本中提供了更高效并发安全的sync.Map。 sync.Map的特点： - 无须初始化，直接声明即可 - sync.Map不能使用map的方式进行取值和设值操作，而是使用sync.Map的方法进行调用。Store表示存储，Load表示获取，Delete表示删除。 - 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，需要继续迭代时，返回true，终止迭代返回false。 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;sync&quot;)func main() { var scene sync.Map //保存键值对 scene.Store(&quot;id&quot;,1) scene.Store(&quot;name&quot;,&quot;lisi&quot;) //根据键取值 fmt.Println(scene.Load(&quot;name&quot;)) //遍历 scene.Range(func(k, v interface{}) bool{ fmt.Println(k,v) return true })} 注意：map没有提供获取map数量的方法，可以在遍历时手动计算。sync.Map为了并发安全。损失了一定的性能。","link":"/posts/41544.html"},{"title":"指针","text":"指针的创建 Go保留了指针，代表某个内存地址，默认值为nil，使用&amp;取变量地址，通过*访问目标对象。 简单示例： 12345v := &quot;3&quot;ptr := &amp;vvalue := *ptrfmt.Printf(&quot;指针地址为：%p\\n&quot;, ptr) // 输出0x.....16进制数fmt.Printf(&quot;指针地址内存储的值为：%s\\n&quot;, value) // 输出3 贴士：变量、指针和地址二者的关系是: 每个变量都拥有地址，指针的值就是地址。 指针类型的声明方式一 1234var a int = 10var p *int = &amp;a //声明指针类型fmt.Println(p) //输出 0xc.....16进制数fmt.Println(*p) // 10 指针类型的声明方式二 1234var p *intp = new(int) //申请一个int类型的地址空间*p = 666 //存储地址内内容为666fmt.Println(p) 注意： - Go同样支持多级指针，如 **T - 空指针：声明但未初始化的指针 - 野指针：引用了无效的地址 - Go不支持-&gt;运算符指针运算，可以直接使用 . 访问目标成员 指针还可以使用new创建： 123str := new(string) //申请一个string类型的指针内存*str = &quot;hello&quot;fmt.Println(*str) 指针实现变量值交换 123func swap (p1,p2 *int) { *p1,*p2 = *p2,*p1} 结构体指针 结构体指针访问结构体字段仍然使用 . 语法，Go中没有 -&gt; 操作符，案例如下： 1234567891011121314type User struct{ name string age int}func main() { var u = User{ name:&quot;lisi&quot;, age: 18, } p := &amp;u fmt.Println(u.name) //输出李四 fmt.Println(p.name) //输出李四} Go不支持指针运算 由于垃圾回收机制的存在，指针运算造成许多困扰，所以Go直接禁止了指针运算 123a := 1p := &amp;ap++ //报错：non-numeric type *int 变量生命周期与栈逃逸机制 函数中允许返回局部变量的地址，Go编译器使用栈逃逸机制将这种局部变量分配在堆上: 12345var p = f()func f() *int { v := 1 return &amp;v // 返回函数中的局部变量地址是安全的，因为p仍然在引用他} 变量的生命周期指在程序运行期间变量有效存在的时间段： - 包级别声明的变量，其生命周期和整个程序的运行周期是一致的 - 局部变量的生命周期是动态的，每次从创建新变量的声明语句开始到不再引用为止，变量的存储空间可能被回收 函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。 Go的GC判断变量是否回收的实现思路：从每个包级的变量、每个当前运行的函数的局部变量开始，通过指针和引用的访问路径遍历，是否可以找到该变量，如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响后续计算结果。 示例： 12345678910var global *intfunc f() { var x int x = 1 global = &amp;x}func g() { y := new(int) *y = 1} 上述的函数调用结果说明： - 虽然x变量定义在f函数内部，但是其必定在堆上分配，因为函数退出后仍然能通过包一级变量global找到，这样的变量，我们称之为从函数f中逃逸了 - g函数返回时，变量*y不可达，因此没有从函数g中逃逸，其内存分配在栈上，会马上被被回收。（当然也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间）","link":"/posts/40851.html"},{"title":"函数","text":"函数声明 函数声明格式 1234func 函数名字 (参数列表) (返回值列表）{ // 函数体 return 返回值列表} 注意： - 函数名首字母小写为私有，大写为公有； - 参数列表可以有0-多个，多参数使用逗号分隔，不支持默认参数； - 返回值列表返回值类型可以不用写变量名 - 如果只有一个返回值且不声明类型，可以省略返回值列表与括号 - 如果有返回值，函数内必须有return Go中函数常见写法： 12345678910111213141516171819202122232425//无返回值，默认返回0，所以也可以写为 func fn() int {}func fn(){} //Go推荐给函数返回值起一个变量名func fn1()(result int){ return 1}//第二种返回值写法func fn2()(result int){ result = 1 return }//多返回值情func fn3 () (int, int, int) { return 1,2,3}//Go返回值推荐多返回值写法：func fn4 () (a int, b int, c int) { 多个参数类型如果相同，可以简写为： a,b int a , b, c = 1, 2, 3 return } 变量作用域 局部变量：函数内部声明，作用域仅限于函数内部 全局变量：函数外部声明，作用域为整个包，如果首字母大写，则整个程序都可使用。 注意：Go中，大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。 不定参数 不定参数必须是最后一个参数，只是一个语法糖，在内部机制上，不定参数是一个切片，即：[]type，这是因为参数args可以用for循环来获取每个传入的参数。 12345//返回int类型的不定参数func fn1(args ...int){ fmt.Println(len(args))}//注意：所有不定参数的类型必须相同，且必须是最后一个参数，不定参数在函数内其实就相当于切片，对切片的操作同样适合\b不定参数。 匿名函数 1234567891011121314151617181920212223242526272829func main() { a := 3; f1 := func() { // f1 即为匿名函数 fmt.Println(a) //匿名函数访问外部变量 } f1() func() { //匿名函数自调 fmt.Println(a); }()}//匿名函数实战：取最大值,最小值x, y := func(i,j int) (max,min int) { if i &gt; j { max = i min = j } else { max = j min = i } return}(10,20)fmt.Println(x + ' ' + y) Go函数特性总结 支持有名称的返回值； 不支持默认值参数； 不支持重载； 不支持命名函数嵌套，匿名函数可以嵌套； Go函数从实参到形参的传递永远是值拷贝，有时函数调用后实参指向的值发生了变化，是因为参数传递的是指针的拷贝，实参是一个指针变量，传递给形参的是这个指针变量的副本，实质上仍然是值拷贝； Go函数支持不定参数； 函数类型 函数类型：函数去掉函数名、参数名和{}\b后的结果，使用%T打印该结果。 两个函数类型相同的前提是：拥有相同的形参列表和返回值列表，且列表元素的次序、类型都相同，形参名可以不同。 定义了函数类型，就可以使用该类型进行传参。 123456789101112131415func mathSum(a, b int) int { return a + b}func mathSub(a, b int) int { return a - b}//定义一个函数类型type MyMath func(int, int) int//定义的函数类型作为参数使用func Test(f MyMath, a , b int) int{ return f(a,b)} 通常我们可以把函数类型当做一种引用类型，实际函数类型变量和函数名都可以当做指针变量，只想函数代码开始的位置，没有初始化的函数默认值是nil。 匿名函数 匿名函数可以看做函数字面量，所有直接使用函数类型变量的地方都可以由匿名函数代替。匿名函数可以直接赋值给函数变量，可以当做实参，也可以作为返回值使用，还可以直接被调用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport &quot;fmt&quot;//匿名函数1var sumFunc = func(a, b int) int { return a + b}//匿名函数2var subFunc = func(a, b int) int { return a - b}func Test (f func(int, int) int, a , b int) int { return f(a, b)}func wrap (op string) func(int, int) int { switch op { case &quot;sum&quot;: return func(a, b int) int { return a + b } case &quot;sub&quot;: return func(a, b int) int { return a + b } default: return nil }}func main() { //方式一：匿名函数被直接调用 defer func(){ if err := recover(); err != nil{ fmt.Println(err) } }() //方式二：使用匿名函数变量名调用 sumFunc(1, 2) //方式三：匿名函数作为实参 Test(func(x, y int) int { return x + y },1 ,2) //方式四： myFunc := wrap(&quot;sum&quot;) result := myFunc(2,3) fmt.Println(result)} init函数 Go语言中，除了可以在全局声明中初始化实体，也可以在init函数中初始化。init函数是一个特殊的函数，它会在包完成初始化后自动执行，执行优先级高于main函数，并且不能手动调用init函数，每一个文件有且仅有一个init函数，初始化过程会根据包的以来关系顺序单线程执行。 1234567891011package mainimport ( &quot;fmt&quot;)func init() { //在这里可以书写一些初始化操作 fmt.Println(&quot;init...&quot;)}func main() { fmt.Println(&quot;main...&quot;)} new函数 new函数可以用来创建变量。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T： 1234p := new(int) // p 为 *int类型，只想匿名的int变量fmt.Println(*p) // &quot;0&quot;*p = 2 // 设置 int匿名变量值为2fmt.Println(*p) 贴士：new函数其实是语法糖，不是新概念，如下所示的两个函数其实拥有相同的行为。 12345678func newInt1() *int { return new(int)}func newInt2() *int { var dummy int return &amp;dummy} 注意：new只是一个预定义函数，并不是一个关键字，所以new也有可能会被项目定义为别的类型。 闭包 闭包概念 闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使己经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。 简单的说 : 函数+引用环境=闭包 贴士：闭包( Closure)在某些编程语言中也被称为 Lambda表达式（如Java） 在闭包中可以修改引用的变量： 123456str := &quot;hello&quot;foo := func(){ // 声明一个匿名函数 str = &quot;world&quot;}foo() // 调用匿名函数，修改str值fmt.Print(str) // world 闭包案例一 简单示例 12345678910111213141516171819func fn1(a int) func(i int) int { return func(i int) int { print(&amp;a, a) return a }}func main() { f := fn1(1) //输出地址 g := fn1(2) //输出地址 fmt.Println(f(1)) //输出1 fmt.Println(f(1)) //输出1 fmt.Println(g(2)) //输出2 fmt.Println(g(2)) //输出2} 闭包案例二 实现累加器 12345678910111213func Accumulate(value int) func() int { return func() int { // 返回一个闭包 value++ return value }}func main() { accAdd := Accumulate(1) fmt.Println(accAdd()) // 2 fmt.Println(accAdd()) // 3} 函数参数传递 值传递和引用传递 不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的 拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的 数据大小，数据越大，效率越低。 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&amp;，函数内以指针的方式操作变量。 可变参数 可变参数变量是一个包含所有参数的切片。如果要在多个可变参数中传递参数 ，可以在传递时在可变参数变量中默认添 加“ ...”，将切片中的元素进行传递，而不是传递可变参数变量本身。 示例：对可变参数列表进行遍历 1234567891011func joinStrings(slist ...string) string { var buf bytes.Buffer for _, s := range slist { buf.WriteString(s) } return buf.String()}func main() { fmt.Println(joinStrings(&quot;pig&quot;, &quot; and&quot;, &quot; bird&quot;))} 示例：参数传递 12345678910111213141516// 实际打印函数func rawPrint(rawList ...interface{}) { for _, a := range rawList { fmt.Println(a) }}// 封装打印函数func print(slist ...interface{}) { // 将slist可变参数切片完整传递给下一个函数 rawPrint(slist...)}func main() { print(1,2,3)} 常用函数 常用字符串函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//字符串的字节长度：汉字占用3个字节，字符占据1个字节len(&quot;hello&quot;)//字符串遍历：可以同时处理中文问题r := []rune(&quot;hello北京&quot;)fmt.Println(r[2]) // 查看第3个//字符串转整数n, err := strconv.Atoi(&quot;hello&quot;)//整数转字符串str = strconv.Itoa(12345)//字符串转[]bytevar bytes = []byte(&quot;hello&quot;)// []byte 转 字符串 str = string([]byte{97, 98, 99})//10进制转2 8 16进制str = strconv.FormatInt(123, 2) // 2-&gt; 8 , 16//查找子字符串是否在指定的字符串中 strings.Contains(&quot;seafood&quot;, &quot;foo&quot;) //true//统计一个字符串有几个指定的子串strings.Count(&quot;ceheese&quot;, &quot;e&quot;) //4//不区分大小写的字符串比较(==是区分字母大小写的)fmt.Println(strings.EqualFold(&quot;abc&quot;, &quot;Abc&quot;)) // true//返回子串在字符串第一次出现的 index 值，如果没有返回-1strings.Index(&quot;NLT_abc&quot;, &quot;abc&quot;) // 4// 返回子串在字符串最后一次出现的 index，如没有返回-1strings.LastIndex(&quot;go golang&quot;, &quot;go&quot;)// 将指定的子串替换成 另外一个子串strings.Replace(&quot;go go hello&quot;, &quot;go&quot;, &quot;go 语言&quot;, n) //n 可以指 定你希望替换几个，如果 n=-1 表示全部替换// 按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组strings.Split(&quot;hello,wrold,ok&quot;, &quot;,&quot;)// 将字符串的字母进行大小写的转换strings.ToLower(&quot;Go&quot;) // go strings.ToUpper(&quot;Go&quot;) // GO// 将字符串左右两边的空格去掉strings.TrimSpace(&quot; tn a lone gopher ntrn &quot;)// 将字符串左右两边指定的字符去掉 同样有 TrimLeft和 TrimRightstrings.Trim(&quot;! hello! &quot;, &quot; !&quot;)// 判断字符串是否以指定的字符串开头strings.HasPrefix(&quot;ftp://192.168.10.1&quot;, &quot;ftp&quot;) // true// 判断字符串是否以指定的字符串结束strings.HasSuffix(&quot;NLT_abc.jpg&quot;, &quot;abc&quot;) //false 时间函数 123456789now := time.Now()fmt.Printf(now.Format(&quot;2018-10-10 15:04:05&quot;))fmt.Printf(now.Format(&quot;2018-10-10&quot;))fmt.Printf(now.Format(&quot;15:04:05&quot;))//时间戳now.Unix() //10位 从1970年J 1 到现在的秒数now.Unixnano() //20位 同上，单位是纳秒","link":"/posts/21513.html"},{"title":"defer延迟执行","text":"defer延迟执行修饰符 在函数中，程序员经常需要创建资源(比如:数据库连接、文件句柄、锁等) ，为了在函数执行完 毕后，及时的释放资源，Go设计者提供了defer(延时机制): 123456func main() { //当执行到defer语句时，暂不执行，会将defer后的语句压入到独立的栈中,当函数执行完毕后，再从该栈按照先入后出的方式出栈执行 defer fmt.Println(&quot;defer1...&quot;) defer fmt.Println(&quot;defer2...&quot;) fmt.Println(&quot;main...&quot;)} 上述代码执行结果： 123main...defer2...defer1... defer将语句放入到栈时，也会将相关的值拷贝同时入栈: 123456func main() { num := 0 defer fmt.Println(&quot;defer中：num=&quot;, num) num = 3 fmt.Println(&quot;main中：num=&quot;,num)} 输出结果： 12main中：num= 3defer中：num= 0 defer最佳实践 defer最佳实践：用于关闭资源，比如：defer connect.close()。 案例一：defer处理资源 没有使用defer时打开文件处理代码： 123456789101112131415f,err := os.Open(file)if err != nil { return 0}info,err := f.Stat()if err != nil { f.Close() return 0}f.Close()return 0; 使用defer优化： 123456789101112131415161718f,err := os.Open(file)if err != nil { return 0}defer f.Close()info,err := f.Stat()if err != nil { // f.Close() //这句已经不需要了 return 0}//后续一系列文件操作后执行关闭// f.Close() //这句已经不需要了return 0; 案例二：并发使用map的函数。 无defer代码： 12345678910var ( mutex sync.Mutex testMap = make(map[string]int))func getMapValue(key string) int { mutex.Lock() //对共享资源加锁 value := testMap[key] mutex.Unlock() return value} 上述案例是很常见的对并发map执行加锁执行的安全操作，使用defer可以对上述语义进行简化： 123456789var ( mutex sync.Mutex testMap = make(map[string]int))func getMapValue(key string) int { mutex.Lock() //对共享资源加锁 defer mutex.Unlock() return testMap[key]} defer无法处理全局资源 使用defer语句, 可以方便地组合函数/闭包和资源对象，即使panic时，defer也能保证资源的正确释放。但是上述案例都是在局部使用和释放资源，如果资源的生命周期很长， 而且可能被多个模块共享和随意传递的话，defer语句就不好处理了，需要下面的方式。 Go的runtime包的func SetFinalize(x, f interface{})函数可以提供类似C++析构函数的机制，比如我们可以包装一个文件对象，在没有人使用的时候能够自动关闭： 123456789101112type MyFile struct { f *os.File}func NewFile(name string) (&amp;MyFile, error){ f, err := os.Open(name) if err != nil { return nil, err } runtime.SetFinalizer(f, f.f.Close) return &amp;MyFile{f: f}, nil} 在使用runtime.SetFinalizer时, 需要注意的地方是尽量要用指针访问内部资源，这样的话, 即使*MyFile`对象忘记释放, 或者是被别的对象无意中覆盖, 也可以保证内部的文件资源可以正确释放。 二 错误Error 2.1 Go自带的错误接口 error是go语言声明的接口类型： 123type error interface { Error() string} 所有符合Error()string格式的方法，都能实现错误接口，Error()方法返回错误的具体描述。 自定义错误 返回错误前，需要定义会产生哪些可能的错误，在Go中，使用errors包进行错误的定义，格式如下： 1var err = errors.New(&quot;发生了错误&quot;) 提示：错误字符串相对固定，一般在包作用于声明，应尽量减少在使用时直接使用errors.New返回。 下面这个例子演示了如何使用errors.New: 123456func Sqrt(f float64) (float64, error) { if f &lt; 0 { return 0, errors.New(&quot;math: square root of negative number&quot;) } // implementation} 在C语言里面是通过返回-1或者NULL之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而Go定义了一个叫做error的类型，来显式表达错误。在使用时，通过把返回的error变量与nil的比较，来判定操作是否成功。例如os.Open函数在打开文件失败时将返回一个不为nil的error变量 1func Open(name string) (file *File, err error) 下面这个例子通过调用os.Open打开一个文件，如果出现错误，那么就会调用log.Fatal来输出错误信息： 12345f, err := os.Open(&quot;filename.ext&quot;)if err != nil { log.Fatal(err)} 类似于os.Open函数，标准包中所有可能出错的API都会返回一个error变量，以方便错误处理，这个小节将详细地介绍error类型的设计，和讨论开发Web应用中如何更好地处理error。 自定义错误案例 案例一：简单的错误字符串提示 1234567891011121314151617181920212223package mainimport ( &quot;errors&quot; &quot;fmt&quot;)//定义除数为0的错误var errByZero = errors.New(&quot;除数为0&quot;)func div(num1, num2 int) (int, error) { if num2 == 0 { return 0, errByZero } return num1 / num2, nil}func main() { fmt.Println(div(1, 0))} 案例二：实现错误接口 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot;)//声明一种解析错误type ParseError struct { Filename string Line int}//实现error接口，返回错误描述func (e *ParseError) Error() string { return fmt.Sprintf(&quot;%s:%d&quot;, e.Filename, e.Line)}//创建一些解析错误func newParseError(filename string, line int) error { return &amp;ParseError{filename, line}}func main() { var e error e = newParseError(&quot;main.go&quot;, 1) fmt.Println(e.Error()) switch detail := e.(type) { case *ParseError: fmt.Printf(&quot;Filename: %s Line:%d \\n&quot;, detail.Filename, detail.Line) default: fmt.Println(&quot;other error&quot;) }} errors包分析 Go中的erros包对New的定义非常简单: 123456789101112131415//创建错误对象func New(text string) error { return &amp;errorString{text}}//错误字符串type errorString struct { s string}//返回发生何种错误func (e *errorString) Error() string { return e.s} 错误对象都要事先error接口的Error()方法，这样，所有的错误都可以获得字符串的描述。 panic 宕机 手动触发宕机 Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时发现错误。 Go语言程序在宕机时，会将堆栈和goroutine信息输出到控制台，所以宕机有额可以方便知晓发生错误的位置。如果在编译时加入的调试信息甚至连崩溃现场的变量值、运行状态都可以获取，那么如何触发宕机？ 1234567package mainfunc main() { panic(&quot;crash&quot;)} 运行结果是： 123456panic: crashgoroutine 1 [running]:main.main() /Users/username/Desktop/TestGo/src/main.go:5 +0x39exit status 2 使用panic函数可以制造崩溃，panic声明如下； 1func panic(v interface{}) panic()参数可以是任意类型。 注意：手动触发宕机并不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，但是如果任何错误都使用宕机处理，也不是一个良好的设计。 defer与panic 当panic()发生宕机，panic()后面的代码将不会被执行，但是在panic前面已经运行过的defer语句依然会在宕机时发生作用： 12345678910package mainimport &quot;fmt&quot;func main() { defer fmt.Println(&quot;before&quot;) panic(&quot;crash&quot;)} recover 宕机恢复 让程序在崩溃时继续执行 无论是代码运行错误由Runtime层抛出的panic崩溃，还是主动触发的panic崩溃，都可以配合defer和recover实现错误捕捉和处理，让代码在发生崩溃后允许继续执行。 在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过try/catch机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续执行。Go没有异常系统，使用panic触发宕机类似于其他语言的抛出异常，recover的宕机恢复机制就对应try/catch机制。 使用defer与recover处理错误 123456789101112131415func test(num1 int, num2 int){ defer func(){ err := recover() //recover内置函数，可以捕获异常 if err != nil { fmt.Println(&quot;err=&quot;, err); } }() fmt.Println(num1/num2)}func main() { test(2,0)} panic recover综合示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;runtime&quot;)//崩溃时需要传递的上下文信息type panicContext struct { function string}//保护方式允许一个函数func ProtectRun(entry func()) { defer func() { err := recover() //发生宕机时，获取panic传递的上下文并打印 switch err.(type) { case runtime.Error: fmt.Println(&quot;runtime error:&quot;, err) default: fmt.Println(&quot;error:&quot;, err) } }() entry()}func main() { fmt.Println(&quot;运行前&quot;) ProtectRun(func(){ fmt.Println(&quot;手动宕机前&quot;) panic(&amp;panicContext{&quot;手动触发panic&quot;,}) fmt.Println(&quot;手动宕机后&quot;) }) ProtectRun(func(){ fmt.Println(&quot;赋值宕机前&quot;) var a *int *a = 1 fmt.Println(&quot;赋值宕机后&quot;) }) fmt.Println(&quot;运行后&quot;)} 运行结果： 123456运行前手动宕机前error: &amp;{手动触发panic}赋值宕机前runtime error: runtime error: invalid memory address or nil pointer dereference运行后 panic和recover关系 panic和defer的组合： - 有panic没有recover，程序宕机 - 有panic也有recover，程序不会宕机，执行完对应的defer后，从宕机点退出当前函数后继续执行","link":"/posts/4154.html"},{"title":"条件随机场","text":"1．概率无向图模型是由无向图表示的联合概率分布。无向图上的结点之间的连接关系表示了联合分布的随机变量集合之间的条件独立性，即马尔可夫性。因此，概率无向图模型也称为马尔可夫随机场。 概率无向图模型或马尔可夫随机场的联合概率分布可以分解为无向图最大团上的正值函数的乘积的形式。 2．条件随机场是给定输入随机变量\\(X\\)条件下，输出随机变量\\(Y\\)的条件概率分布模型， 其形式为参数化的对数线性模型。条件随机场的最大特点是假设输出变量之间的联合概率分布构成概率无向图模型，即马尔可夫随机场。条件随机场是判别模型。 3．线性链条件随机场是定义在观测序列与标记序列上的条件随机场。线性链条件随机场一般表示为给定观测序列条件下的标记序列的条件概率分布，由参数化的对数线性模型表示。模型包含特征及相应的权值，特征是定义在线性链的边与结点上的。线性链条件随机场的数学表达式是 \\[ P(y | x)=\\frac{1}{Z(x)} \\exp \\left(\\sum_{i, k} \\lambda_{k} t_{k}\\left(y_{i-1}, y_{i}, x, i\\right)+\\sum_{i, l} \\mu_{l} s_{l}\\left(y_{i}, x, i\\right)\\right) \\] 其中， \\[ Z(x)=\\sum_{y} \\exp \\left(\\sum_{i, k} \\lambda_{k} t_{k}\\left(y_{i-1}, y_{i}, x, i\\right)+\\sum_{i, l} \\mu_{l} s_{l}\\left(y_{i}, x, i\\right)\\right) \\] 4．线性链条件随机场的概率计算通常利用前向-后向算法。 5．条件随机场的学习方法通常是极大似然估计方法或正则化的极大似然估计，即在给定训练数据下，通过极大化训练数据的对数似然函数以估计模型参数。具体的算法有改进的迭代尺度算法、梯度下降法、拟牛顿法等。 6．线性链条件随机场的一个重要应用是标注。维特比算法是给定观测序列求条件概率最大的标记序列的方法。 例11.1 1from numpy import * 123456789101112131415#这里定义T为转移矩阵列代表前一个y(ij)代表由状态i转到状态j的概率,Tx矩阵x对应于时间序列#这里将书上的转移特征转换为如下以时间轴为区别的三个多维列表，维度为输出的维度T1 = [[0.6, 1], [1, 0]]T2 = [[0, 1], [1, 0.2]]#将书上的状态特征同样转换成列表,第一个是为y1的未规划概率，第二个为y2的未规划概率S0 = [1, 0.5]S1 = [0.8, 0.5]S2 = [0.8, 0.5]Y = [1, 2, 2] #即书上例一需要计算的非规划条件概率的标记序列Y = array(Y) - 1 #这里为了将数与索引相对应即从零开始P = exp(S0[Y[0]])for i in range(1, len(Y)): P *= exp((eval('S%d' % i)[Y[i]]) + eval('T%d' % i)[Y[i - 1]][Y[i]])print(P)print(exp(3.2)) 24.532530197109345 24.532530197109352 例11.2 1234567891011121314#这里根据例11.2的启发整合为一个矩阵F0 = S0F1 = T1 + array(S1 * len(T1)).reshape(shape(T1))F2 = T2 + array(S2 * len(T2)).reshape(shape(T2))Y = [1, 2, 2] #即书上例一需要计算的非规划条件概率的标记序列Y = array(Y) - 1P = exp(F0[Y[0]])Sum = Pfor i in range(1, len(Y)): PIter = exp((eval('F%d' % i)[Y[i - 1]][Y[i]])) P *= PIter Sum += PIterprint('非规范化概率', P) 非规范化概率 24.532530197109345 第11章条件随机场-习题 习题11.1 写出图11.3中无向图描述的概率图模型的因子分解式。 解答： 图11.3表示由4个结点组成的无向图。图中由2个结点组成的团有5个：\\(\\{Y_1,Y_2\\},\\{Y_2,Y_3\\},\\{Y_3,Y_4\\},\\{Y_4,Y_2\\}\\)和\\(\\{Y_1,Y_3\\}\\)，有2个最大团：\\(\\{Y_1,Y_2,Y_3\\}\\)和\\(\\{Y_2,Y_3,Y_4\\}\\)，而\\(\\{Y_1,Y_2,Y_3,Y_4\\}\\)不是一个团，因为\\(Y_1\\)和\\(Y_4\\)没有边连接。 根据概率图模型的因子分解定义：将概率无向图模型的联合概率分布表示为其最大团上的随机变量的函数的乘积形式的操作。公式在书中(11.5)，(11.6)。 \\[P(Y)=\\frac{\\Psi_{(1,2,3)}(Y_{(1,2,3)})\\cdot\\Psi_{(2,3,4)}(Y_{(2,3,4)})}{\\displaystyle \\sum_Y \\left[ \\Psi_{(1,2,3)}(Y_{(1,2,3)})\\cdot\\Psi_{(2,3,4)}(Y_{(2,3,4)})\\right]}\\] 习题11.2 证明\\(Z(x)=a_n^T(x) \\cdot \\boldsymbol{1} = \\boldsymbol{1}^T\\cdot\\beta_1(x)\\)，其中\\(\\boldsymbol{1}\\)是元素均为1的\\(m\\)维列向量。 解答： 第1步：证明\\(Z(x)=a_n^T(x) \\cdot \\boldsymbol{1}\\) 根据条件随机场的矩阵形式：\\[(M_{n+1}(x))_{i,j}=\\begin{cases} 1,&amp;j=\\text{stop}\\\\ 0,&amp;\\text{otherwise} \\end{cases}\\]根据前向向量的定义：\\[\\alpha_0(y|x)=\\begin{cases} 1,&amp;y=\\text{start} \\\\ 0,&amp;\\text{otherwise} \\end{cases}\\] \\(\\begin{aligned} \\therefore Z_n(x) &amp;= \\left(M_1(x)M_2(x){\\cdots}M_{n+1}(x)\\right)_{(\\text{start},\\text{stop})} \\\\ &amp;= \\alpha_0(x)^T M_1(x)M_2(x){\\cdots}M_n(x) \\cdot 1\\\\ &amp;=\\alpha_n(x)^T\\cdot \\boldsymbol{1} \\end{aligned}\\) 第2步：证明\\(Z(x)=\\boldsymbol{1}^T \\cdot \\beta_1(x)\\) 根据条件随机场的矩阵形式：\\[(M_{n+1}(x))_{i,j}=\\begin{cases} 1,&amp;j=\\text{stop}\\\\ 0,&amp;\\text{otherwise} \\end{cases}\\]根据后向向量定义：\\[\\beta_{n+1}(y_{n+1}|x)= \\begin{cases} 1,&amp; y_{n+1}=\\text{stop} \\\\ 0,&amp; \\text{otherwise} \\end{cases}\\] \\(\\begin{aligned} \\therefore Z_n(x) &amp;= (M_1(x)M_2(x) \\cdots M_{n+1}(x))_{(\\text{start},\\text{stop})} \\\\ &amp;= (M_1(x)M_2(x) \\cdots M_n(x) \\beta_{n+1}(x))_{\\text{start}} \\\\ &amp;=(\\beta_1(x))_{\\text{start}} \\\\ &amp;=\\boldsymbol{1}^T \\cdot \\beta_1(x) \\end{aligned}\\) 综上所述：\\(Z(x)=a_n^T(x) \\cdot \\boldsymbol{1} = \\boldsymbol{1}^T \\cdot \\beta_1(x)\\)，命题得证。 习题11.3 写出条件随机场模型学习的梯度下降法。 解答： 条件随机场的对数极大似然函数为：\\[L(w)=\\sum^N_{j=1} \\sum^K_{k=1} w_k f_k(y_j,x_j)-\\sum^N_{j=1} \\log{Z_w(x_j)}\\]梯度下降算法的目标函数是\\(f(w)=-L(w)\\) 目标函数的梯度为：\\[g(w)=\\nabla{f(w^{(k)})}=\\left(\\frac{\\partial{f(w)}}{\\partial{w_1}},\\frac{\\partial{f(w)}}{\\partial{w_2}},\\cdots,\\frac{\\partial{f(w)}}{\\partial{w_k}}\\right)\\]其中\\[\\begin{aligned} \\frac{\\partial{f(w)}}{\\partial{w_i}} &amp;= -\\sum^N_{j=1} w_i f_i(y_j,x_j) + \\sum^N_{j=1} \\frac{1}{Z_w(x_j)} \\cdot \\frac{\\partial{Z_w(x_j)}}{\\partial{w_i}}\\\\ &amp;= -\\sum^N_{j=1}w_if_i(y_j,x_j)+\\sum^N_{j=1}\\frac{1}{Z_w(x_j)}\\sum_y(\\exp{\\sum^K_{k=1}w_kf_k(y,x_j))}w_if_i(y,x_j) \\end{aligned}\\] 根据梯度下降算法： 1. 取初始值\\(w^{(0)} \\in \\mathbf{R}^n\\)，置\\(k=0\\) 2. 计算\\(f(w^{(k)})\\) 3. 计算梯度\\(g_k=g(w^{(k)})\\)，当\\(\\|g_k\\|&lt;\\varepsilon\\)时，停止迭代，令\\(w^*=w^{(k)}\\)；否则令\\(p_k=-g(w^{(k)})\\)，求\\(\\lambda_k\\)，使\\[ f(w^{(k)}+\\lambda_k p_k)=\\min_{\\lambda \\geqslant 0}{f(w^{(k)}+\\lambda p_k)}\\] 4. 置\\(w^{(k+1)}=w^{(k)}+\\lambda_k p_k\\)，计算\\(f(w^{(k+1)})\\) 当\\(\\|f(w^{(k+1)})-f(w^{(k)})\\| &lt; \\epsilon\\)或\\(\\|w^{(k+1)}-w^{(k)}\\| &lt; \\epsilon\\)时，停止迭代，令\\(w^*=w^{(k+1)}\\) 5. 否则，置\\(k=k+1\\)，转(3). 习题11.4 参考图11.6的状态路径图，假设随机矩阵\\(M_1(x),M_2(x),M_3(x),M_4(x)\\)分别是 \\[M_1(x)=\\begin{bmatrix}0&amp;0\\\\0.5&amp;0.5\\end{bmatrix} , M_2(x)=\\begin{bmatrix}0.3&amp;0.7\\\\0.7&amp;0.3\\end{bmatrix}\\] \\[ M_3(x)=\\begin{bmatrix}0.5&amp;0.5\\\\0.6&amp;0.4\\end{bmatrix}, M_4(x)=\\begin{bmatrix}0&amp;1\\\\0&amp;1\\end{bmatrix}\\] 求以\\(start=2\\)为起点\\(stop=2\\)为终点的所有路径的状态序列\\(y\\)的概率及概率最大的状态序列。 解答： 123456789import numpy as np# 创建随机矩阵M1 = [[0, 0], [0.5, 0.5]]M2 = [[0.3, 0.7], [0.7, 0.3]]M3 = [[0.5, 0.5], [0.6, 0.4]]M4 = [[0, 1], [0, 1]]M = [M1, M2, M3, M4]print(M) [[[0, 0], [0.5, 0.5]], [[0.3, 0.7], [0.7, 0.3]], [[0.5, 0.5], [0.6, 0.4]], [[0, 1], [0, 1]]] 123456789101112# 生成路径path = [2]for i in range(1, 4): paths = [] for _, r in enumerate(path): temp = np.transpose(r) paths.append(np.append(temp, 1)) paths.append(np.append(temp, 2)) path = paths.copy()path = [np.append(r, 2) for _, r in enumerate(path)]print(path) [array([2, 1, 1, 1, 2]), array([2, 1, 1, 2, 2]), array([2, 1, 2, 1, 2]), array([2, 1, 2, 2, 2]), array([2, 2, 1, 1, 2]), array([2, 2, 1, 2, 2]), array([2, 2, 2, 1, 2]), array([2, 2, 2, 2, 2])] 123456789101112# 计算概率pr = []for _, row in enumerate(path): p = 1 for i in range(len(row) - 1): a = row[i] b = row[i + 1] p *= M[i][a - 1][b - 1] pr.append((row.tolist(), p))pr = sorted(pr, key=lambda x: x[1], reverse=True)print(pr) [([2, 1, 2, 1, 2], 0.21), ([2, 2, 1, 1, 2], 0.175), ([2, 2, 1, 2, 2], 0.175), ([2, 1, 2, 2, 2], 0.13999999999999999), ([2, 2, 2, 1, 2], 0.09), ([2, 1, 1, 1, 2], 0.075), ([2, 1, 1, 2, 2], 0.075), ([2, 2, 2, 2, 2], 0.06)] 1234567# 打印结果print(&quot;以start=2为起点stop=2为终点的所有路径的状态序列y的概率为：&quot;)for path, p in pr: print(&quot; 路径为：&quot; + &quot;-&gt;&quot;.join([str(x) for x in path]), end=&quot; &quot;) print(&quot;概率为：&quot; + str(p))print(&quot;概率[&quot; + str(pr[0][1]) + &quot;]最大的状态序列为:&quot;, &quot;-&gt;&quot;.join([str(x) for x in pr[0][0]])) 以start=2为起点stop=2为终点的所有路径的状态序列y的概率为： 路径为：2-&gt;1-&gt;2-&gt;1-&gt;2 概率为：0.21 路径为：2-&gt;2-&gt;1-&gt;1-&gt;2 概率为：0.175 路径为：2-&gt;2-&gt;1-&gt;2-&gt;2 概率为：0.175 路径为：2-&gt;1-&gt;2-&gt;2-&gt;2 概率为：0.13999999999999999 路径为：2-&gt;2-&gt;2-&gt;1-&gt;2 概率为：0.09 路径为：2-&gt;1-&gt;1-&gt;1-&gt;2 概率为：0.075 路径为：2-&gt;1-&gt;1-&gt;2-&gt;2 概率为：0.075 路径为：2-&gt;2-&gt;2-&gt;2-&gt;2 概率为：0.06 概率[0.21]最大的状态序列为: 2-&gt;1-&gt;2-&gt;1-&gt;2","link":"/posts/57809.html"},{"title":"正则表达式","text":"简介 字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取 @ 前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。 正则表达式是一种用来匹配字符串的强大工具。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 所以我们判断一个字符串是否是合法的Email的方法是： 创建一个匹配Email的正则表达式； 用该正则表达式去匹配用户的输入来判断是否合法。 因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。 在正则表达式中，如果直接给出字符，就是精确匹配。用 \\d 可以匹配一个数字，\\w 可以匹配一个字母或数字，\\s 可以匹配一个空格（也包括Tab等空白符）。所以： '00\\d' 可以匹配 '007'，但无法匹配 '00A'； '\\d\\d\\d' 可以匹配 '010'； '\\w\\w\\d' 可以匹配 'py3'； . 可以匹配任意字符，所以： 'py.' 可以匹配 'pyc'、'pyo'、'py!' 等等。 要匹配变长的字符，在正则表达式中，用 * 表示任意个字符（包括0个），用 + 表示至少一个字符，用 ? 表示0个或1个字符，用 {n} 表示n个字符，用 {n,m} 表示n-m个字符： 来看一个复杂的例子：\\d{3}\\s+\\d{3,8} 我们来从左到右解读一下： \\d{3} 表示匹配3个数字，例如 '010'； \\s+ 表示至少有一个空格，例如匹配 ' '，' ' 等； \\d{3,8} 表示3-8个数字，例如 '1234567'。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配 '010-12345' 这样的号码呢？由于 '-' 是特殊字符，在正则表达式中，要用 '\\' 转义，所以，用于匹配的正则表达式应为 \\d{3}\\-\\d{3,8}。 但是，上面的方法无法匹配 '010 - 12345'，我们需要更复杂的匹配方式。 进阶 要做更精确地匹配，可以用 [] 表示一个范围，比如： [0-9a-zA-Z\\_] 可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等； [a-zA-Z\\_][0-9a-zA-Z\\_]* 可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量； [a-zA-Z\\_][0-9a-zA-Z\\_]{0, 19} 更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B 可以匹配A或B，所以 (P|p)ython 既可以匹配 'Python' 又可以匹配 'python'。 ^ 表示行的开头，^\\d 表示必须以数字开头。 $ 表示行的结束，\\d$ 表示必须以数字结束。 有趣的是 py 也可以用来匹配 'python'，但是加上 ^py$ 就变成了整行匹配，只能匹配 'py' 了。 re模块 有了准备知识，我们就可以在Python中使用正则表达式了。Python提供了 re 模块，包含所有正则表达式的功能。注意，在正则表达式中，我们使用 \\ 来表示转义，但在Python的字符串中，\\ 同样是一个转义符。因此，使用时我们就要特别注意字符串中的 \\ 是否能正确地起作用。比方说： 1s = 'ABC\\\\-001' 这个字符串中，第一个 \\ 用于为第二个 \\ 转义，所以打印这个字符串实际上得到的是 'ABC-001'，这样用作正则表达式时，就能正确地转义 -。而： 1s = 'ABC\\-001' 这个字符串实际上是 'ABC-001'，由于 - 在正则表达式中是一个特殊字符，而这里我们希望的是它只作为用于匹配字符 - 的功能，所以这样得到的正则表达式就出错了。 因此在书写正则表达式时，推荐使用Python字符串的 r 前缀，这样就不用考虑字符转义的问题了： 1s = r'ABC\\-001' r 前缀表示后面的字符串中无需转义字符。 接下来看看如何判断正则表达式是否与字符串匹配： 12345&gt;&gt;&gt; import re&gt;&gt;&gt; re.match(r'^\\d{3}\\-\\d{3,8}$', '010-12345')&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;&gt;&gt;&gt; re.match(r'^\\d{3}\\-\\d{3,8}$', '010 12345')&gt;&gt;&gt; re 模块的 match() 方法判断是否匹配，如果匹配成功，返回一个 Match 对象，否则返回 None。常见的判断方法就是： 12345test = '用户输入的字符串'if re.match(r'正则表达式', test): print('ok')else: print('failed') 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 12&gt;&gt;&gt; 'a b c'.split(' ')['a', 'b', '', '', 'c'] 嗯，无法识别连续的空格，用正则表达式试试： 12&gt;&gt;&gt; re.split(r'\\s+', 'a b c') # '\\s+'表示至少匹配一个空白字符['a', 'b', 'c'] 无论多少个空格都可以正常分割。加入 , 试试： 12&gt;&gt;&gt; re.split(r'[\\s\\,]+', 'a,b, c d')['a', 'b', 'c', 'd'] 再加入 ; 试试： 12&gt;&gt;&gt; re.split(r'[\\s\\,\\;]+', 'a,b;; c d')['a', 'b', 'c', 'd'] 如果用户输入了一组标签，下次记得可以用正则表达式来把不规范的输入转化成正确的数组。 分组 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用 () 表示的就是要提取的分组（Group）。比如： ^(\\d{3})-(\\d{3,8})$ 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123456789&gt;&gt;&gt; m = re.match(r'^(\\d{3})-(\\d{3,8})$', '010-12345')&gt;&gt;&gt; m&lt;_sre.SRE_Match object; span=(0, 9), match='010-12345'&gt;&gt;&gt;&gt; m.group(0)'010-12345'&gt;&gt;&gt; m.group(1)'010'&gt;&gt;&gt; m.group(2)'12345' 如果正则表达式中定义了组，就可以在 Match 对象上用 group() 方法提取出某个子串。注意到 group(0) 永远是原始字符串，group(1)、group(2) …… 表示第1、2、……个子串。 提取子串非常有用。来看一个更凶残的例子： 1234&gt;&gt;&gt; t = '19:05:30'&gt;&gt;&gt; m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)&gt;&gt;&gt; m.groups()('19', '05', '30') 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$' 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要编写其他代码来配合识别了。 贪婪匹配 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12&gt;&gt;&gt; re.match(r'^(\\d+)(0*)$', '102300').groups()('102300', '') 由于 \\d+ 采用贪婪匹配，直接把后面的0全部匹配了，结果 0* 就只能匹配到空字符串了。 必须让 \\d+ 采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，这时我们可以使用 ? 来让 \\d+ 采用非贪婪匹配： 12&gt;&gt;&gt; re.match(r'^(\\d+?)(0*)$', '102300').groups()('1023', '00') 编译 当我们在Python中使用正则表达式时，re 模块内部会干两件事情： 编译正则表达式，如果正则表达式的字符串本身不合法，会报错； 用编译后的正则表达式去匹配字符串。 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译正则表达式，接下来重复使用时就不需要编译这个步骤了，可以直接匹配： 12345678&gt;&gt;&gt; import re# 编译:&gt;&gt;&gt; re_telephone = re.compile(r'^(\\d{3})-(\\d{3,8})$')# 使用：&gt;&gt;&gt; re_telephone.match('010-12345').groups()('010', '12345')&gt;&gt;&gt; re_telephone.match('010-8086').groups()('010', '8086') 编译后生成 Regular Expression 对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。 小结 正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。 练习 习题一 请尝试写一个验证Email地址的正则表达式，可以验证类似以下格式的Email： 12someone@gmail.combill.gates@microsoft.com 代码： 12345678910import rere_email = re.compile(r'^[a-z.]+?@[a-z]+?.com$')while True: test = input('\\nPlease input your email address: ') if re_email.match(test): print('ok') else: print('failed') 习题二 继续上一题，但这次的Email地址带名字，要既能验证地址又能提取出名字： 12&lt;Tom Paris&gt; tom@voyager.com&lt;Mary Liu&gt; mary@microsoft.com 代码： 1234567891011import rere_email = re.compile(r'^&lt;([A-Za-z\\s]+?)\\s([A-Za-z\\s]+?)&gt;\\s([a-z.]+?@[a-z]+?.com)$')while True: test = input('\\nPlease input your email address: ') match = re_email.match(test) if match: print(match.group(1)+' '+match.group(2)+&quot;'s email address is: &quot;+match.group(3)) else: print('failed')","link":"/posts/46563.html"},{"title":"包","text":"package与import 在实际的开发中，我们往往需要在不同的文件中，去调用其它文件的定义的函数，比如 main.go 中，需要使用\"fmt\"包中的Println()函数： 12package mainimport &quot;fmt&quot; 在Go中，Go的每一个文件都是属于一个包的，也就是说Go是以包的形式来管理文件和项目目录结构。所以如果要导入某些第三方包，直接输入包所在地址即可。文件的包名通常和文件所在的文件夹名一致，一般为小写字母。 123456引入方式 1:import &quot;包名&quot;引入方式 2:import ( &quot;包名&quot; &quot;包名&quot; ) package 指令在 文件第一行，然后是 import 指令 在 import 包时，路径从 $GOPATH 的 src 下开始，不用带 src , 编译器会自动从 src 下开始引入 为了让其它包的文件，可以访问到本包的函数，则该函数名的首字母需要大写，类似其它语言 的 public ,这样才能跨包访问 在访问其它包函数，变量时，其语法是 包名.函数名 GoPath GoPath目录用来存放代码文件、可运行文件、编译后的包文件。 从1.1版本到1.7必须设置这个变量，而且不能和Go的安装目录一样，1.8版本后会有默认值： 12Unix:$HOME/goWindows:%USERPROFILE%/go。 GOPATH允许多个目录，多个目录的时候Windows是分号，Linux系统是冒号隔开。当有多个GOPATH时，默认会将go get的内容放在第一个目录下，\\(GOPATH 目录约定有三个子目录： - src:存放源代码，一般一个项目分配一个子目录; - pkg:编译后生成的文件，如.a文件 - bin:编译后生成的可执行文件,可以加入\\)PATH中 &gt;注意：一般建议package的名称和目录名保持一致 1.3 包中的函数调用方式 函数调用的方式： - 同包下：直接调用即可 - 不同包下：包名.函数名 go mod go mod 的使用 go的项目依赖管理一直饱受诟病，在go1.11后正式引入了go mod功能，类似nodejs的npm。在go1.13版本中将会默认启用。 使用Gomod可以让项目完全摆脱GOPATH的困扰。 go mod 初步使用： 123456789101112# 开启go modexport GO111MODULE=on# 在新建的项目根目录下（src）下使用该命令go mod init 项目名 # 此时会生成一个go.mod文件# 使用在项目中可以随时import依赖，当 go run 时候，会自动安装依赖，比如：import ( &quot;github.com/gin-gonic/gin&quot;) go run 后的 go.mod: 12345678910111213module api_servergo 1.12require ( github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 // indirect github.com/gin-gonic/gin v1.3.0 // indirect github.com/golang/protobuf v1.3.1 // indirect github.com/mattn/go-isatty v0.0.7 // indirect github.com/ugorji/go/codec v0.0.0-20190320090025-2dc34c0b8780 // indirect gopkg.in/go-playground/validator.v8 v8.18.2 // indirect gopkg.in/yaml.v2 v2.2.2 // indirect) 使用go mod后，run产生的依赖源码不会安装在当前项目中，而是安装在：$GOPATH/pkg/mod 详细使用 详细使用地址：https://zhuanlan.zhihu.com/p/59687626 翻墙问题解决 推荐方式 GOPROXY 从 Go 1.11 版本开始，还新增了 GOPROXY 环境变量，如果设置了该变量，下载源代码时将会通过这个环境变量设置的代理地址，而不再是以前的直接从代码库下载。goproxy.io 这个开源项目帮我们实现好了我们想要的。该项目允许开发者一键构建自己的 GOPROXY 代理服务。同时，也提供了公用的代理服务 https://goproxy.io，我们只需设置该环境变量即可正常下载被墙的源码包了： 12345678910# 开发时设置Goland的Prefrence-Go-proxy即可# linux开启代理export GOPROXY=https://goproxy.io # 注意：必须开启go mod才能使用# win开启代理$env:GOPROXY = &quot;https://goproxy.io&quot;# 关闭代理export GOPROXY= replace方式 从 Go 1.11 版本开始，新增支持了 go modules 用于解决包依赖管理问题。该工具提供了 replace，就是为了解决包的别名问题，也能替我们解决 golang.org/x 无法下载的的问题。 go module 被集成到原生的 go mod 命令中，但是如果你的代码库在 $GOPATH 中，module 功能是默认不会开启的，想要开启也非常简单，通过一个环境变量即可开启 export GO111MODULE=on。 123456789module example.com/hellorequire ( golang.org/x/text v0.3.0)replace ( golang.org/x/text =&gt; github.com/golang/text v0.3.0) 手动下载 旧版go的解决 我们常见的 golang.org/x/... 包，一般在 GitHub 上都有官方的镜像仓库对应。比如 golang.org/x/text 对应 github.com/golang/text。所以，我们可以手动下载或 clone 对应的 GitHub 仓库到指定的目录下。 mkdir $GOPATH/src/golang.org/x cd $GOPATH/src/golang.org/x git clone git@github.com:golang/text.git rm -rf text/.git 当如果需要指定版本的时候，该方法就无解了，因为 GitHub 上的镜像仓库多数都没有 tag。并且，手动嘛，程序员怎么能干呢，尤其是依赖的依赖，太多了。 go mod引起的变化 引包方式变化： - 不使用go mod 引包：\"./test\" 引入test文件夹 - 使用go mod 引包：\"projectmodlue/test\" 使用go.mod中的modlue名/包名 因为在go1.11后如果开启了go mod，需要在src目录下存在go.mod文件，并书写主module名（一般为项目名），否则无法build。 开启go mod编译运行变化： - 使用vscode开发，必须在src目录下使用 go build命令执行，不要使用code runner插件 - 使用IDEA开发，项目本身配置go.mod文件扔不能支持，开发工具本身也要开启go mod支持（位于配置的go设置中）","link":"/posts/38068.html"},{"title":"面向对象初识","text":"模拟构造函数 Go和传统的面向对象语言如Java有着很大区别。结构体没有构造函数初始化功能，可以通过以下方式模拟： 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot;)type Person struct { Name string Age int}func NewPersonByName(name string) *Person { return &amp;Person{ Name: name, }}func NewPersonByAge(age int) *Person { return &amp;Person{ Age: age, }}func main() { p := NewPersonByName(&quot;zs&quot;) fmt.Println(p) // {zs 0}} 贴士：因为Go没有函数重载，为了避免函数名字冲突，使用了NewPersonByName和NewPersonByAge两个不同的函数表示不同的Person构造过程。 父子关系结构体初始化 Person可以看做父类，Student是子类，子类需要继承父类的成员，该如何处理？ 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot;)type Person struct { Name string Age int}type Student struct { Person ClassName string}//构造父类func NewPerson(name string, age int) *Person { return &amp;Person{ Name: name, Age: age, }}//构造子类func NewStudent(classname string) *Student { p := &amp;Student{} p.ClassName = classname return p}func main() { s := NewStudent(&quot;一班&quot;) fmt.Println(s) // &amp;{{ 0} 一班}} 我们发现Student中的Person也被一并实例化了。Go中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。 Go中的面向对象初识 在Go中，可以给任意类型（除了指针）添加相应方法： 12345678910type Interger intfunc (i Interger) Less (j Interger) bool { return i &lt; j}func main() { var i Interger = 1 fmt.Print(i.Less(5))} 方法 方法的定义 面向过程的函数书写案例： 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)type Person struct { Name string Age int}func run(p *Person, name string) { p.Name = name fmt.Printf(&quot;%s is runnig...\\n&quot;, p.Name)}func main() { p1 := &amp;Person{} run(p1, &quot;zs&quot;)} 在某些情况下，我们要需要声明(定义)方法。比如 Person 结构体:除了有一些字段外( 年龄，姓名..),Person 结构体还有一些行为比如:可以说话、跑步..,通过学习，还可以做算术题，这时就要用方法才能完成。 Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。 方法的声明和调用： 1234func (recevier type) methodName(参数列表) (返回值列表){ //方法体 return 返回值} 示例代码： 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot;)type Person struct { Name string Age int}func (p *Person) run() { // p为接收器 fmt.Printf(&quot;%s is runnig...\\n&quot;, p.Name)}func main() { //方式一 p1 := Person{ Name: &quot;Tom&quot;, Age: 18, } p1.run() //方式二 p2 := new(Person) p2.Name = &quot;Jerry&quot; p2.run()} Go方法本质 Go的方法是一种作用于特定类型变量的函数，这种特定类型的变量叫做接收器（Receiver）。如果特定类型理解为结构体或者“类”时，接收器就类似于其他语言的this或者self。 在Go中，接收器可以是任何类型，不仅仅是结构体。 依此我们看出，Go中的方法和其他语言的方法类似，但是Go语言的接收器强调方法的作用对象是实例。 方法与函数的区别就是：函数没有作用对象。 理解接收器 上述Person案例中，接收器类型是*Person，属于指针类型，非常接近Java中的this，由于指针的特性，调用方法时，修改接收器指针的任意长远变量，在方法结束后，修改都是有效的。 当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效，如下所示： 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;//定义一个表示点的结构体type Point struct { X int Y int}//非指针接收器func (p Point) Add(otherP Point) Point { return Point{ p.X + otherP.X, p.Y + otherP.Y, }}func main() { p1 := Point{1, 1} p2 := Point{2, 2} result := p1.Add(p2) fmt.Println(result) // {3 3}} 一般情况下，小对象由于复制时速度较快，适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，此时再接收器和参数之间传递时不进行复制，只传递指针。","link":"/posts/36489.html"},{"title":"方法与函数的混合使用","text":"Go语言可以将类型的方法与普通函数作为一个概念，从而简化方法和函数混合作为回调类型时的复杂性。该特性与C#中的delegate类似，调用者无须关心谁来支持调用，系统会自动处理是否调用普通函数还是类型方法。 以下案例将实现一个普通函数FuncDo，一个类型方法ClassDo，二者签名一致： 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot;)type class struct {}//方法func (c *class) ClassDo(v int) { fmt.Println(&quot;class do: &quot;, v)}//函数func FuncDo(v int) { fmt.Println(&quot;func do: &quot;, v)}func main() { //声明一个函数回调 var delegate func(int) c := new(class) //将回调设为c的类型方法 delegate = c.ClassDo delegate(100) // class do: 100 //将回调设为c的普通函数 delegate = FuncDo delegate(50) // func do: 50} 事件系统原理 事件系统可以将事件派发者与事件处理者解耦，例如网络底层可以生成各种事件，在网络连接上后，网络底层只需要将事件派发出去，而不需要关心到底哪些代码来响应连接上的逻辑。 一个事件系统拥有如下特征： - 能够实现事件的一方，可以根据事件ID或名字注册对应的事件 - 事件发起者，会根据注册信息通知这些注册者 - 一个事件可以有多个实现方响应 事件系统开发 事件注册 事件系统需要为外部提供一个注册入口，这个注册入口传入注册的事件名称和对应事件名称的响应函数，事件注册的过程就是将事件名称和响应函数关联并保存起来。 1234567891011121314151617//实例化一个通过字符串映射函数切片的mapvar EventMap = make(map[string][]func(interface{}))//注册事件，提供事件名和回调函数func RegistEvent(eventName string, callback func(interface{})) { //通过名字查找事件列表 eventList := EventMap[eventName] //在列表切片中添加函数 eventList = append(eventList, callback) //保存修改的事件列表切片 EventMap[eventName] = eventList } 事件调用 事件调用方是事发现场，负责将事件和事件发生的参数通过事件系统派发出去，而不关心事件到底由谁处理。 12345678910111213//调用事件func CallEvent(eventName string, param interface{}) { //通过名称找到事件列表 eventList := EventMap[eventName] //遍历这个事件的所有回调 for _, callback := range eventList { callback(param) }} 事件调用 1234567891011121314151617181920212223242526//声明角色的结构体type Actor struct {}//为角色添加一个事件处理函数func (a *Actor) Test(param interface{}) { fmt.Println(&quot;test event: &quot;, param)}//全局事件func GlobalEvent(param interface{}) { fmt.Println(&quot;global event: &quot;, param)}func main() { a := new(Actor) RegistEvent(&quot;OnSkill&quot;, a.Test) //注册名为OnSkill的事件 RegistEvent(&quot;OnSkill&quot;, GlobalEvent) //再次注册全局事件 CallEvent(&quot;OnSkill&quot;, 100)}上述事件按照注册的顺序被触发。","link":"/posts/63864.html"},{"title":"面向对象三大特性","text":"封装 封装就是把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行操作。 通过封装，可以： - 隐藏实现细节 - 可以对数据进行验证，保证安全合理 封装的实现步骤： 1234567891011121 将结构体、字段(属性)的首字母小写(私有化)；2 给结构体所在包提供一个工厂模式的函数，首字母大写，类似一个构造函数；3 提供一个首字母大写的 Set 方法(类似其它语言的 public)，用于对属性判断并赋值： func (var 结构体类型名) SetXxx(参数列表) (返回值列表) { //加入数据验证的业务逻辑 var.字段 = 参数 }1) 提供一个首字母大写的 Get 方法(类似其它语言的 public)，用于获取属性的值： func (var 结构体类型名) GetXxx() { return var.age }特别说明:在 Golang 开发中并没有特别强调封装，这点并不像 Java. 所以提醒学过 java 的朋友， 不用总是用 java 的语法特性来看待 Golang, Golang 本身对面向对象的特性做了简化的. 123456789101112131415161718192021222324252627282930313233343536373839404142//person.gopackage modelimport &quot;fmt&quot;type person struct { Name string age int //年龄是隐私，不允许其他包访问}//工厂函数（类似构造函数）func Person(name string) *person { return &amp;person{ Name: name, }}func (p *person) SetAge(age int) { if age &gt; 0 &amp;&amp; age &lt; 150 { //校验 p.age = age } else { fmt.Println(&quot;年龄不合法&quot;) }}func (p *person) GetAge() int { return p.age}//main.gopackage mainimport ( &quot;./model&quot; &quot;fmt&quot;)func main() { p := model.Person(&quot;Tom&quot;) p.SetAge(18) fmt.Println(p)} 继承 在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访 问匿名结构体的字段和方法，从而实现了继承特性。 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot;)type Father struct { Name string age int}func (f *Father) run() { fmt.Println(f.Name + &quot; like running...&quot;)}type Son struct { Father //嵌套匿名结构体}func main() { var s Son //s.Father.Name = &quot;Tom&quot; //s.Father.age = 10 //可以访问未导出属性 //s.Father.run() //可以访问未导出方法 //上述可以简写为： s.Name = &quot;Tom&quot; s.age = 10 s.run()} 注意： - 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问 匿名结构体的字段和方法，可以通过匿名结构体名来区分。 - 结构体嵌入两个(或多个)匿名结构体，如两个匿名结构体有相同的字段和方法(同时结构体本身 没有同名的字段和方法)，在访问时，就必须明确指定匿名结构体名字，否则编译报错。 - 如果一个 struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字。 关于多重继承： 如果一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;fmt&quot;)type Father1 struct { Name string age int}func (f *Father1) run() { fmt.Println(f.Name + &quot; like running...&quot;)}type Father2 struct { Like string}type Son1 struct { Father1 Father2}type Son2 struct { *Father1 *Father2}func main() { s1 := Son1 { Father1{ Name: &quot;Tom&quot;, age: 10, }, Father2{ Like: &quot;伏特加&quot;, }, } fmt.Println(s1) s2 := Son2{ &amp;Father1{ Name: &quot;Tom&quot;, age: 10, }, &amp;Father2{ Like: &quot;伏特加&quot;, }, } fmt.Println(*s2.Father1)} 如嵌入的匿名结构体有相同的字段名或者方法名，则在访问时，需要通过匿名结构体类型名来 区分。为了保证代码的简洁性，建议大家尽量不使用多重继承。 多态 多态与接口（interface）有关联，参见接口章节","link":"/posts/15667.html"},{"title":"接口 interface","text":"接口定义 接口（interface）是调用方和实现方均需要遵守的一种约束，大家按照统一的方法命名、参数类型和数量来协调逻辑处理的过程。实际上，接口就是一组不需实现的方法声明，不能包含任何变量。到某个自定义类型要使用的时候,在根据具体情况把这些方法写出来(实现)。 Go的接口是非侵入式设计的，接口编写者无需知道接口被哪些类型实现，接口实现者只需要知道实现的是什么样子的接口，但无需指明实现了哪个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。 接口语法： 12345type 接口类型名 interface { 方法名1(参数列表) 返回值列表 方法名2(参数列表) 返回值列表 ...} 注意： - Go语言的接口在命名时，一般会在单词后面添加er，如写操作的接口叫做Writer - 当方法名首字母大写，且实现的接口首字母也是大写，则该方法可以被接口所在包之外的代码访问 - 参数列表和返回值列表中的变量名可以被忽略，如：type writer interfae{ Write([]byte) error} - Go标准包，每个接口包含的方法很少，Go希望一个接口精准描述它自己的功能。 接口实现 接口实现的条件： - 方法与接口中的方法签名一致（方法名、参数列表、返回列表都必须一致） - 接口中所有的方法都必须被实现 示例： 123456789101112131415161718192021222324252627//定义一个数据写入接口type DataWriter interface { WriteData(data interface{}) error}//定义文件对象，实现WriteData()方法type file struct {}//实现接口func (f *file) WriteData(data interface{}) error { fmt.Print(&quot;WriteData: &quot;, data) //模拟写入 return nil}func main() { f := new(file) var writer DataWriter //声明一个DataWriter接口 writer = f //将接口赋值给f，即*file类型 writer.WriteData(&quot;data...&quot;) //模拟数据写入} 注意： - 如果在编译到writer = f发现实现接口的方法签名不一致，则会报错：does not implement。 - 如上所示，Go无须像Java那样显式声明实现了哪个接口，即为非侵入式。 - 使用writer接口调用了接头体file的方法，也可以理解为实现了面向对象中的多态 接口与类型的关系 类型和接口之间有一对多和多对一的关系，即： - 一个类型可以实现多个接口，接口间是彼此独立的，互相不知道对方的实现 - 多个类型也可以实现相同的接口。 123456789101112131415161718192021222324252627type Service interface { Start() Log(string)}// 日志器type Logger struct {}//日志输出方法func (g *Logger) Log(s string){ fmt.Println(&quot;日志：&quot;, s)}// 游戏服务type GameService struct { Logger}// 实现游戏服务的Start方法func (g *GameService) Start() { fmt.Println(&quot;游戏服务启动&quot;)}func main() { s := new(GameService) s.Start() s.Log(&quot;hello&quot;)} 在上述案例中，即使没有接口也能运行，但是当存在接口时，会隐式实现接口，让接口给类提供约束。 接口嵌套 Go中不仅结构体之间可以嵌套，接口之间也可以嵌套。接口与接口嵌套形成了新的接口，只要接口的所有方法被实现，则这个接口中所有嵌套接口的方法均可以被调用。 123456789101112type Writer interface { Write(p []byte) (n int, e error)}type Closer interface { Close() error}type WriteCloser interface { Writer Closer} 接口断言 类型断言定义 Go中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为别的类型，这是非常常见的使用。 类型断言格式: 12t := i.(T) //不安全写法：如果i没有完全实现T接口的方法，这个语句将会触发宕机t, ok := i.(T) // 安全写法：如果接口未实现接口，将会把ok掷为false，t掷为T类型的0值 - i代表接口变量 - T代表转换的目标类型 - t代表转换后的变量 接口转换为其他接口 实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。 鸟和猪都具有不同的特性，鸟可以飞，猪不能飞，但是二者都可以走，如果使用结构体实现鸟和猪，让他具备各自的特性Fly()和Walk()方法就让鸟和猪各自实现了飞行动物接口Flyer和行走动物接口Walker。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//飞行动物接口type Flyer interface { Fly()}//行走动物接口type Walker interface { Walk()}//鸟类type bird struct {}//鸟类实现飞行动物接口func (b *bird) Fly() { fmt.Println(&quot;bird: fly&quot;)}//鸟类实现行走动物接口func (b *bird) Walk() { fmt.Println(&quot;bird: walk&quot;)}//猪类type pig struct {}//猪类实现行走动物接口，没有实现飞行接口func (p *pig) Walk() { fmt.Println(&quot;pig: walk&quot;)}func main() { //创建动物名字到实例的映射 animals := map[string]interface{}{ &quot;bird&quot;: new(bird), &quot;pig&quot;: new(pig), } for name, obj := range animals { // 断言：判断对象是否是飞行动物，行走动物 f, isFlyer := obj.(Flyer) w, isWalker := obj.(Walker) fmt.Printf(&quot;name is %s \\n&quot;, name) if isFlyer { f.Fly() } if isWalker { w.Walk() } } } 将接口转换为其他类型 在上述代码中，可以实现将接口转换为普通的指针类型，例如将Walker接口转换为*pig类型： 1234567p1 := new(pig)var a Walker = p1p2 := a.(*pig)fmt.Printf(&quot;p1=%p p2=%p&quot;, p1, p2) //发现二者相同 类型查询 在Go中，可以直接询问接口指向的对象实例的类型： 123456var v1 interfaceP{} = ...switch v := v1.(type) { case int: case string: ...} 接口实现多态 多态是面向对象的三大特性之一。 示例：动物都具备Move的动作，如果是鸟类的Move，则是飞翔，如果是鱼类的Move则是游泳 12345678910111213141516171819202122232425262728293031323334353637type Animal interface { Move()}type Bird struct { Name string}func (b *Bird) Move() { fmt.Println(&quot;bird fly...&quot;)}type Fish struct { Name string}func (f *Fish) Move() { fmt.Println(&quot;fish swim...&quot;)}func Factory(name string) Animal { switch name { case &quot;bird&quot;: return &amp;Bird{} case &quot;fish&quot;: return &amp;Fish{} default: return nil }}func main() { a := Factory(&quot;bird&quot;) a.Move()} 空接口 空接口定义 空接口是接口的特殊形式，没有任何方法，因此任何类型都无须实现空接口，故而空接口可以保存任何值，（可以简单的将空接口理解为Java中的Object）。 1234567var any interface{}any = 1fmt.Println(any)any = &quot;hello&quot;fmt.Println(any) 从空接口获取值 保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误： 123var a int = 1var i interface{} = avar b int = i //这里编译报错（类型不一致），可以这样做：b := i 空接口值比较 类型不同的空接口比较： 1234var a interface{} = 100var b interface{} = &quot;hi&quot;fmt.Println(a == b) //false 不能比较空接口中的动态值： 123var c interface{} = []int{10}var d interface{} = []int{20}fmt.Println(c == d) //运行报错 空接口的类型和可比较性： | 类型 | 说明 | | ---- | ---- | | map | 不可比较，会发生宕机错误 | | 切片 | 不可比较，会发生宕机错误 | | 通道 | 可比较，必须由同一个make生成，即同一个通道才是true | | 数组 | 可比较，编译期即可知道是否一致 | | 结构体 | 可比较，可诸葛比较结构体的值 | | 函数 | 可比较 |","link":"/posts/19438.html"},{"title":"反射简介","text":"反射是指在程序运行期对程序本身进行访问和修改的能力。即可以在运行时动态获取变量的各种信息，比如变量的类型（type），类别（kind），如果是结构体变量，还可以获取到结构体本身的信息（字段与方法），通过反射，还可以修改变量的值，可以调用关联的方法。 反射常用在框架的开发上，一些常见的案例，如JSON序列化时候tag标签的产生，适配器函数的制作等，都需要用到反射。 贴士： - C，C++没有支持反射功能，只能通过 typeid提供非常弱化的程序运行时类型信息。 - Java、 C#等语言都支持完整的反射功能。 - Lua、 JavaScript类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统 。 Go程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树( AST) 对源码进行扫描后获得这些信息 。 Go中反射相关的包是reflect。 反射操作数据 反射初识 12345var a intfmt.Println(reflect.ValueOf(a)) // 0 变量值fmt.Println(reflect.TypeOf(a)) // int 变量类型对象名，其类型为 reflect.Type()fmt.Println(reflect.TypeOf(a).Name()) // int 变量类型对象的类型名fmt.Println(reflect.TypeOf(a).Kind()) // int 变量类型对象的种类名 编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类(Kind)。例 如，需要统一判断类型中的指针时，使用种类 (Kind)信息就较为方便，即： - Type是系统原生数据类型： int、 string、 boo!、 float32 ，以及 type 定义的类型，对应的反射获取方法是 reflect.Type 中 的 Name() Kind是对象归属的品种：Int、Bool、Float32、Chan、String、Struct、Ptr（指针）、Map、Interface、Fune、Array、Slice、Unsafe Pointer等 操作简单数据类型 12345678var num int64 = 100rValue := reflect.ValueOf(num)//第一种运算方式fmt.Println(num + rValue.Int()) //200//第二种运算方式fmt.Println(num + rValue.Interface().(int64)) //200 反射操作指针 123456789101112type cat struct {}c := &amp;cat{}typeOfCat := reflect.TypeOf(c)fmt.Println(&quot;name: &quot;, typeOfCat.Name()) // 空fmt.Println(&quot;kind: &quot;, typeOfCat.Kind()) // ptrtypeOfCat = typeOfCat.Elem()fmt.Println(&quot;element name: &quot;, typeOfCat.Name()) // catfmt.Println(&quot;element kind: &quot;, typeOfCat.Kind()) // struct 反射操作结构体 通过reflect.TypeOf(）获取到结构体的对象信息后，可以通过 反射值对象( reflect.Type)的 NumField()和 Field()方法获得结构体成员的详细信息。 reflect.Type 的 Field()方法返回 StructField 结构： 123456789type StructField struct { Name string //字段名 PkgPath string //字段路径 Type Type //字段反射类型对象 Tag StructTag //字段的结构体标签 Offset uintptr //字段在结构体中的相对偏移 Index []int //Type.FielddByindex 中的返回的索引值 Anonymous bool //是否为匿名字段} 示例： 12345678910111213141516171819202122type Student struct { Name string Age int `json:&quot;age&quot; id:&quot;100&quot;` // 结构体标签}s := Student{ Name: &quot;zs&quot;, Age: 1,}typeOfStudent := reflect.TypeOf(s)for i := 0; i &lt; typeOfStudent.NumField(); i++ { fieldType := typeOfStudent.Field(i) fmt.Println( fieldType.Name, fieldType.Tag) // Name Age json: &quot;age&quot; id:&quot;100&quot;}fmt.Println(&quot;-------------------&quot;)if studentAge, ok := typeOfStudent.FieldByName(&quot;Age&quot;); ok { fmt.Println(studentAge.Tag.Get(&quot;json&quot;), studentAge.Tag.Get(&quot;id&quot;)) // age 100} 通过类型创建类型的实例 当己知 reflect.Type 时，可以动态地创建这个类型的实例，实例的类型为指针。例如reflect.Type的类型为 int时，创建 int的指针，即*int： 1234var a inttypeOfA := reflect.TypeOf(a)// 创建实例aIns := reflect.New(typeOfA) 使用反射调用函数 如果反射值对象(reflect.Value)中值的类型为函数时，可以通过 reflect.Value调用该 函数。使用反射调用函数时，需要将参数使用反射值对象的切片 口reflect.Value 构造后传入 Call()方法中 ， 调用完成时，函数的返回值通过 []reflect.Value 返回 。 123456funcValue : = reflect .ValueOf(add)paramList := []reflect. Value {reflect. ValueOf (1 0) , reflect.Va l u e O f ( 2 0 ) }// 调用函数retList : = funcValue . Call (paramL工st )","link":"/posts/45341.html"},{"title":"Binary Tree Preorder Traversal","text":"题目地址 https://leetcode.com/problems/binary-tree-preorder-traversal/description/ 题目描述 1234567891011121314Given a binary tree, return the preorder traversal of its nodes' values.Example:Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3]Follow up: Recursive solution is trivial, could you do it iteratively? 思路 这道题目是前序遍历，这个和之前的leetcode 94 号问题 - 中序遍历完全不一回事。 前序遍历是根左右的顺序，注意是根开始，那么就很简单。直接先将根节点入栈，然后 看有没有右节点，有则入栈，再看有没有左节点，有则入栈。 然后出栈一个元素，重复即可。 其他树的非递归遍历课没这么简单 关键点解析 二叉树的基本操作（遍历） &gt; 不同的遍历算法差异还是蛮大的 如果非递归的话利用栈来简化操作 如果数据规模不大的话，建议使用递归 递归的问题需要注意两点，一个是终止条件，一个如何缩小规模 终止条件，自然是当前这个元素是null（链表也是一样） 由于二叉树本身就是一个递归结构， 每次处理一个子树其实就是缩小了规模， 难点在于如何合并结果，这里的合并结果其实就是mid.concat(left).concat(right), mid是一个具体的节点，left和right递归求出即可 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* * @lc app=leetcode id=144 lang=javascript * * [144] Binary Tree Preorder Traversal * * https://leetcode.com/problems/binary-tree-preorder-traversal/description/ * * algorithms * Medium (50.36%) * Total Accepted: 314K * Total Submissions: 621.2K * Testcase Example: '[1,null,2,3]' * * Given a binary tree, return the preorder traversal of its nodes' values. * * Example: * * * Input: [1,null,2,3] * ⁠ 1 * ⁠ \\ * ⁠ 2 * ⁠ / * ⁠ 3 * * Output: [1,2,3] * * * Follow up: Recursive solution is trivial, could you do it iteratively? * *//** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {number[]} */var preorderTraversal = function(root) { // 1. Recursive solution // if (!root) return []; // return [root.val].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right)); // 2. iterative solutuon if (!root) return []; const ret = []; const stack = [root]; let left = root.left; let t = stack.pop(); while(t) { ret.push(t.val); if (t.right) { stack.push(t.right); } if (t.left) { stack.push(t.left); } t =stack.pop(); } return ret;};","link":"/posts/3510445862.html"},{"title":"奇异值分解","text":"1.矩阵的奇异值分解是指将\\(m \\times n\\)实矩阵\\(A\\)表示为以下三个实矩阵乘积形式的运算 \\[A = U \\Sigma V ^ { T }\\] 其中\\(U\\)是\\(m\\)阶正交矩阵，\\(V\\)是\\(n\\)阶正交矩阵，\\(\\Sigma\\)是\\(m \\times n\\)矩形对角矩阵 \\[\\Sigma = \\operatorname { diag } ( \\sigma _ { 1 } , \\sigma _ { 2 } , \\cdots , \\sigma _ { p } ) , \\quad p = \\operatorname { min } \\{ m , n \\}\\] 其对角线元素非负，且满足\\(\\sigma _ { 1 } \\geq \\sigma _ { 2 } \\geq \\cdots \\geq \\sigma _ { p } \\geq 0\\) 2.任意给定一个实矩阵，其奇异值分解一定存在，但并不唯一。 3.奇异值分解包括紧奇异值分解和截断奇异值分解。紧奇异值分解是与原始矩阵等秩的奇异值分解，截断奇异值分解是比原始矩阵低秩的奇异值分解。 4.奇异值分解有明确的几何解释。奇异值分解对应三个连续的线性变换：一个旋转变换，一个缩放变换和另一个旋转变换第一个和第三个旋转变换分别基于空间的标准正交基进行。 5.设矩阵\\(A\\)的奇异值分解为\\(A = U \\Sigma V ^ { T }\\)，则有\\[\\left. \\begin{array} { l } { A ^ { T } A = V ( \\Sigma ^ { T } \\Sigma ) V ^ { T } } \\\\ { A A ^ { T } = U ( \\Sigma \\Sigma ^ { T } ) U ^ { T } } \\end{array} \\right.\\] 即对称矩阵\\(A^TA\\)和\\(AA^T\\)的特征分解可以由矩阵\\(A\\)的奇异值分解矩阵表示。 6.矩阵\\(A\\)的奇异值分解可以通过求矩阵\\(A^TA\\)的特征值和特征向量得到：\\(A^TA\\)的特征向量构成正交矩阵\\(V\\)的列；从\\(A^TA\\)的特征值\\(\\lambda _ { j }\\)的平方根得到奇异值$_ { i } \\(,即\\)\\(\\sigma _ { j } = \\sqrt { \\lambda _ { j } } , \\quad j = 1,2 , \\cdots , n\\)$ 对其由大到小排列，作为对角线元素，构成对角矩阵\\(\\Sigma\\);求正奇异值对应的左奇异向量，再求扩充的\\(A^T\\)的标准正交基，构成正交矩阵\\(U\\)的列。 7.矩阵\\(A = [ a _ { i j } ] _ { m \\times n }\\)的弗罗贝尼乌斯范数定义为\\[\\| A \\| _ { F } = ( \\sum _ { i = 1 } ^ { m } \\sum _ { j = 1 } ^ { n } ( a _ { i j } ) ^ { 2 } ) ^ { \\frac { 1 } { 2 } }\\]在秩不超过\\(k\\)的\\(m \\times n\\)矩阵的集合中，存在矩阵\\(A\\)的弗罗贝尼乌斯范数意义下的最优近似矩阵\\(X\\)。秩为\\(k\\)的截断奇异值分解得到的矩阵\\(A_k\\)能够达到这个最优值。奇异值分解是弗罗贝尼乌斯范数意义下，也就是平方损失意义下的矩阵最优近似。 8.任意一个实矩阵\\(A\\)可以由其外积展开式表示\\[A = \\sigma _ { 1 } u _ { 1 } v _ { 1 } ^ { T } + \\sigma _ { 2 } u _ { 2 } v _ { 2 } ^ { T } + \\cdots + \\sigma _ { n } u _ { n } v _ { n } ^ { T }\\] 其中\\(u _ { k } v _ { k } ^ { T }\\)为\\(m \\times n\\)矩阵，是列向量\\(u _ { k }\\)和行向量\\(v _ { k } ^ { T }\\)的外积，\\(\\sigma _ { k }\\)为奇异值，\\(u _ { k } , v _ { k } ^ { T } , \\sigma _ { k }\\)通过矩阵\\(A\\)的奇异值分解得到。 任意一个\\(m\\) x \\(n\\) 矩阵，都可以表示为三个矩阵的乘积（因子分解）形式，分别是\\(m\\)阶正交矩阵，由降序排列的非负的对角线元素组成的\\(m\\) x \\(n\\) 矩形对角矩阵，和\\(n\\)阶正交矩阵，称为该矩阵的奇异值分解。矩阵的奇异值分解一定存在，但不唯一。 奇异值分解可以看作是矩阵数据压缩的一种方法，即用因子分解的方式近似地表示原始矩阵，这种近似是在平方损失意义下的最优近似。 矩阵的奇异值分解是指，将一个非零的\\(m\\) x \\(n\\) 实矩阵\\(A, A\\in R^{m\\times n}\\)表示为一下三个实矩阵乘积形式的运算： \\(A = U\\Sigma V^{T}\\), 其中 \\(U\\) 是 \\(m\\) 阶正交矩阵， \\(V\\) 是 \\(n\\) 阶正交矩阵，\\(\\Sigma\\) 是由降序排列的非负的对角线元素组成的\\(m\\) x \\(n\\)矩形对角矩阵。称为\\(A\\) 的奇异值分解。 \\(U\\)的列向量称为左奇异向量， \\(V\\)的列向量称为右奇异向量。 奇异值分解不要求矩阵\\(A\\) 是方阵，事实上矩阵的奇异值分解可以看作方阵的对角化的推广。 紧奇奇异值分解是与原始矩阵等秩的奇异值分解， 截断奇异值分解是比原始矩阵低秩的奇异值分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 实现奇异值分解， 输入一个numpy矩阵，输出 U, sigma, V# https://zhuanlan.zhihu.com/p/54693391import numpy as np#基于矩阵分解的结果，复原矩阵def rebuildMatrix(U, sigma, V): a = np.dot(U, sigma) a = np.dot(a, np.transpose(V)) return a#基于特征值的大小，对特征值以及特征向量进行排序。倒序排列def sortByEigenValue(Eigenvalues, EigenVectors): index = np.argsort(-1 * Eigenvalues) Eigenvalues = Eigenvalues[index] EigenVectors = EigenVectors[:, index] return Eigenvalues, EigenVectors#对一个矩阵进行奇异值分解def SVD(matrixA, NumOfLeft=None): #NumOfLeft是要保留的奇异值的个数，也就是中间那个方阵的宽度 #首先求transpose(A)*A matrixAT_matrixA = np.dot(np.transpose(matrixA), matrixA) #然后求右奇异向量 lambda_V, X_V = np.linalg.eig(matrixAT_matrixA) lambda_V, X_V = sortByEigenValue(lambda_V, X_V) #求奇异值 sigmas = lambda_V sigmas = list(map(lambda x: np.sqrt(x) if x &gt; 0 else 0, sigmas)) #python里很小的数有时候是负数 sigmas = np.array(sigmas) sigmasMatrix = np.diag(sigmas) if NumOfLeft == None: rankOfSigmasMatrix = len(list(filter(lambda x: x &gt; 0, sigmas))) #大于0的特征值的个数 else: rankOfSigmasMatrix = NumOfLeft sigmasMatrix = sigmasMatrix[0:rankOfSigmasMatrix, :] #特征值为0的奇异值就不要了 #计算右奇异向量 X_U = np.zeros( (matrixA.shape[0], rankOfSigmasMatrix)) #初始化一个右奇异向量矩阵，这里直接进行裁剪 for i in range(rankOfSigmasMatrix): X_U[:, i] = np.transpose(np.dot(matrixA, X_V[:, i]) / sigmas[i]) #对右奇异向量和奇异值矩阵进行裁剪 X_V = X_V[:, 0:NumOfLeft] sigmasMatrix = sigmasMatrix[0:rankOfSigmasMatrix, 0:rankOfSigmasMatrix] #print(rebuildMatrix(X_U, sigmasMatrix, X_V)) return X_U, sigmasMatrix, X_V 1234A = np.array([[1, 1, 1, 2, 2], [0, 0, 0, 3, 3], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [2, 2, 2, 0, 0], [5, 5, 5, 0, 0], [1, 1, 1, 0, 0]])A array([[1, 1, 1, 2, 2], [0, 0, 0, 3, 3], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [2, 2, 2, 0, 0], [5, 5, 5, 0, 0], [1, 1, 1, 0, 0]]) 1X_U, sigmasMatrix, X_V = SVD(A, NumOfLeft=3) 1X_U array([[ 1.96602638e-01, -5.12980706e-01, -6.20066911e-09], [ 3.08997616e-02, -8.04794293e-01, 1.69140901e-09], [ 1.02999205e-02, -2.68264764e-01, 5.63803005e-10], [ 1.76002797e-01, 2.35488225e-02, -7.63159275e-09], [ 3.52005594e-01, 4.70976451e-02, -1.52631855e-08], [ 8.80013984e-01, 1.17744113e-01, -3.81579637e-08], [ 1.76002797e-01, 2.35488225e-02, -7.63159275e-09]]) 1sigmasMatrix array([[9.81586105e+00, 0.00000000e+00, 0.00000000e+00], [0.00000000e+00, 5.25821946e+00, 0.00000000e+00], [0.00000000e+00, 0.00000000e+00, 1.16381789e-07]]) 1X_V array([[ 5.75872999e-01, 4.12749590e-02, 8.16496581e-01], [ 5.75872999e-01, 4.12749590e-02, -4.08248290e-01], [ 5.75872999e-01, 4.12749590e-02, -4.08248290e-01], [ 5.05512944e-02, -7.05297502e-01, 3.28082013e-17], [ 5.05512944e-02, -7.05297502e-01, 3.28082013e-17]]) 123# rebuild from U, sigma, VrebuildMatrix(X_U, sigmasMatrix, X_V) array([[ 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 2.00000000e+00, 2.00000000e+00], [ 5.39915464e-17, 7.72260438e-16, -7.54662738e-16, 3.00000000e+00, 3.00000000e+00], [ 9.57429619e-18, 2.48997260e-16, -2.59977132e-16, 1.00000000e+00, 1.00000000e+00], [ 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.25546281e-17, 1.25546281e-17], [ 2.00000000e+00, 2.00000000e+00, 2.00000000e+00, 2.51092563e-17, 2.51092563e-17], [ 5.00000000e+00, 5.00000000e+00, 5.00000000e+00, 9.74347659e-18, 9.74347659e-18], [ 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.38777878e-17, 1.38777878e-17]]) same as A. 12345678from PIL import Imageimport requestsfrom io import BytesIOurl = 'https://images.mulberry.com/i/mulberrygroup/RL5792_000N651_L/small-hampstead-deep-amber-small-classic-grain-ayers/small-hampstead-deep-amber-small-classic-grain-ayers?v=3&amp;w=304'response = requests.get(url)img = Image.open(BytesIO(response.content))img","link":"/posts/2771.html"},{"title":"主成分分析","text":"1.假设\\(x\\)为\\(m\\) 维随机变量，其均值为\\(\\mu\\)，协方差矩阵为\\(\\Sigma\\)。 考虑由\\(m\\)维随机变量\\(x\\)到\\(m\\)维随机变量\\(y\\)的线性变换 \\[y _ { i } = \\alpha _ { i } ^ { T } x = \\sum _ { k = 1 } ^ { m } \\alpha _ { k i } x _ { k } , \\quad i = 1,2 , \\cdots , m\\] 其中\\(\\alpha _ { i } ^ { T } = ( \\alpha _ { 1 i } , \\alpha _ { 2 i } , \\cdots , \\alpha _ { m i } )\\)。 如果该线性变换满足以下条件，则称之为总体主成分： （1）\\(\\alpha _ { i } ^ { T } \\alpha _ { i } = 1 , i = 1,2 , \\cdots , m\\)； （2）\\(\\operatorname { cov } ( y _ { i } , y _ { j } ) = 0 ( i \\neq j )\\); （3）变量\\(y_1\\)是\\(x\\)的所有线性变换中方差最大的；\\(y_2\\)是与\\(y_1\\)不相关的\\(x\\)的所有线性变换中方差最大的；一般地，\\(y_i\\)是与\\(y _ { 1 } , y _ { 2 } , \\cdots , y _ { i - 1 } , ( i = 1,2 , \\cdots , m )\\)都不相关的\\(x\\)的所有线性变换中方差最大的；这时分别称\\(y _ { 1 } , y _ { 2 } , \\cdots , y _ { m }\\)为\\(x\\)的第一主成分、第二主成分、…、第\\(m\\)主成分。 2.假设\\(x\\)是\\(m\\)维随机变量，其协方差矩阵是\\(\\Sigma\\)，\\(\\Sigma\\)的特征值分别是\\(\\lambda _ { 1 } \\geq\\lambda _ { 2 } \\geq \\cdots \\geq \\lambda _ { m } \\geq 0\\)，特征值对应的单位特征向量分别是\\(\\alpha _ { 1 } , \\alpha _ { 2 } , \\cdots , \\alpha _ { m }\\)，则\\(x\\)的第2主成分可以写作 \\[y _ { i } = \\alpha _ { i } ^ { T } x = \\sum _ { k = 1 } ^ { m } \\alpha _ { k i } x _ { k } , \\quad i = 1,2 , \\cdots , m\\] 并且，\\(x\\)的第\\(i\\)主成分的方差是协方差矩阵\\(\\Sigma\\)的第\\(i\\)个特征值，即\\[\\operatorname { var } ( y _ { i } ) = \\alpha _ { i } ^ { T } \\Sigma \\alpha _ { i } = \\lambda _ { i }\\] 3.主成分有以下性质： 主成分\\(y\\)的协方差矩阵是对角矩阵\\[\\operatorname { cov } ( y ) = \\Lambda = \\operatorname { diag } ( \\lambda _ { 1 } , \\lambda _ { 2 } , \\cdots , \\lambda _ { m } )\\] 主成分\\(y\\)的方差之和等于随机变量\\(x\\)的方差之和 \\[\\sum _ { i = 1 } ^ { m } \\lambda _ { i } = \\sum _ { i = 1 } ^ { m } \\sigma _ { i i }\\] 其中\\(\\sigma _ { i i }\\)是\\(x_2\\)的方差，即协方差矩阵\\(\\Sigma\\)的对角线元素。 主成分\\(y_k\\)与变量\\(x_2\\)的相关系数\\(\\rho ( y _ { k } , x _ { i } )\\)称为因子负荷量（factor loading），它表示第\\(k\\)个主成分\\(y_k\\)与变量\\(x\\)的相关关系，即\\(y_k\\)对\\(x\\)的贡献程度。 \\[\\rho ( y _ { k } , x _ { i } ) = \\frac { \\sqrt { \\lambda _ { k } } \\alpha _ { i k } } { \\sqrt { \\sigma _ { i i } } } , \\quad k , i = 1,2 , \\cdots , m\\] 4.样本主成分分析就是基于样本协方差矩阵的主成分分析。 给定样本矩阵 \\[X = \\left[ \\begin{array} { l l l l } { x _ { 1 } } &amp; { x _ { 2 } } &amp; { \\cdots } &amp; { x _ { n } } \\end{array} \\right] = \\left[ \\begin{array} { c c c c } { x _ { 11 } } &amp; { x _ { 12 } } &amp; { \\cdots } &amp; { x _ { 1 n } } \\\\ { x _ { 21 } } &amp; { x _ { 22 } } &amp; { \\cdots } &amp; { x _ { 2 n } } \\\\ { \\vdots } &amp; { \\vdots } &amp; { } &amp; { \\vdots } \\\\ { x _ { m 1 } } &amp; { x _ { m 2 } } &amp; { \\cdots } &amp; { x _ { m n } } \\end{array} \\right]\\] 其中\\(x _ { j } = ( x _ { 1 j } , x _ { 2 j } , \\cdots , x _ { m j } ) ^ { T }\\)是\\(x\\)的第\\(j\\)个独立观测样本，\\(j=1,2，…,n\\)。 \\(X\\)的样本协方差矩阵 \\[\\left. \\begin{array} { c } { S = [ s _ { i j } ] _ { m \\times m } , \\quad s _ { i j } = \\frac { 1 } { n - 1 } \\sum _ { k = 1 } ^ { n } ( x _ { i k } - \\overline { x } _ { i } ) ( x _ { j k } - \\overline { x } _ { j } ) } \\\\ { i = 1,2 , \\cdots , m , \\quad j = 1,2 , \\cdots , m } \\end{array} \\right.\\] 给定样本数据矩阵\\(X\\)，考虑向量\\(x\\)到\\(y\\)的线性变换\\[y = A ^ { T } x\\] 这里 \\[A = \\left[ \\begin{array} { l l l l } { a _ { 1 } } &amp; { a _ { 2 } } &amp; { \\cdots } &amp; { a _ { m } } \\end{array} \\right] = \\left[ \\begin{array} { c c c c } { a _ { 11 } } &amp; { a _ { 12 } } &amp; { \\cdots } &amp; { a _ { 1 m } } \\\\ { a _ { 21 } } &amp; { a _ { 22 } } &amp; { \\cdots } &amp; { a _ { 2 m } } \\\\ { \\vdots } &amp; { \\vdots } &amp; { } &amp; { \\vdots } \\\\ { a _ { m 1 } } &amp; { a _ { m 2 } } &amp; { \\cdots } &amp; { a _ { m m } } \\end{array} \\right]\\] 如果该线性变换满足以下条件，则称之为样本主成分。样本第一主成分\\(y _ { 1 } = a _ { 1 } ^ { T } x\\)是在\\(a _ { 1 } ^ { T } a _ { 1 } = 1\\)条件下，使得\\(a _ { 1 } ^ { T } x _ { j } ( j = 1,2 , \\cdots , n )\\)的样本方差\\(a _ { 1 } ^ { T } S a _ { 1 }\\)最大的\\(x\\)的线性变换； 样本第二主成分\\(y _ { 2 } = a _ { 2 } ^ { T } x\\)是在\\(a _ { 2 } ^ { T } a _ { 2 } = 1\\)和\\(a _ { 2 } ^ { T } x _ { j }\\)与\\(a _ { 1 } ^ { T } x _ { j } ( j = 1,2 , \\cdots , n )\\)的样本协方差\\(a _ { 1 } ^ { T } S a _ { 2 } = 0\\)条件下，使得\\(a _ { 2 } ^ { T } x _ { j } ( j = 1,2 , \\cdots , n )\\)的样本方差\\(a _ { 2 } ^ { T } S a _ { 2 }\\)最大的\\(x\\)的线性变换； 一般地，样本第\\(i\\)主成分\\(y _ { i } = a _ { i } ^ { T } x\\)是在\\(a _ { i } ^ { T } a _ { i } = 1\\)和\\(a _ { i } ^ { T } x _ { j }\\)与\\(a _ { k } ^ { T } x _ { j } ( k &lt; i , j = 1,2 , \\cdots , n )\\)的样本协方差\\(a _ { k } ^ { T } S a _ { i } = 0\\)条件下，使得\\(a _ { i } ^ { T } x _ { j } ( j = 1,2 , \\cdots , n )\\)的样本方差\\(a _ { k } ^ { T } S a _ { i }\\)最大的\\(x\\)的线性变换。 5.主成分分析方法主要有两种，可以通过相关矩阵的特征值分解或样本矩阵的奇异值分解进行。 （1）相关矩阵的特征值分解算法。针对\\(m \\times n\\)样本矩阵\\(X\\)，求样本相关矩阵 \\[R = \\frac { 1 } { n - 1 } X X ^ { T }\\] 再求样本相关矩阵的\\(k\\)个特征值和对应的单位特征向量，构造正交矩阵 \\[V = ( v _ { 1 } , v _ { 2 } , \\cdots , v _ { k } )\\] \\(V\\)的每一列对应一个主成分，得到\\(k \\times n\\)样本主成分矩阵 \\[Y = V ^ { T } X\\] （2）矩阵\\(X\\)的奇异值分解算法。针对\\(m \\times n\\)样本矩阵\\(X\\) \\[X ^ { \\prime } = \\frac { 1 } { \\sqrt { n - 1 } } X ^ { T }\\] 对矩阵\\(X ^ { \\prime }\\)进行截断奇异值分解，保留\\(k\\)个奇异值、奇异向量，得到 \\[X ^ { \\prime } = U S V ^ { T }\\] \\(V\\)的每一列对应一个主成分，得到\\(k \\times n\\)样本主成分矩阵\\(Y\\) \\[Y = V ^ { T } X\\] 本章代码直接使用Coursera机器学习课程的第六个编程练习。 PCA（principal components analysis）即主成分分析技术旨在利用降维的思想，把多指标转化为少数几个综合指标。 12345import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sbfrom scipy.io import loadmat 12data = loadmat('data/ex7data1.mat')# data 12345X = data['X']fig, ax = plt.subplots(figsize=(12,8))ax.scatter(X[:, 0], X[:, 1])plt.show() PCA的算法相当简单。 在确保数据被归一化之后，输出仅仅是原始数据的协方差矩阵的奇异值分解。 123456789101112def pca(X): # normalize the features X = (X - X.mean()) / X.std() # compute the covariance matrix X = np.matrix(X) cov = (X.T * X) / X.shape[0] # perform SVD U, S, V = np.linalg.svd(cov) return U, S, V 12U, S, V = pca(X)U, S, V (matrix([[-0.79241747, -0.60997914], [-0.60997914, 0.79241747]]), array([1.43584536, 0.56415464]), matrix([[-0.79241747, -0.60997914], [-0.60997914, 0.79241747]])) 现在我们有主成分（矩阵U），我们可以用这些来将原始数据投影到一个较低维的空间中。 对于这个任务，我们将实现一个计算投影并且仅选择顶部K个分量的函数，有效地减少了维数。 123def project_data(X, U, k): U_reduced = U[:,:k] return np.dot(X, U_reduced) 12Z = project_data(X, U, 1)Z matrix([[-4.74689738], [-7.15889408], [-4.79563345], [-4.45754509], [-4.80263579], [-7.04081342], [-4.97025076], [-8.75934561], [-6.2232703 ], [-7.04497331], [-6.91702866], [-6.79543508], [-6.3438312 ], [-6.99891495], [-4.54558119], [-8.31574426], [-7.16920841], [-5.08083842], [-8.54077427], [-6.94102769], [-8.5978815 ], [-5.76620067], [-8.2020797 ], [-6.23890078], [-4.37943868], [-5.56947441], [-7.53865023], [-7.70645413], [-5.17158343], [-6.19268884], [-6.24385246], [-8.02715303], [-4.81235176], [-7.07993347], [-5.45953289], [-7.60014707], [-4.39612191], [-7.82288033], [-3.40498213], [-6.54290343], [-7.17879573], [-5.22572421], [-4.83081168], [-7.23907851], [-4.36164051], [-6.44590096], [-2.69118076], [-4.61386195], [-5.88236227], [-7.76732508]]) 我们也可以通过反向转换步骤来恢复原始数据。 123def recover_data(Z, U, k): U_reduced = U[:,:k] return np.dot(Z, U_reduced.T) 12X_recovered = recover_data(Z, U, 1)X_recovered matrix([[3.76152442, 2.89550838], [5.67283275, 4.36677606], [3.80014373, 2.92523637], [3.53223661, 2.71900952], [3.80569251, 2.92950765], [5.57926356, 4.29474931], [3.93851354, 3.03174929], [6.94105849, 5.3430181 ], [4.93142811, 3.79606507], [5.58255993, 4.29728676], [5.48117436, 4.21924319], [5.38482148, 4.14507365], [5.02696267, 3.8696047 ], [5.54606249, 4.26919213], [3.60199795, 2.77270971], [6.58954104, 5.07243054], [5.681006 , 4.37306758], [4.02614513, 3.09920545], [6.76785875, 5.20969415], [5.50019161, 4.2338821 ], [6.81311151, 5.24452836], [4.56923815, 3.51726213], [6.49947125, 5.00309752], [4.94381398, 3.80559934], [3.47034372, 2.67136624], [4.41334883, 3.39726321], [5.97375815, 4.59841938], [6.10672889, 4.70077626], [4.09805306, 3.15455801], [4.90719483, 3.77741101], [4.94773778, 3.80861976], [6.36085631, 4.8963959 ], [3.81339161, 2.93543419], [5.61026298, 4.31861173], [4.32622924, 3.33020118], [6.02248932, 4.63593118], [3.48356381, 2.68154267], [6.19898705, 4.77179382], [2.69816733, 2.07696807], [5.18471099, 3.99103461], [5.68860316, 4.37891565], [4.14095516, 3.18758276], [3.82801958, 2.94669436], [5.73637229, 4.41568689], [3.45624014, 2.66050973], [5.10784454, 3.93186513], [2.13253865, 1.64156413], [3.65610482, 2.81435955], [4.66128664, 3.58811828], [6.1549641 , 4.73790627]]) 123fig, ax = plt.subplots(figsize=(12,8))ax.scatter(list(X_recovered[:, 0]), list(X_recovered[:, 1]))plt.show() 请注意，第一主成分的投影轴基本上是数据集中的对角线。 当我们将数据减少到一个维度时，我们失去了该对角线周围的变化，所以在我们的再现中，一切都沿着该对角线。","link":"/posts/25529.html"},{"title":"概率潜在语义分析","text":"1.概率潜在语义分析是利用概率生成模型对文本集合进行话题分析的方法。概率潜在语义分析受潜在语义分析的启发提出两者可以通过矩阵分解关联起来。 给定一个文本集合，通过概率潜在语义分析，可以得到各个文本生成话题的条件概率分布，以及各个话题生成单词的条件概率分布。 概率潜在语义分析的模型有生成模型，以及等价的共现模型。其学习策略是观测数据的极大似然估计，其学习算法是EM算法。 2.生成模型表示文本生成话题，话题生成单词从而得到单词文本共现数据的过程；假设每个文本由一个话题分布决定，每个话题由一个单词分布决定。单词变量\\(w\\)与文本变量\\(d\\)是观测变量话题变量\\(z\\)是隐变量。生成模型的定义如下： \\[P ( T ) = \\prod _ { ( w , d ) } P ( w , d ) ^ { n ( w , d ) }\\] \\[P ( w , d ) = P ( d ) P ( w | d ) = P ( d ) \\sum _ { \\alpha } P ( z | d ) P ( w | z )\\] 3.共现模型描述文本单词共现数据拥有的模式。共现模型的定义如下： \\[P ( T ) = \\prod _ { ( w , d ) } P ( w , d ) ^ { n ( w , d ) }\\] \\[P ( w , d ) = \\sum _ { z \\in Z } P ( z ) P ( w | z ) P ( d | z )\\] 4.概率潜在语义分析的模型的参数个数是\\(O ( M \\cdot K + N \\cdot K )\\)。现实中\\(K \\ll M\\)，所以概率潜在语义分析通过话题对数据进行了更简洁地表示，实现了数据压缩。 5.模型中的概率分布\\(P ( w | d )\\)可以由参数空间中的单纯形表示。\\(M\\)维参数空间中，单词单纯形表示所有可能的文本的分布，在其中的话题单纯形表示在\\(K\\)个话题定义下的所有可能的文本的分布。话题单纯形是单词单纯形的子集，表示潜在语义空间。 6.概率潜在语义分析的学习通常采用EM算法通过迭代学习模型的参数，\\(P ( w | z )\\) 和\\(P ( z| d )\\)，而\\(P（d）\\)可直接统计得出。 概率潜在语义分析（probabilistic latent semantic analysis, PLSA）,也称概率潜在语义索引（probabilistic latent semantic indexing, PLSI）,是一种利用概率生成模型对文本集合进行话题分析的无监督学习方法。 模型最大特点是用隐变量表示话题，整个模型表示文本生成话题，话题生成单词，从而得到单词-文本共现数据的过程；假设每个文本由一个话题分布决定，每个话题由一个单词分布决定。 18.1.2 生成模型 假设有单词集合 $W = $ {\\(w_{1}, w_{2}, ..., w_{M}\\)}， 其中M是单词个数；文本（指标）集合$D = $ {\\(d_{1}, d_{2}, ..., d_{N}\\)}, 其中N是文本个数；话题集合$Z = $ {\\(z_{1}, z_{2}, ..., z_{K}\\)}，其中\\(K\\)是预先设定的话题个数。随机变量 \\(w\\) 取值于单词集合；随机变量 \\(d\\) 取值于文本集合，随机变量 \\(z\\) 取值于话题集合。概率分布 \\(P(d)\\)、条件概率分布 \\(P(z|d)\\)、条件概率分布 \\(P(w|z)\\) 皆属于多项分布，其中 \\(P(d)\\) 表示生成文本 \\(d\\) 的概率，\\(P(z|d)\\) 表示文本 \\(d\\) 生成话题 \\(z\\) 的概率，\\(P(w|z)\\) 表示话题 \\(z\\) 生成单词 \\(w\\) 的概率。 每个文本 \\(d\\) 拥有自己的话题概率分布 \\(P(z|d)\\)，每个话题 \\(z\\) 拥有自己的单词概率分布 \\(P(w|z)\\)；也就是说一个文本的内容由其相关话题决定，一个话题的内容由其相关单词决定。 生成模型通过以下步骤生成文本·单词共现数据： （1）依据概率分布 \\(P(d)\\)，从文本（指标）集合中随机选取一个文本 \\(d\\) , 共生成 \\(N\\) 个文本；针对每个文本，执行以下操作； （2）在文本\\(d\\) 给定条件下，依据条件概率分布 \\(P(z|d)\\), 从话题集合随机选取一个话题 \\(z\\), 共生成 \\(L\\) 个话题，这里 \\(L\\) 是文本长度； （3）在话题 \\(z\\) 给定条件下，依据条件概率分布 \\(P(w|z)\\) , 从单词集合中随机选取一个单词 \\(w\\). 注意这里为叙述方便，假设文本都是等长的，现实中不需要这个假设。 生成模型中， 单词变量 \\(w\\) 与文本变量 \\(d\\) 是观测变量， 话题变量 \\(z\\) 是隐变量， 也就是说模型生成的是单词-话题-文本三元组合 (\\(w, z ,d\\))的集合， 但观测到的单词-文本二元组 （\\(w, d\\)）的集合， 观测数据表示为单词-文本矩阵 \\(T\\)的形式，矩阵 \\(T\\) 的行表示单词，列表示文本， 元素表示单词-文本对（\\(w, d\\)）的出现次数。 从数据的生成过程可以推出，文本-单词共现数据\\(T\\)的生成概率为所有单词-文本对(\\(w,d\\))的生成概率的乘积： \\(P(T) = \\prod_{w,d}P(w,d)^{n(w,d)}\\) 这里 \\(n(w,d)\\) 表示 (\\(w,d\\))的出现次数，单词-文本对出现的总次数是 \\(N*L\\)。 每个单词-文本对（\\(w,d\\)）的生成概率由一下公式决定： \\(P(w,d) = P(d)P(w|d)\\) \\(= P(d)\\sum_{z}P(w,z|d)\\) \\(=P(d)\\sum_{z}P(z|d)P(w|z)\\) 18.1.3 共现模型 \\(P(w,d) = \\sum_{z\\in Z}P(z)P(w|z)P(d|z)\\) 虽然生成模型与共现模型在概率公式意义上是等价的，但是拥有不同的性质。生成模型刻画文本-单词共现数据生成的过程，共现模型描述文本-单词共现数据拥有的模式。 如果直接定义单词与文本的共现概率 \\(P(w,d)\\), 模型参数的个数是 \\(O(M*N)\\), 其中 \\(M\\) 是单词数， \\(N\\) 是文本数。 概率潜在语义分析的生成模型和共现模型的参数个数是 \\(O(M*K + N*K)\\), 其中 \\(K\\) 是话题数。 现实中 \\(K&lt;&lt;M\\), 所以概率潜在语义分析通过话题对数据进行了更简洁的表示，减少了学习过程中过拟合的可能性。 算法 18.1 （概率潜在语义模型参数估计的EM算法） 输入： 设单词集合为 $W = \\({\\)w_{1}, w_{2},..., w_{M}$}, 文本集合为 \\(D=\\){\\(d_{1}, d_{2},..., d_{N}\\)}, 话题集合为 \\(Z=\\){\\(z_{1}, z_{2},..., z_{K}\\)}, 共现数据 \\(\\left \\{ n(w_{i}, d_{j}) \\right \\}, i = 1,2,..., M, j = 1,2,...,N;\\) 输出： \\(P(w_{i}|z_{k})\\) 和 \\(P(z_{k}|d_{j})\\). 设置参数 \\(P(w_{i}|z_{k})\\) 和 \\(P(z_{k}|d_{j})\\) 的初始值。 迭代执行以下E步，M步，直到收敛为止。 E步： \\(P(z_{k}|w_{i},d_{j})=\\frac{P(w_{i}|z_{k})P(z_{k}|d_{j})}{\\sum_{k=1}^{K}P(w_{i}|z_{k})P(z_{k}|d_{j})}\\) M步： \\(P(w_{i}|z_{k})=\\frac{\\sum_{j=1}^{N}n(w_{i},d_{j})P(z_{k}|w_{i},d_{j})}{\\sum_{m=1}^{M}\\sum_{j=1}^{N}n(w_{m},d_{j})P(z_{k}|w_{m},d_{j})}\\) $P(z_{k}|d_{j}) = \\frac{\\sum_{i=1}^{M}n(w_{i},d_{j})P(z_{k}|w_{i},d_{j})}{n(d_{j})}$ 习题 18.3 1import numpy as np 123456789101112X = [[0,0,1,1,0,0,0,0,0], [0,0,0,0,0,1,0,0,1], [0,1,0,0,0,0,0,1,0], [0,0,0,0,0,0,1,0,1], [1,0,0,0,0,1,0,0,0], [1,1,1,1,1,1,1,1,1], [1,0,1,0,0,0,0,0,0], [0,0,0,0,0,0,1,0,1], [0,0,0,0,0,2,0,0,1], [1,0,1,0,0,0,0,1,0], [0,0,0,1,1,0,0,0,0]]X = np.asarray(X);X array([[0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 2, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0]]) 1X.shape (11, 9) 1X = X.T;X array([[0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 1, 1, 0, 0, 2, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0]]) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class PLSA: def __init__(self, K, max_iter): self.K = K self.max_iter = max_iter def fit(self, X): n_d, n_w = X.shape # P(z|w,d) p_z_dw = np.zeros((n_d, n_w, self.K)) # P(z|d) p_z_d = np.random.rand(n_d, self.K) # P(w|z) p_w_z = np.random.rand(self.K, n_w) for i_iter in range(self.max_iter): # E step for di in range(n_d): for wi in range(n_w): sum_zk = np.zeros((self.K)) for zi in range(self.K): sum_zk[zi] = p_z_d[di, zi] * p_w_z[zi, wi] sum1 = np.sum(sum_zk) if sum1 == 0: sum1 = 1 for zi in range(self.K): p_z_dw[di, wi, zi] = sum_zk[zi] / sum1 # M step # update P(z|d) for di in range(n_d): for zi in range(self.K): sum1 = 0. sum2 = 0. for wi in range(n_w): sum1 = sum1 + X[di, wi] * p_z_dw[di, wi, zi] sum2 = sum2 + X[di, wi] if sum2 == 0: sum2 = 1 p_z_d[di, zi] = sum1 / sum2 # update P(w|z) for zi in range(self.K): sum2 = np.zeros((n_w)) for wi in range(n_w): for di in range(n_d): sum2[wi] = sum2[wi] + X[di, wi] * p_z_dw[di, wi, zi] sum1 = np.sum(sum2) if sum1 == 0: sum1 = 1 for wi in range(n_w): p_w_z[zi, wi] = sum2[wi] / sum1 return p_w_z, p_z_d# https://github.com/lipiji/PG_PLSA/blob/master/plsa.py 12model = PLSA(2, 100)p_w_z, p_z_d = model.fit(X) 1p_w_z array([[0.64238757, 0.05486094, 0.18905573, 0.24047994, 0.41230822, 0.38136674, 0.81525232, 0.74314243, 0.32465342, 0.19798429, 0.72010476], [0.6337431 , 0.79442181, 0.96755364, 0.22924392, 0.99367301, 0.20277986, 0.40513752, 0.51164374, 0.73750246, 0.22300907, 0.17339099]]) 1p_z_d array([[7.14884177e-01, 2.85115823e-01], [5.38307075e-02, 9.46169293e-01], [1.00000000e+00, 3.40624611e-11], [1.00000000e+00, 1.12459358e-24], [1.00000000e+00, 5.00831891e-42], [1.66511004e-19, 1.00000000e+00], [1.00000000e+00, 8.02144289e-15], [1.04149223e-02, 9.89585078e-01], [5.96793031e-03, 9.94032070e-01]])","link":"/posts/29662.html"},{"title":"马尔可夫链蒙特卡罗法","text":"蒙特卡罗法是通过基于概率模型的抽样进行数值近似计算的方法，蒙特卡罗法可以用于概率分布的抽样、概率分布数学期望的估计、定积分的近似计算。 随机抽样是蒙特卡罗法的一种应用，有直接抽样法、接受拒绝抽样法等。接受拒绝法的基本想法是，找一个容易抽样的建议分布，其密度函数的数倍大于等于想要抽样的概率分布的密度函数。按照建议分布随机抽样得到样本，再按要抽样的概率分布与建议分布的倍数的比例随机决定接受或拒绝该样本，循环执行以上过程。 马尔可夫链蒙特卡罗法数学期望估计是蒙特卡罗法的另一种应用，按照概率分布\\(p(x)\\)抽取随机变量\\(x\\)的\\(n\\)个独立样本，根据大数定律可知，当样本容量增大时，函数的样本均值以概率1收敛于函数的数学期望 \\[\\hat { f } _ { n } \\rightarrow E _ { p ( x ) } [ {f ( x )} ] , \\quad n \\rightarrow \\infty\\] 计算样本均值$ _ { n } \\(，作为数学期望\\)E _ { p ( x ) } [ {f ( x )} ] $的估计值。 马尔可夫链是具有马尔可夫性的随机过程\\[P ( X _ { t } | X _ { 0 } X _ { 1 } \\cdots X _ { t - 1 } ) = P ( X _ { t } | X _ { t - 1 } ) , \\quad t = 1,2 , \\cdots\\] 通常考虑时间齐次马尔可夫链。有离散状态马尔可夫链和连续状态马尔可夫链，分别由概率转移矩阵\\(P\\)和概率转移核\\(p(x,y)\\)定义。 满足\\(\\pi = P \\pi\\)或\\(\\pi ( y ) = \\int p ( x , y ) \\pi ( x ) d x\\)的状态分布称为马尔可夫链的平稳分布。 马尔可夫链有不可约性、非周期性、正常返等性质。一个马尔可夫链若是不可约、非周期、正常返的，则该马尔可夫链满足遍历定理。当时间趋于无穷时，马尔可夫链的状态分布趋近于平稳分布，函数的样本平均依概率收敛于该函数的数学期望。 \\[\\operatorname { lim } _ { t \\rightarrow \\infty } P ( X _ { t } = i | X _ { 0 } = j ) = \\pi _ { i } , \\quad i = 1,2 , \\cdots ; \\quad j = 1,2\\] \\[\\hat { f } _ { t } \\rightarrow E _ { \\pi } [ {f ( X )} ] , \\quad t \\rightarrow \\infty\\] 可逆马尔可夫链是满足遍历定理的充分条件。 马尔可夫链蒙特卡罗法是以马尔可夫链为概率模型的蒙特卡罗积分方法，其基本想法如下： （1）在随机变量\\(x\\)的状态空间\\(\\chi\\)上构造一个满足遍历定理条件的马尔可夫链，其平稳分布为目标分布\\(p(x)\\)； （2）由状态空间的某一点\\(X_0\\)出发，用所构造的马尔可夫链进行随机游走，产生样本序列\\(X _ { 1 } , X _ { 2 } , \\cdots , X _ { t } , \\cdots\\)； （3）应用马尔可夫链遍历定理，确定正整数\\(m\\)和\\(n(m&lt;n)\\)，得到样本集合\\(\\{ x _ { m + 1 } , x _ { m + 2 } , \\cdots , x _ { n } \\}\\)，进行函数\\(f(x)\\)的均值（遍历均值）估计： \\[\\hat { E } f = \\frac { 1 } { n - m } \\sum _ { i = m + 1 } ^ { n } {f ( x _ { i } )}\\] Metropolis-Hastings算法是最基本的马尔可夫链蒙特卡罗法。假设目标是对概率分布\\(p ( x )\\)进行抽样，构造建议分布\\(q ( x , x ^ { \\prime } )\\)，定义接受分布\\(\\alpha ( x , x ^ { \\prime } )\\)进行随机游走，假设当前处于状态\\(x\\)，按照建议分布\\(q ( x , x ^ { \\prime } )\\)机抽样，按照概率\\(\\alpha ( x , x ^ { \\prime } )\\)接受抽样，转移到状态 \\(x ^ { \\prime }\\)，按照概率\\(1- \\alpha ( x , x ^ { \\prime } )\\)拒绝抽样，停留在状态\\(x\\)，持续以上操作，得到一系列样本。这样的随机游走是根据转移核为\\(p ( x , x ^ { \\prime } ) = q ( x , x ^ { \\prime } ) \\alpha ( x , x ^ { \\prime } )\\)的可逆马尔可夫链（满足遍历定理条件）进行的，其平稳分布就是要抽样的目标分布\\(p ( x )\\)。 吉布斯抽样（Gibbs sampling）用于多元联合分布的抽样和估计吉布斯抽样是单分量 Metropolis-Hastings-算法的特殊情况。这时建议分布为满条件概率分布\\[q ( x , x ^ { \\prime } ) = p ( x _ { j } ^ { \\prime } | x _ { - j } )\\] 吉布斯抽样的基本做法是，从联合分布定义满条件概率分布，依次从满条件概率分布进行抽样，得到联合分布的随机样本。假设多元联合概率分布为\\(p ( x ) = p ( x _ { 1 } , x _ { 2 } , \\cdots , x _ { k } )\\)，吉布斯抽样从一个初始样本\\(x ^ { ( 0 ) } = ( x _ { 1 } ^ { ( 0 ) } , x _ { 2 } ^ { ( 0 ) } , \\cdots , x _ { k } ^ { ( 0 ) } ) ^ { T }\\)出发，不断进行迭代，每一次迭代得到联合分布的一个样本\\(x ^ { ( i ) } = ( x _ { 1 } ^ { ( i ) } , x _ { 2 } ^ { ( i ) } , \\cdots , x _ { k } ^ { ( i ) } ) ^ { T }\\)，在第\\(i\\)次迭代中，依次对第\\(j\\)个变量按照满条件概率分布随机抽样\\(p ( x _ { j } | x _ { 1 } ^ { ( i ) } , \\cdots , x _ { j - 1 } ^ { ( i ) },x _ { j + 1 } ^ { ( i - 1 ) } , \\cdots , x _ { k } ^ { ( i - 1 ) } ) , j = 1,2 , \\cdots , k\\)，得到\\(x _ { j } ^ { ( i ) }\\)最终得到样本序列\\(\\{ x ^ { ( 0 ) } , x ^ { ( 1 ) } , \\cdots , x ^ { ( n ) } \\}\\)。 蒙特卡洛法（Monte Carlo method) ， 也称为统计模拟方法 (statistical simulation method) ， 是通过从概率模型的随机抽样进行近似数值计 算的方法。 马尔可夫链陟特卡罗法 (Markov Chain Monte Carlo, MCMC)， 则是以马尔可夫链 (Markov chain）为概率模型的蒙特卡洛法。 马尔可夫链蒙特卡罗法构建一个马尔可夫链，使其平稳分布就是要进行抽样的分布， 首先基于该马尔可夫链进行随机游走， 产生样本的序列， 之后使用该平稳分布的样本进行近似数值计算。 Metropolis-Hastings算法是最基本的马尔可夫链蒙特卡罗法，Metropolis等人在 1953年提出原始的算法，Hastings在1970年对之加以推广， 形成了现在的形式。吉布斯抽样(Gibbs sampling)是更简单、使用更广泛的马尔可夫链蒙特卡罗法，1984 年由S. Geman和D. Geman提出。 马尔可夫链蒙特卡罗法被应用于概率分布的估计、定积分的近似计算、最优化问题的近似求解等问题，特别是被应用于统计学习中概率模型的学习 与推理，是重要的统计学习计算方法。 一般的蒙特卡罗法有直接抽样法、接受-拒绝抽样法、 重要性抽样法等。 接受-拒绝抽样法、重要性抽样法适合于概率密度函数复杂 （如密度函数含有多个变量，各变量相互不独立，密度函数形式复杂），不能直接抽样的情况。 19.1.2 数学期望估计 一舣的蒙特卡罗法， 如直接抽样法、接受·拒绝抽样法、重要性抽样法， 也可以用于数学期望估计 （estimation Of mathematical expectation)。 假设有随机变量\\(x\\)， 取值 \\(x\\in X\\), 其概率密度函数为 \\(p(x)\\), \\(f(x)\\) 为定义在 \\(X\\) 上的函数， 目标是求函数 \\(f(x)\\) 关于密度函数 \\(p(x)\\) 的数学期望 \\(E_{p(x)}[f(x)]\\)。 针对这个问题，蒙特卡罗法按照概率分布 \\(p(x)\\) 独立地抽取 \\(n\\) 个样本\\(x_{1}, x_{2},...,x_{n}\\)，比如用以上的抽样方法，之后计算函 数\\(f(x)\\)的样本均值\\(\\hat f_{n}\\) \\(\\hat f_{n} = \\frac{1} {n}\\sum_{i=1}^{n}f(x_{i})\\) 作为数学期望\\(E_{p(x)}[f(x)]\\)近似值。 根据大数定律可知， 当样本容量增大时， 样本均值以概率1收敛于数学期望： $f_{n} E_{p(x)}[f(x)], n $ 这样就得到了数学期望的近似计算方法： \\(E_{p(x)}[f(x)] \\approx \\frac{1} {n}\\sum_{i=1}^{n}f(x_{i})\\) 马尔可夫链 考虑一个随机变量的序列 \\(X = {X_{0}, X_{1},..., X(t),...}\\) 这里 \\(X_{t}\\)，表示时刻 \\(t\\) 的随机变量， \\(t = 0, 1, 2...\\). 每个随机变量 \\(X_{t}(t=0,1,2,...)\\) 的取值集合相同， 称为状态空间， 表示为\\(S\\). 随机变量可以是离散的， 也可以是连续的。 以上随机变量的序列构成随机过程（stochastic process)。 假设在时刻 \\(0\\) 的随机变量 \\(X_{0}\\) 遵循概率分布 \\(P(X_{0}) = \\pi\\)，称为初始状态分布。在某个时刻 \\(t&gt;=1\\) 的随机变量 \\(X_{t}\\)与前 一个时刻的随机变量 \\(X_{t-1}\\) 之间有条件分布 \\(P(X_{t}|X_{t-1})\\) 如果 \\(X_{t}\\) 只依赖于 \\(X_{t-1}\\), 而不依赖于过去的随机变量 \\({X_{0}，X_{1},...，X_{t-2}}\\) 这一性质称为马尔可夫性，即 \\(P(X_{t}|X_{0},X_{1},...,X_{t-1}) = P(X_{t}|X_{t-1}), t=1,2,...\\) 具有马尔可夫性的随机序列\\(X = {X_{0}, X_{1},..., X(t),...}\\)称为马尔可夫链， 或马尔可夫过程（Markov process)。 条件概率分布 \\(P(X_{t}|X_{t-1})\\) 称为马尔可夫链的转移概率分布。 转移概率分布决定了马尔可夫裢的特性。 平稳分布 设有马尔可夫链\\(X = {X_{0}, X_{1},..., X(t),...}\\)，其状态空间为 \\(S\\),转移概率矩阵为 \\(P=(p_{ij})\\)， 如果存在状态空间 \\(S\\) 上的一个分布 \\(\\pi = \\begin{bmatrix} \\pi_{1}\\\\ \\pi_{2}\\\\ \\vdots \\end{bmatrix}\\) 使得 \\(\\pi = P\\pi\\) 则称丌为马尔可夫裢\\(X = {X_{0}, X_{1},..., X(t),...}\\)的平稳分布。 直观上，如果马尔可夫链的平稳分布存在，那么以该平稳分布作为初始分布，面向未来进行随机状态转移，之后任何一个时刻的状态分布都是该平稳分布。 引理19．1 给定一个马尔可夫链\\(X = {X_{0}, X_{1},..., X(t),...}\\), 状态空间为\\(S\\), 移概率矩阵为\\(P=(p_{ij})\\)， 则分布 \\(\\pi=(\\pi_{1}, \\pi_{2},...)^{T}\\) 为 \\(X\\) 的平稳分布的充要条件是\\(\\pi=(\\pi_{1}, \\pi_{2},...)^{T}\\)是下列方程组的解： \\(x_{i} = \\sum_{j}p_{ij}x_{j}, i=1,2,...\\) \\(x_{i} &gt;= 0, i = 1,2,...\\) \\(\\sum_{i}x_{i} = 1\\) 吉布斯采样 输入： 目标概率分布的密度函数\\(p(x)\\), 函数\\(f(x)\\); 输出： \\(p(x)\\)的随机样本 \\(x_{m+1}, x_{m+2}, ..., x_{n}\\)，函数样本均值 \\(f_{mn}\\); 参数： 收敛步数\\(m\\), 迭代步数 \\(n\\). 初始化。给出初始样本 $x^{0} = \\((\\)x^{0}_{1}, x{0}{2},..., x^{0}{k}\\()\\){T}$. 对\\(i\\)循环执行 设第\\(i-1\\)次迭代结束前的样本为$x^{i-1} = \\((\\)x^{i-1}_{1}, x{i-1}{2},..., x^{i-1}{k}\\()\\){T}\\(，则第\\)i$次迭代进行如下几步操作： (1)由满条件分布 \\(p(x_{1}|x^{i-1}_{2},...,x^{i-1}_{k})\\) 抽取 \\(x^{i}_{1}\\) ... (j)由满条件分布 \\(p(x_{j}|x^{i}_{1},...,x^{i}_{j-1}, x^{i-1}_{j+1},..., x^{i-1}_{k})\\) 抽取 \\(x^{i}_{j}\\) (k)由满条件分布 \\(p(x_{k}|x^{i}_{1},...,x^{i}_{k})\\) 抽取 \\(x^{i}_{k}\\) 得到第 \\(i\\) 次迭代值 \\(x^{(i)} = (x^{(i)}_{1}, x^{(i)}_{2},..., x^{(i)}_{k})^{T}\\). 得到样本集合 {\\(x^{(m+1)}, x^{(m+2)},..., x^{(n)}\\)} 计算 \\(f_{mn} = \\frac{1}{n-m}\\sum_{i=m+1}^{n}f(x^{(i)})\\) 网络资源： LDA-math-MCMC 和 Gibbs Sampling： https://cosx.org/2013/01/lda-math-mcmc-and-gibbs-sampling MCMC蒙特卡罗方法： https://www.cnblogs.com/pinard/p/6625739.html 12345678910111213141516171819import randomimport mathimport matplotlib.pyplot as pltimport seaborn as snsimport numpy as nptransfer_matrix = np.array([[0.6, 0.2, 0.2], [0.3, 0.4, 0.3], [0, 0.3, 0.7]], dtype='float32')start_matrix = np.array([[0.5, 0.3, 0.2]], dtype='float32')value1 = []value2 = []value3 = []for i in range(30): start_matrix = np.dot(start_matrix, transfer_matrix) value1.append(start_matrix[0][0]) value2.append(start_matrix[0][1]) value3.append(start_matrix[0][2])print(start_matrix) [[0.23076935 0.30769244 0.46153864]] 1234567#进行可视化x = np.arange(30)plt.plot(x,value1,label='cheerful')plt.plot(x,value2,label='so-so')plt.plot(x,value3,label='sad')plt.legend()plt.show() 可以发现，从10轮左右开始，我们的状态概率分布就不变了，一直保持在 [0.23076934,0.30769244,0.4615386] https://zhuanlan.zhihu.com/p/37121528 M-H采样python实现 https://zhuanlan.zhihu.com/p/37121528 假设目标平稳分布是一个均值3，标准差2的正态分布，而选择的马尔可夫链状态转移矩阵 \\(Q(i,j)\\) 的条件转移概率是以 \\(i\\) 为均值,方差1的正态分布在位置 \\(j\\) 的值。 1234567891011121314151617181920212223242526272829303132333435from scipy.stats import normdef norm_dist_prob(theta): y = norm.pdf(theta, loc=3, scale=2) return yT = 5000pi = [0 for i in range(T)]sigma = 1t = 0while t &lt; T - 1: t = t + 1 pi_star = norm.rvs(loc=pi[t - 1], scale=sigma, size=1, random_state=None) #状态转移进行随机抽样 alpha = min( 1, (norm_dist_prob(pi_star[0]) / norm_dist_prob(pi[t - 1]))) #alpha值 u = random.uniform(0, 1) if u &lt; alpha: pi[t] = pi_star[0] else: pi[t] = pi[t - 1]plt.scatter(pi, norm.pdf(pi, loc=3, scale=2), label='Target Distribution')num_bins = 50plt.hist(pi, num_bins, density=1, facecolor='red', alpha=0.7, label='Samples Distribution')plt.legend()plt.show() 二维Gibbs采样实例python实现 假设我们要采样的是一个二维正态分布 \\(N(\\mu, \\Sigma)\\) ，其中： \\(\\mu=(\\mu_{1}, \\mu_{2})= (5, -1)\\) , \\(\\Sigma = \\begin{pmatrix} \\sigma^{2}_{1} &amp; \\rho \\sigma_{1}\\sigma_{2}b\\rho \\sigma_{2}&amp; \\sigma^{2}_{2}\\end{pmatrix} = \\begin{pmatrix} 1&amp; 1b1 &amp; 4\\end{pmatrix}\\); 而采样过程中的需要的状态转移条件分布为： \\(P(x_{1}|x_{2}) = N(\\mu_{1}+ \\rho \\sigma_{1}/\\sigma_{2}(x_{2} - \\mu_{2}), (1 - \\rho^{2})\\sigma^{2}_{1})\\) \\(P(x_{2}|x_{1}) = N(\\mu_{2}+ \\rho \\sigma_{2}/\\sigma_{1}(x_{1} - \\mu_{1}), (1 - \\rho^{2})\\sigma^{2}_{2})\\) 123456789101112131415161718192021222324252627282930313233343536373839from mpl_toolkits.mplot3d import Axes3Dfrom scipy.stats import multivariate_normalsamplesource = multivariate_normal(mean=[5,-1], cov=[[1,0.5],[0.5,2]])def p_ygivenx(x, m1, m2, s1, s2): return (random.normalvariate(m2 + rho * s2 / s1 * (x - m1), math.sqrt(1 - rho ** 2) * s2))def p_xgiveny(y, m1, m2, s1, s2): return (random.normalvariate(m1 + rho * s1 / s2 * (y - m2), math.sqrt(1 - rho ** 2) * s1))N = 5000K = 20x_res = []y_res = []z_res = []m1 = 5m2 = -1s1 = 1s2 = 2rho = 0.5y = m2for i in range(N): for j in range(K): x = p_xgiveny(y, m1, m2, s1, s2) #y给定得到x的采样 y = p_ygivenx(x, m1, m2, s1, s2) #x给定得到y的采样 z = samplesource.pdf([x,y]) x_res.append(x) y_res.append(y) z_res.append(z)num_bins = 50plt.hist(x_res, num_bins,density=1, facecolor='green', alpha=0.5,label='x')plt.hist(y_res, num_bins, density=1, facecolor='red', alpha=0.5,label='y')plt.title('Histogram')plt.legend()plt.show()","link":"/posts/49096.html"},{"title":"潜在狄利克雷分配","text":"1.狄利克雷分布的概率密度函数为\\[p ( \\theta | \\alpha ) = \\frac { \\Gamma ( \\sum _ { i = 1 } ^ { k } \\alpha _ { i } ) } { \\prod _ { i = 1 } ^ { k } \\Gamma ( \\alpha _ { i } ) } \\prod _ { i = 1 } ^ { k } \\theta _ { i } ^ { \\alpha _ { i } - 1 }\\] 其中 \\[\\sum _ { i = 1 } ^ { k } \\theta _ { i } = 1 , \\theta _ { i } \\geq 0 , \\alpha = ( \\alpha _ { 1 } , \\alpha _ { 2 } , \\cdots , \\alpha _ { k } ) , \\alpha _ { i } &gt; 0 , i = 1,2 , \\cdots , \\] 狄利克雷分布是多项分布的共轭先验。 2.潜在狄利克雷分配2.潜在狄利克雷分配（LDA）是文本集合的生成概率模型。模型假设话题由单词的多项分布表示，文本由话题的多项分布表示，单词分布和话题分布的先验分布都是狄利克雷分布。LDA模型属于概率图模型可以由板块表示法表示LDA模型中，每个话题的单词分布、每个文本的话题分布、文本的每个位置的话题是隐变量，文本的每个位置的单词是观测变量。 3.LDA生成文本集合的生成过程如下： （1）话题的单词分布：随机生成所有话题的单词分布，话题的单词分布是多项分布，其先验分布是狄利克雷分布。 （2）文本的话题分布：随机生成所有文本的话题分布，文本的话题分布是多项分布，其先验分布是狄利克雷分布。 （3）文本的内容：随机生成所有文本的内容。在每个文本的每个位置，按照文本的话题分布随机生成一个话题，再按照该话题的单词分布随机生成一个单词。 4.LDA模型的学习与推理不能直接求解。通常采用的方法是吉布斯抽样算法和变分EM算法，前者是蒙特卡罗法而后者是近似算法。 5.LDA的收缩的吉布斯抽样算法的基本想法如下。目标是对联合概率分布\\(p ( w , z , \\theta , \\varphi | \\alpha , \\beta )\\)进行估计。通过积分求和将隐变量\\(\\theta\\)和\\(\\varphi\\)消掉，得到边缘概率分布\\(p ( w , z | \\alpha , \\beta )\\)；对概率分布\\(p ( w | z , \\alpha , \\beta )\\)进行吉布斯抽样，得到分布\\(p ( w | z , \\alpha , \\beta )\\)的随机样本；再利用样本对变量\\(z\\)，\\(\\theta\\)和\\(\\varphi\\)的概率进行估计，最终得到LDA模型\\(p ( w , z , \\theta , \\varphi | \\alpha , \\beta )\\)的参数估计。具体算法如下对给定的文本单词序列，每个位置上随机指派一个话题，整体构成话题系列。然后循环执行以下操作。对整个文本序列进行扫描，在每一个位置上计算在该位置上的话题的满条件概率分布，然后进行随机抽样，得到该位置的新的话题，指派给这个位置。 6.变分推理的基本想法如下。假设模型是联合概率分布\\(p ( x , z )\\)，其中\\(x\\)是观测变量（数据），\\(z\\)是隐变量。目标是学习模型的后验概率分布\\(p ( z | x )\\)。考虑用变分分布\\(q ( z )\\)近似条件概率分布\\(p ( z | x )\\)，用KL散度计算两者的相似性找到与\\(p ( z | x )\\)在KL散度意义下最近的\\(q ^ { * } ( z )\\)，用这个分布近似\\(p ( z | x )\\)。假设\\(q ( z )\\)中的\\(z\\)的所有分量都是互相独立的。利用Jensen不等式，得到KL散度的最小化可以通过证据下界的最大化实现。因此，变分推理变成求解以下证据下界最大化问题： \\[L ( q , \\theta ) = E _ { q } [ \\operatorname { log } p ( x , z | \\theta ) ] - E _ { q } [ \\operatorname { log } q ( z ) ]\\] 7.LDA的变分EM算法如下。针对LDA模型定义变分分布，应用变分EM算法。目标是对证据下界\\(L ( \\gamma , \\eta , \\alpha , \\varphi )\\)进行最大化，其中\\(\\alpha\\)和\\(\\varphi\\)是模型参数，\\(\\gamma\\)和\\(\\eta\\)是变分参数。交替迭代E步和M步，直到收敛。 （1）E步：固定模型参数\\(\\alpha\\)，\\(\\varphi\\)，通过关于变分参数\\(\\gamma\\)，\\(\\eta\\)的证据下界的最大化，估计变分参数\\(\\gamma\\)，\\(\\eta\\)。 （2）M步：固定变分参数\\(\\gamma\\)，\\(\\eta\\)，通过关于模型参数\\(\\alpha\\)，\\(\\varphi\\)的证据下界的最大化，估计模型参数\\(\\alpha\\)，\\(\\varphi\\)。 潜在狄利克雷分配（latent Dirichlet allocation,LDA），作为基于贝叶斯学习的话题模型，是潜在语义分析、概率潜在语义分析的扩展，于2002年由Blei等提出dA在文本数据挖掘、图像处理、生物信息处理等领域被广泛使用。 LDA模型是文本集合的生成概率模型假设每个文本由话题的一个多项分布表示，每个话题由单词的一个多项分布表示，特别假设文本的话题分布的先验分布是狄利克雷分布，话题的单词分布的先验分布也是狄利克雷分布。先验分布的导入使LDA能够更好地应对话题模型学习中的过拟合现象。 LDA的文本集合的生成过程如下：首先随机生成一个文本的话题分布，之后在该文本的每个位置，依据该文本的话题分布随机生成一个话题，然后在该位置依据该话题的单词分布随机生成一个单词，直至文本的最后一个位置，生成整个文本。重复以上过程生成所有文本。 LDA模型是含有隐变量的概率图模型。模型中，每个话题的单词分布，每个文本的话题分布，文本的每个位置的话题是隐变量；文本的每个位置的单词是观测变量。LDA模型的学习与推理无法直接求解通常使用吉布斯抽样（ Gibbs sampling）和变分EM算法（variational EM algorithm），前者是蒙特卡罗法，而后者是近似算法。 123from gensim import corpora, models, similaritiesfrom pprint import pprintimport warnings 123456f = open('data/LDA_test.txt')stop_list = set('for a of the and to in'.split())# texts = [line.strip().split() for line in f]# print 'Before'# pprint(texts)print('After') After 12345texts = [[ word for word in line.strip().lower().split() if word not in stop_list] for line in f]print('Text = ')pprint(texts) Text = [['human', 'machine', 'interface', 'lab', 'abc', 'computer', 'applications'], ['survey', 'user', 'opinion', 'computer', 'system', 'response', 'time'], ['eps', 'user', 'interface', 'management', 'system'], ['system', 'human', 'system', 'engineering', 'testing', 'eps'], ['relation', 'user', 'perceived', 'response', 'time', 'error', 'measurement'], ['generation', 'random', 'binary', 'unordered', 'trees'], ['intersection', 'graph', 'paths', 'trees'], ['graph', 'minors', 'iv', 'widths', 'trees', 'well', 'quasi', 'ordering'], ['graph', 'minors', 'survey']] 12dictionary = corpora.Dictionary(texts)print(dictionary) Dictionary(35 unique tokens: ['abc', 'applications', 'computer', 'human', 'interface']...) 12345678V = len(dictionary)corpus = [dictionary.doc2bow(text) for text in texts]corpus_tfidf = models.TfidfModel(corpus)[corpus]corpus_tfidf = corpusprint('TF-IDF:')for c in corpus_tfidf: print(c) TF-IDF: [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)] [(2, 1), (7, 1), (8, 1), (9, 1), (10, 1), (11, 1), (12, 1)] [(4, 1), (10, 1), (12, 1), (13, 1), (14, 1)] [(3, 1), (10, 2), (13, 1), (15, 1), (16, 1)] [(8, 1), (11, 1), (12, 1), (17, 1), (18, 1), (19, 1), (20, 1)] [(21, 1), (22, 1), (23, 1), (24, 1), (25, 1)] [(24, 1), (26, 1), (27, 1), (28, 1)] [(24, 1), (26, 1), (29, 1), (30, 1), (31, 1), (32, 1), (33, 1), (34, 1)] [(9, 1), (26, 1), (30, 1)] 1234print('\\nLSI Model:')lsi = models.LsiModel(corpus_tfidf, num_topics=2, id2word=dictionary)topic_result = [a for a in lsi[corpus_tfidf]]pprint(topic_result) LSI Model: [[(0, 0.9334981916792652), (1, 0.10508952614086528)], [(0, 2.031992374687025), (1, -0.047145314121742235)], [(0, 1.5351342836582078), (1, 0.13488784052204628)], [(0, 1.9540077194594532), (1, 0.21780498576075008)], [(0, 1.2902472956004092), (1, -0.0022521437499372337)], [(0, 0.022783081905505403), (1, -0.7778052604326754)], [(0, 0.05671567576920905), (1, -1.1827703446704851)], [(0, 0.12360003320647955), (1, -2.6343068608236835)], [(0, 0.23560627195889133), (1, -0.9407936203668315)]] 12print('LSI Topics:')pprint(lsi.print_topics(num_topics=2, num_words=5)) LSI Topics: [(0, '0.579*&quot;system&quot; + 0.376*&quot;user&quot; + 0.270*&quot;eps&quot; + 0.257*&quot;time&quot; + ' '0.257*&quot;response&quot;'), (1, '-0.480*&quot;graph&quot; + -0.464*&quot;trees&quot; + -0.361*&quot;minors&quot; + -0.266*&quot;widths&quot; + ' '-0.266*&quot;ordering&quot;')] 123similarity = similarities.MatrixSimilarity(lsi[corpus_tfidf]) # similarities.Similarity()print('Similarity:')pprint(list(similarity)) Similarity: [array([ 1. , 0.9908607 , 0.9997008 , 0.9999994 , 0.9935261 , -0.08272626, -0.06414512, -0.06517283, 0.13288835], dtype=float32), array([0.9908607 , 0.99999994, 0.9938636 , 0.99100804, 0.99976987, 0.0524564 , 0.07105229, 0.070025 , 0.2653665 ], dtype=float32), array([ 0.9997008 , 0.9938636 , 0.99999994, 0.999727 , 0.99600756, -0.05832579, -0.03971674, -0.04074576, 0.15709123], dtype=float32), array([ 0.9999994 , 0.99100804, 0.999727 , 1. , 0.9936501 , -0.08163348, -0.06305084, -0.06407862, 0.13397504], dtype=float32), array([0.9935261 , 0.99976987, 0.99600756, 0.9936501 , 0.99999994, 0.03102366, 0.04963995, 0.04861134, 0.24462426], dtype=float32), array([-0.08272626, 0.0524564 , -0.05832579, -0.08163348, 0.03102366, 0.99999994, 0.99982643, 0.9998451 , 0.97674036], dtype=float32), array([-0.06414512, 0.07105229, -0.03971674, -0.06305084, 0.04963995, 0.99982643, 1. , 0.9999995 , 0.9805657 ], dtype=float32), array([-0.06517283, 0.070025 , -0.04074576, -0.06407862, 0.04861134, 0.9998451 , 0.9999995 , 1. , 0.9803632 ], dtype=float32), array([0.13288835, 0.2653665 , 0.15709123, 0.13397504, 0.24462426, 0.97674036, 0.9805657 , 0.9803632 , 1. ], dtype=float32)] 12345678910111213print('\\nLDA Model:')num_topics = 2lda = models.LdaModel( corpus_tfidf, num_topics=num_topics, id2word=dictionary, alpha='auto', eta='auto', minimum_probability=0.001, passes=10)doc_topic = [doc_t for doc_t in lda[corpus_tfidf]]print('Document-Topic:\\n')pprint(doc_topic) LDA Model: Document-Topic: [[(0, 0.02668742), (1, 0.97331256)], [(0, 0.9784582), (1, 0.021541778)], [(0, 0.9704323), (1, 0.02956772)], [(0, 0.97509205), (1, 0.024907947)], [(0, 0.9785106), (1, 0.021489413)], [(0, 0.9703556), (1, 0.029644381)], [(0, 0.04481229), (1, 0.9551877)], [(0, 0.023327617), (1, 0.97667235)], [(0, 0.058409944), (1, 0.9415901)]] 12for doc_topic in lda.get_document_topics(corpus_tfidf): print(doc_topic) [(0, 0.026687337), (1, 0.9733126)] [(0, 0.9784589), (1, 0.021541081)] [(0, 0.97043234), (1, 0.029567692)] [(0, 0.9750935), (1, 0.024906479)] [(0, 0.9785101), (1, 0.021489937)] [(0, 0.9703557), (1, 0.029644353)] [(0, 0.044812497), (1, 0.9551875)] [(0, 0.02332762), (1, 0.97667235)] [(0, 0.058404233), (1, 0.9415958)] 1234567891011121314for topic_id in range(num_topics): print('Topic', topic_id) # pprint(lda.get_topic_terms(topicid=topic_id)) pprint(lda.show_topic(topic_id))similarity = similarities.MatrixSimilarity(lda[corpus_tfidf])print('Similarity:')pprint(list(similarity))hda = models.HdpModel(corpus_tfidf, id2word=dictionary)topic_result = [a for a in hda[corpus_tfidf]]print('\\n\\nUSE WITH CARE--\\nHDA Model:')pprint(topic_result)print('HDA Topics:')print(hda.print_topics(num_topics=2, num_words=5)) Topic 0 [('system', 0.094599016), ('user', 0.073440075), ('eps', 0.052545987), ('response', 0.052496374), ('time', 0.052453455), ('survey', 0.031701956), ('trees', 0.03162545), ('human', 0.03161709), ('computer', 0.031570844), ('testing', 0.031543963)] Topic 1 [('graph', 0.0883405), ('trees', 0.06323685), ('minors', 0.06296622), ('interface', 0.03810195), ('computer', 0.03798469), ('human', 0.03792907), ('applications', 0.03792245), ('abc', 0.037920628), ('machine', 0.037917122), ('lab', 0.037909806)] Similarity: [array([1. , 0.04940351, 0.05783966, 0.05292428, 0.04934979, 0.05791992, 0.99981046, 0.99999374, 0.99940336], dtype=float32), array([0.04940351, 1. , 0.99996436, 0.9999938 , 1. , 0.99996364, 0.06883725, 0.04587576, 0.08387101], dtype=float32), array([0.05783966, 0.99996436, 1.0000001 , 0.99998796, 0.99996394, 1. , 0.07726298, 0.05431345, 0.09228647], dtype=float32), array([0.05292428, 0.9999938 , 0.99998796, 1. , 0.9999936 , 0.9999875 , 0.07235384, 0.04939714, 0.08738345], dtype=float32), array([0.04934979, 1. , 0.99996394, 0.9999936 , 1. , 0.99996316, 0.06878359, 0.04582203, 0.08381741], dtype=float32), array([0.05791992, 0.99996364, 1. , 0.9999875 , 0.99996316, 0.99999994, 0.07734313, 0.05439373, 0.09236652], dtype=float32), array([0.99981046, 0.06883725, 0.07726298, 0.07235384, 0.06878359, 0.07734313, 0.99999994, 0.9997355 , 0.9998863 ], dtype=float32), array([0.99999374, 0.04587576, 0.05431345, 0.04939714, 0.04582203, 0.05439373, 0.9997355 , 0.99999994, 0.9992751 ], dtype=float32), array([0.99940336, 0.08387101, 0.09228647, 0.08738345, 0.08381741, 0.09236652, 0.9998863 , 0.9992751 , 1. ], dtype=float32)] USE WITH CARE-- HDA Model: [[(0, 0.18174982193320122), (1, 0.02455260642448283), (2, 0.741340573910992), (3, 0.013544078061059922), (4, 0.010094377639823477)], [(0, 0.39419292675663636), (1, 0.2921969355337328), (2, 0.26125786014858376), (3, 0.013539627392486701), (4, 0.01009410883245766)], [(0, 0.5182077872999125), (1, 0.3880947736463974), (2, 0.023895609845034207), (3, 0.01805202212531745), (4, 0.013458421673222807)], [(0, 0.03621384798236036), (1, 0.5504573172680752), (2, 0.020442846194997377), (3, 0.348529241707211), (4, 0.011535562414627153)], [(0, 0.9049762450848856), (1, 0.024748801100993395), (2, 0.017919024335434904), (3, 0.013543460312481508), (4, 0.010093932388992328)], [(0, 0.04681359723231631), (1, 0.03233799461088905), (2, 0.8510430252219996), (3, 0.01805587061936895), (4, 0.013458128836093802)], [(0, 0.42478083784052273), (1, 0.03858547281122597), (2, 0.4528531768644199), (3, 0.021680841796584305), (4, 0.016150009359845837), (5, 0.011953757612369628)], [(0, 0.2466808290730598), (1, 0.6908552821243853), (2, 0.015924569811569197), (3, 0.012039668311419834)], [(0, 0.500366457263008), (1, 0.048221177670061226), (2, 0.34671234963274666), (3, 0.02707530995137571), (4, 0.02018763747377598), (5, 0.014942188361070167), (6, 0.010992923111633942)]] HDA Topics: [(0, '0.122*graph + 0.115*minors + 0.098*management + 0.075*random + 0.063*error'), (1, '0.114*human + 0.106*system + 0.086*user + 0.064*iv + 0.063*measurement')]","link":"/posts/59352.html"},{"title":"PageRank算法","text":"PageRank是互联网网页重要度的计算方法，可以定义推广到任意有向图结点的重要度计算上。其基本思想是在有向图上定义随机游走模型，即一阶马尔可夫链，描述游走者沿着有向图随机访问各个结点的行为，在一定条件下，极限情况访问每个结点的概率收敛到平稳分布，这时各个结点的概率值就是其 PageRank值，表示结点相对重要度。 有向图上可以定义随机游走模型，即一阶马尔可夫链，其中结点表示状态，有向边表示状态之间的转移，假设一个结点到连接出的所有结点的转移概率相等。转移概率由转移矩阵\\(M\\)表示 \\[M = [ m _ { i j } ] _ { n \\times n }\\] 第\\(i\\)行第\\(j\\)列的元素\\(m _ { i j }\\)表示从结点\\(j\\)跳转到结点\\(i\\)的概率。 当含有\\(n\\)个结点的有向图是强连通且非周期性的有向图时，在其基础上定义的随机游走模型，即一阶马尔可夫链具有平稳分布，平稳分布向量\\(R\\)称为这个有向图的 PageRank。若矩阵\\(M\\)是马尔可夫链的转移矩阵，则向量R满足\\[MR=R\\]向量\\(R\\)的各个分量称 PageRank为各个结点的值。 \\[R = \\left[ \\begin{array} { c } { P R ( v _ { 1 } ) } \\\\ { P R ( v _ { 2 } ) } \\\\ { \\vdots } \\\\ { P R ( v _ { n } ) } \\end{array} \\right]\\] 其中\\(P R ( v _ { i } ) , i = 1,2 , \\cdots , n\\)，表示结点\\(v_i\\)的 PageRank值。这是 PageRank的基本定义。 PageRank基本定义的条件现实中往往不能满足，对其进行扩展得到 PageRank的一般定义。任意含有\\(n\\)个结点的有向图上，可以定义一个随机游走模型，即一阶马尔可夫链，转移矩阵由两部分的线性组合组成，其中一部分按照转移矩阵\\(M\\)，从一个结点到连接出的所有结点的转移概率相等，另一部分按照完全随机转移矩阵，从任一结点到任一结点的转移概率都是\\(1/n\\)。这个马尔可夫链存在平稳分布，平稳分布向量R称为这个有 PageRank向图的一般，满足 \\[R = d M R + \\frac { 1 - d } { n } 1\\] 其中\\(d ( 0 \\leq d \\leq 1 )\\)是阻尼因子，1是所有分量为1的\\(n\\)维向量。 PageRank的计算方法包括迭代算法、幂法、代数算法。 幂法将 PageRank的等价式写成\\[R = ( d M + \\frac { 1 - d } { n } E ) R = A R\\] 其中\\(d\\)是阻尼因子，\\(E\\)是所有元素为1的\\(n\\)阶方阵。 PageRank算法可以看出\\(R\\)是一般转移矩阵\\(A\\)的主特征向量，即最大的特征值对应的特征向量。 幂法就是一个计算矩阵的主特征值和主特征向量的方法。 步骤是：选择初始向量\\(x_0\\)；计算一般转移矩阵\\(A\\)；进行迭代并规范化向量 \\[y _ { t + 1 } = A x _ { t }\\] \\[x _ { t + 1 } = \\frac { y _ { t + 1 } } { \\| y _ { t + 1 } \\| }\\] 直至收敛。 在实际应用中许多数据都以图(graph)的形式存在，比如，互联网、社交网络都可以看作是一个图。图数据上的机器学习具有理论与应用上的重要意义。pageRank算法是图的链接分析 (link analysis)的代表性算法，属于图数据上的无监督学习方法。 pageRank算法最初作为互联网网页重要度的计算方法，1996年由page和Brin提出，并用于谷歌搜索引擎的网页排序。事实上，pageRank可以定义在任意有向图上，后来被应用到社会影响力分析、文本摘要等多个问题。 pageRank算法的基本想法是在有向图上定义一个随机游走模型，即一阶马尔可夫链，描述随机游走者沿着有向图随机访问各个结点的行为。在一定条件下，极限情况访问每个结点的概率收敛到平稳分布， 这时各个结点的平稳概率值就是其 pageRank值，表示结点的重要度。 pageRank是递归定义的，pageRank的计算可以通过迭代算法进行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#https://gist.github.com/diogojc/1338222/84d767a68da711a154778fb1d00e772d65322187import numpy as npfrom scipy.sparse import csc_matrixdef pageRank(G, s=.85, maxerr=.0001): &quot;&quot;&quot; Computes the pagerank for each of the n states Parameters ---------- G: matrix representing state transitions Gij is a binary value representing a transition from state i to j. s: probability of following a transition. 1-s probability of teleporting to another state. maxerr: if the sum of pageranks between iterations is bellow this we will have converged. &quot;&quot;&quot; n = G.shape[0] # transform G into markov matrix A A = csc_matrix(G, dtype=np.float) rsums = np.array(A.sum(1))[:, 0] ri, ci = A.nonzero() A.data /= rsums[ri] # bool array of sink states sink = rsums == 0 # Compute pagerank r until we converge ro, r = np.zeros(n), np.ones(n) while np.sum(np.abs(r - ro)) &gt; maxerr: ro = r.copy() # calculate each pagerank at a time for i in range(0, n): # inlinks of state i Ai = np.array(A[:, i].todense())[:, 0] # account for sink states Di = sink / float(n) # account for teleportation to state i Ei = np.ones(n) / float(n) r[i] = ro.dot(Ai * s + Di * s + Ei * (1 - s)) # return normalized pagerank return r / float(sum(r)) 123456789# Example extracted from 'Introduction to Information Retrieval'G = np.array([[0,0,1,0,0,0,0], [0,1,1,0,0,0,0], [1,0,1,1,0,0,0], [0,0,0,1,1,0,0], [0,0,0,0,0,0,1], [0,0,0,0,0,1,1], [0,0,0,1,1,0,1]])print(pageRank(G,s=.86)) [0.12727557 0.03616954 0.12221594 0.22608452 0.28934412 0.03616954 0.16274076]","link":"/posts/24469.html"},{"title":"4种不同颜色的色块，它们的颜色真的不同吗","text":"背景介绍 在上面这幅背景为灰色的图片中（使用turtle绘制），我们看到了4种不同颜色的色块。它们的颜色真的不同吗？ 答案是否定的。 这里的灰色实际上是很小的蓝色和黄色像素的混合产物。由于这些像素太小，混合在一起不会引发拮抗过程，也就无法形成对比。 彩色电视机之所以能够利用颜色差异很小的像素呈现不同色彩就是这个原理。 (感兴趣的读者可以用放大镜亲自验证一下)绿松石色和淡黄绿色色块实际上分别由很小的绿色像素与蓝色背景像素混合和与黄色背景像素混合而来。红色像素与背景中的黄色像素混合形成橙色，与背景中的蓝色像素混合则成紫色。 导入模块 123import turtleimport randomimport time API说明 定义自己的画图类MyTurtle，常用方法介绍如下： get_color() 随机取rgb模式下的颜色的三个参数 set_pen_color() 设置画笔使用颜色 move(x, y) 控制海龟移动到指定x,y坐标(移动轨迹不着色) draw_shape(sides, length)画 sides 条边，length 长度的图形 draw_square(length) 调用 draw_shape() 函数画边长为 length 正方形 draw_triangle(length)调用 draw_shape() 函数画边长为 length 等边三角形draw_circle(length)调用 draw_shape() 函数画半径为 length 圆形 fill_color_shape(shape, length, fill_color)用 fill_color 颜色, 填充 length 边长, shape （draw_square, draw_triangle, draw_circle）设定的图形 此例子使用的 turtle 内置函数介绍 &gt;left(x)/right(x) 使海龟 逆时针/顺时针 旋转 &gt;circle(x)以x为半径，以当前方向开始画圆 &gt;forward(x)|fd(x) 前进x，单位为像素 &gt;backward(x)|bk(x)|back(x) 后退x，单位为像素 &gt;goto(x,y)|setpos(x,y)|setposition(x,y)使海龟沿直线移动到(x,y)坐标处 &gt;setx(x)/sety(y)设置 x/y 坐标，使海龟水平移动 &gt;dot(size,color)在当前位置以直径为size画点，颜色为color &gt;speed(n) 设置海龟的移动速度 &gt;pendown()|pd()|down() 使海龟“落地”，移动轨迹在屏幕上显示 &gt;penup()|up() 使海龟“起飞”,移动轨迹在屏幕上不显示 &gt;pensize(x) 设置画笔宽度为x，单位为像素 &gt;pencolor(color) 设置画笔颜色 &gt;fillcolor() 设置填充颜色，当轨迹形成闭合图形时填充的颜色 &gt;begin_fill()/end_fill() 控制颜色填充的时间段，只有在begin_fill()与end_fill()中间的闭合图形才会填充颜色 自定义绘图类 MyTurtle 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyTurtle(turtle.Turtle): def get_color(self): rgb = [] for i in range(3): rgb.append(random.randint(0, 255)) return rgb def set_pen_color(self): ''' ## 设置画笔的颜色 + ### colormode(cmode) &gt;- cmode 为1 或者 255， &gt;- 随后rgb三元组的值必须在0~comde之间 + ### pencolor(color=None) &gt; 设置画笔颜色 ''' self.screen.colormode(255) self.pencolor(self.get_color()) def move(self, x: int, y: int) -&gt; None: self.penup() self.goto(x, y) self.pendown() def draw_shape(self, sides: int, length: int) -&gt; None: _angle = 360.0/sides for side in range(sides): self.forward(length) self.left(_angle) def draw_square(self, length: int) -&gt; None: self.draw_shape(4, length) def draw_triangle(self, length: int) -&gt; None: self.draw_shape(3, length) def draw_circle(self, length: int) -&gt; None: self.draw_shape(360, length) def fill_color_shape(self, shape: str, length: int, fill_color: str) -&gt; None: _command = f'self.{shape}(length)' self.begin_fill() self.color(fill_color) eval(_command) self.end_fill() 定义函数 根据 star 列表（通常为[x, y]起始坐标）， end 坐标最大值，step 步长，来计算出所有坐标。 返回坐标列表（[[x,y], [x, y1], [x1, y], [x1, y1], …]） 12345678def diff_color_square_address(star: list, end: int, step: int) -&gt; list: x = list(range(star[0], end+1, step)) y = list(range(star[1], end+1, step)) res_array = [] for xi in x: for yi in y: res_array.append([xi, yi]) return res_array 画图主函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def draw_main(b_val: int, s_len: int) -&gt; None: ''' + ### bgcolor(color) &gt; 设置屏幕颜色，方式同 color() + ### speed(s=None) &gt; s为0-10的整数或者速度字符串 - None：返回当前速度 - &quot;fastest&quot;：0 - &quot;fast&quot;：10 - &quot;normal&quot;：6 - &quot;slow&quot;：3 - &quot;slowest&quot;：1 ''' star_time = time.time() t = MyTurtle() t.screen.bgcolor(&quot;black&quot;) # white t.speed(100) tem_b = b_val + 1 tem_s = b_val - tem_b % 2 # 取单数数量 sx = list(x1 for x1 in range(1, tem_s)) # 小方格基本坐标 sy = list(y1 for y1 in range(1, tem_s)) bx = list(x1 for x1 in range(1, tem_b)) # 大方格基本坐标 by = list(y1 for y1 in range(1, tem_b)) b_len = len(sx) # 大方格边长 different_colors_square_list = [ diff_color_square_address([2, 2], b_val, 4), # 混合橙色坐标 diff_color_square_address([4, 4], b_val, 4), # 混合淡绿色坐标 diff_color_square_address([4, 2], b_val, 4), # 混合紫色坐标 diff_color_square_address([2, 4], b_val, 4) # 混合绿松石色坐标 ] color_list = [ ['red', 'yellow'], # 混合橙色 ['green', 'yellow'], # 混合淡绿色 ['red', 'blue'], # 混合紫色 ['green', 'blue'], # 混合绿松石色 ['yellow', 'blue'], # 混合灰色 ] offset = (s_len * b_len * (b_val + 2) + s_len) / 2 print( f's_len: {s_len}, b_len: {b_len}, offset: {offset}, turtle: {t._screen.screensize()}') turtle.tracer(False) # 如果想看看程序的画图过程设成True for x3 in bx: for y3 in by: for x4 in sx: for y4 in sy: x = x3 * s_len * b_len + x4 * s_len - offset y = y3 * s_len * b_len + y4 * s_len - offset t.move(int(x), int(y)) # 判断坐标是否在特定颜色组坐标中，是选用对应颜色组 if [x3, y3] in different_colors_square_list[0]: colors = color_list[0] elif [x3, y3] in different_colors_square_list[1]: colors = color_list[1] elif [x3, y3] in different_colors_square_list[2]: colors = color_list[2] elif [x3, y3] in different_colors_square_list[3]: colors = color_list[3] else: colors = color_list[4] if ((x4 + y4) % 2) == 0: color = colors[0] else: color = colors[1] t.fill_color_shape('draw_square', s_len, color) t.move(800, 800) turtle.update() end_time = time.time() - star_time # print_time = time.strftime(&quot;%b %d %Y %H:%M:%S&quot;, end_time) print(end_time) t.screen.mainloop() 调用函数绘图 123456789if __name__ == '__main__': big_input = 9 big_value = 9 if big_input == '' or int(big_input) &lt;= 0 else int(big_input) small_input = 5 small_len = 5 if small_input == '' or int( small_input) &lt;= 0 else int(small_input) print('big_value:', big_value, type(big_value), '\\n', 'small_len:', small_len, type(small_len)) draw_main(big_value, small_len)","link":"/posts/1235119209.html"},{"title":"EM算法及其推广","text":"Expectation Maximization algorithm Maximum likehood function likehood &amp; maximum likehood 1．EM算法是含有隐变量的概率模型极大似然估计或极大后验概率估计的迭代算法。含有隐变量的概率模型的数据表示为\\(\\theta\\) )。这里，\\(Y\\)是观测变量的数据，\\(Z\\)是隐变量的数据，\\(\\theta\\) 是模型参数。EM算法通过迭代求解观测数据的对数似然函数\\({L}(\\theta)=\\log {P}(\\mathrm{Y} | \\theta)\\)的极大化，实现极大似然估计。每次迭代包括两步： \\(E\\)步，求期望，即求\\(logP\\left(Z | Y, \\theta\\right)\\) )关于$ P(Z | Y, ^{(i)})$)的期望： \\[Q\\left(\\theta, \\theta^{(i)}\\right)=\\sum_{Z} \\log P(Y, Z | \\theta) P\\left(Z | Y, \\theta^{(i)}\\right)\\] 称为\\(Q\\)函数，这里\\(\\theta^{(i)}\\)是参数的现估计值； \\(M\\)步，求极大，即极大化\\(Q\\)函数得到参数的新估计值： \\[\\theta^{(i+1)}=\\arg \\max _{\\theta} Q\\left(\\theta, \\theta^{(i)}\\right)\\] 在构建具体的EM算法时，重要的是定义\\(Q\\)函数。每次迭代中，EM算法通过极大化\\(Q\\)函数来增大对数似然函数\\({L}(\\theta)\\)。 2．EM算法在每次迭代后均提高观测数据的似然函数值，即 \\[P\\left(Y | \\theta^{(i+1)}\\right) \\geqslant P\\left(Y | \\theta^{(i)}\\right)\\] 在一般条件下EM算法是收敛的，但不能保证收敛到全局最优。 3．EM算法应用极其广泛，主要应用于含有隐变量的概率模型的学习。高斯混合模型的参数估计是EM算法的一个重要应用，下一章将要介绍的隐马尔可夫模型的非监督学习也是EM算法的一个重要应用。 4．EM算法还可以解释为\\(F\\)函数的极大-极大算法。EM算法有许多变形，如GEM算法。GEM算法的特点是每次迭代增加\\(F\\)函数值（并不一定是极大化\\(F\\)函数），从而增加似然函数值。 在统计学中，似然函数（likelihood function，通常简写为likelihood，似然）是一个非常重要的内容，在非正式场合似然和概率（Probability）几乎是一对同义词，但是在统计学中似然和概率却是两个不同的概念。概率是在特定环境下某件事情发生的可能性，也就是结果没有产生之前依据环境所对应的参数来预测某件事情发生的可能性，比如抛硬币，抛之前我们不知道最后是哪一面朝上，但是根据硬币的性质我们可以推测任何一面朝上的可能性均为50%，这个概率只有在抛硬币之前才是有意义的，抛完硬币后的结果便是确定的；而似然刚好相反，是在确定的结果下去推测产生这个结果的可能环境（参数），还是抛硬币的例子，假设我们随机抛掷一枚硬币1,000次，结果500次人头朝上，500次数字朝上（实际情况一般不会这么理想，这里只是举个例子），我们很容易判断这是一枚标准的硬币，两面朝上的概率均为50%，这个过程就是我们运用出现的结果来判断这个事情本身的性质（参数），也就是似然。 \\[P(Y|\\theta) = \\prod[\\pi p^{y_i}(1-p)^{1-y_i}+(1-\\pi) q^{y_i}(1-q)^{1-y_i}]\\] E step: \\[\\mu^{i+1}=\\frac{\\pi (p^i)^{y_i}(1-(p^i))^{1-y_i}}{\\pi (p^i)^{y_i}(1-(p^i))^{1-y_i}+(1-\\pi) (q^i)^{y_i}(1-(q^i))^{1-y_i}}\\] 12import numpy as npimport math 123456789pro_A, pro_B, por_C = 0.5, 0.5, 0.5def pmf(i, pro_A, pro_B, por_C): pro_1 = pro_A * math.pow(pro_B, data[i]) * math.pow( (1 - pro_B), 1 - data[i]) pro_2 = pro_A * math.pow(pro_C, data[i]) * math.pow( (1 - pro_C), 1 - data[i]) return pro_1 / (pro_1 + pro_2) M step: \\[\\pi^{i+1}=\\frac{1}{n}\\sum_{j=1}^n\\mu^{i+1}_j\\] \\[p^{i+1}=\\frac{\\sum_{j=1}^n\\mu^{i+1}_jy_i}{\\sum_{j=1}^n\\mu^{i+1}_j}\\] \\[q^{i+1}=\\frac{\\sum_{j=1}^n(1-\\mu^{i+1}_jy_i)}{\\sum_{j=1}^n(1-\\mu^{i+1}_j)}\\] 12345678910111213141516171819202122232425262728293031class EM: def __init__(self, prob): self.pro_A, self.pro_B, self.pro_C = prob # e_step def pmf(self, i): pro_1 = self.pro_A * math.pow(self.pro_B, data[i]) * math.pow( (1 - self.pro_B), 1 - data[i]) pro_2 = (1 - self.pro_A) * math.pow(self.pro_C, data[i]) * math.pow( (1 - self.pro_C), 1 - data[i]) return pro_1 / (pro_1 + pro_2) # m_step def fit(self, data): count = len(data) print('init prob:{}, {}, {}'.format(self.pro_A, self.pro_B, self.pro_C)) for d in range(count): _ = yield _pmf = [self.pmf(k) for k in range(count)] pro_A = 1 / count * sum(_pmf) pro_B = sum([_pmf[k] * data[k] for k in range(count)]) / sum( [_pmf[k] for k in range(count)]) pro_C = sum([(1 - _pmf[k]) * data[k] for k in range(count)]) / sum([(1 - _pmf[k]) for k in range(count)]) print('{}/{} pro_a:{:.3f}, pro_b:{:.3f}, pro_c:{:.3f}'.format( d + 1, count, pro_A, pro_B, pro_C)) self.pro_A = pro_A self.pro_B = pro_B self.pro_C = pro_C 1data=[1,1,0,1,0,0,1,0,1,1] 123em = EM(prob=[0.5, 0.5, 0.5])f = em.fit(data)next(f) init prob:0.5, 0.5, 0.5 12# 第一次迭代f.send(1) 1/10 pro_a:0.500, pro_b:0.600, pro_c:0.600 12# 第二次f.send(2) 2/10 pro_a:0.500, pro_b:0.600, pro_c:0.600 123em = EM(prob=[0.4, 0.6, 0.7])f2 = em.fit(data)next(f2) init prob:0.4, 0.6, 0.7 1f2.send(1) 1/10 pro_a:0.406, pro_b:0.537, pro_c:0.643 1f2.send(2) 2/10 pro_a:0.406, pro_b:0.537, pro_c:0.643 第9章EM算法及其推广-习题 习题9.1 如例9.1的三硬币模型，假设观测数据不变，试选择不同的处置，例如，\\(\\pi^{(0)}=0.46,p^{(0)}=0.55,q^{(0)}=0.67\\)，求模型参数为\\(\\theta=(\\pi,p,q)\\)的极大似然估计。 解答： 123456789101112131415161718192021222324252627282930313233343536373839%matplotlib inlineimport numpy as npimport mathclass EM: def __init__(self, prob): self.pro_A, self.pro_B, self.pro_C = prob def pmf(self, i): pro_1 = self.pro_A * math.pow(self.pro_B, data[i]) * math.pow( (1 - self.pro_B), 1 - data[i]) pro_2 = (1 - self.pro_A) * math.pow(self.pro_C, data[i]) * math.pow( (1 - self.pro_C), 1 - data[i]) return pro_1 / (pro_1 + pro_2) def fit(self, data): print('init prob:{}, {}, {}'.format(self.pro_A, self.pro_B, self.pro_C)) count = len(data) theta = 1 d = 0 while (theta &gt; 0.00001): # 迭代阻塞 _pmf = [self.pmf(k) for k in range(count)] pro_A = 1 / count * sum(_pmf) pro_B = sum([_pmf[k] * data[k] for k in range(count)]) / sum( [_pmf[k] for k in range(count)]) pro_C = sum([(1 - _pmf[k]) * data[k] for k in range(count)]) / sum([(1 - _pmf[k]) for k in range(count)]) d += 1 print('{} pro_a:{:.4f}, pro_b:{:.4f}, pro_c:{:.4f}'.format( d, pro_A, pro_B, pro_C)) theta = abs(self.pro_A - pro_A) + abs(self.pro_B - pro_B) + abs(self.pro_C - pro_C) self.pro_A = pro_A self.pro_B = pro_B self.pro_C = pro_C 12345# 加载数据data = [1, 1, 0, 1, 0, 0, 1, 0, 1, 1]em = EM(prob=[0.46, 0.55, 0.67])f = em.fit(data) init prob:0.46, 0.55, 0.67 1 pro_a:0.4619, pro_b:0.5346, pro_c:0.6561 2 pro_a:0.4619, pro_b:0.5346, pro_c:0.6561 可见通过两次迭代，参数已经收敛，三个硬币的概率分别为0.4619，0.5346，0.6561 习题9.2 证明引理9.2。 引理9.2：若\\(\\tilde{P}_{\\theta}(Z)=P(Z | Y, \\theta)\\)，则\\[F(\\tilde{P}, \\theta)=\\log P(Y|\\theta)\\] 证明： 由\\(F\\)函数的定义（定义9.3）可得：\\[F(\\tilde{P}, \\theta)=E_{\\tilde{P}}[\\log P(Y,Z|\\theta)] + H(\\tilde{P})\\]其中，\\(H(\\tilde{P})=-E_{\\tilde{P}} \\log \\tilde{P}(Z)\\) \\(\\begin{aligned} \\therefore F(\\tilde{P}, \\theta) &amp;= E_{\\tilde{P}}[\\log P(Y,Z|\\theta)] -E_{\\tilde{P}} \\log \\tilde{P}(Z) \\\\ &amp;= \\sum_Z \\log P(Y,Z|\\theta) \\tilde{P}_{\\theta}(Z) - \\sum_Z \\log \\tilde{P}(Z) \\cdot \\tilde{P}(Z) \\\\ &amp;= \\sum_Z \\log P(Y,Z|\\theta) P(Z|Y,\\theta) - \\sum_Z \\log P(Z|Y,\\theta) \\cdot P(Z|Y,\\theta) \\\\ &amp;= \\sum_Z P(Z|Y,\\theta) \\left[ \\log P(Y,Z|\\theta) - \\log P(Z|Y,\\theta) \\right] \\\\ &amp;= \\sum_Z P(Z|Y,\\theta) \\log \\frac{P(Y,Z|\\theta)}{P(Z|Y,\\theta)} \\\\ &amp;= \\sum_Z P(Z|Y,\\theta) \\log P(Y|\\theta) \\\\ &amp;= \\log P(Y|\\theta) \\sum_Z P(Z|Y,\\theta) \\end{aligned}\\) \\(\\displaystyle \\because \\sum_Z \\tilde{P}_{\\theta}(Z) = P(Z|Y, \\theta) = 1\\) \\(\\therefore F(\\tilde{P}, \\theta) = \\log P(Y|\\theta)\\)，引理9.2得证。 习题9.3 已知观测数据 -67，-48，6，8，14，16，23，24，28，29，41，49，56，60，75 试估计两个分量的高斯混合模型的5个参数。 解答： 12345678910111213from sklearn.mixture import GaussianMixtureimport numpy as npimport matplotlib.pyplot as plt# 初始化观测数据data = np.array([-67, -48, 6, 8, 14, 16, 23, 24, 28, 29, 41, 49, 56, 60, 75]).reshape(-1, 1)# 聚类gmmModel = GaussianMixture(n_components=2)gmmModel.fit(data)labels = gmmModel.predict(data)print(&quot;labels =&quot;, labels) labels = [1 1 0 0 0 0 0 0 0 0 0 0 0 0 0] 123456789101112for i in range(0, len(labels)): if labels[i] == 0: plt.scatter(i, data.take(i), s=15, c='red') elif labels[i] == 1: plt.scatter(i, data.take(i), s=15, c='blue')plt.title('Gaussian Mixture Model')plt.xlabel('x')plt.ylabel('y')plt.show()print(&quot;means =&quot;, gmmModel.means_.reshape(1, -1))print(&quot;covariances =&quot;, gmmModel.covariances_.reshape(1, -1))print(&quot;weights = &quot;, gmmModel.weights_.reshape(1, -1)) means = [[ 32.98489643 -57.51107027]] covariances = [[429.45764867 90.24987882]] weights = [[0.86682762 0.13317238]] 习题9.4 EM算法可以用到朴素贝叶斯法的非监督学习，试写出其算法。 解答： &gt; EM算法的一般化： E步骤：根据参数初始化或上一次迭代的模型参数来计算出隐变量的后验概率，其实就是隐变量的期望。作为隐变量的现估计值：\\[w_j^{(i)}=Q_{i}(z^{(i)}=j) := p(z^{(i)}=j | x^{(i)} ; \\theta)\\] M步骤：将似然函数最大化以获得新的参数值：\\[ \\theta :=\\arg \\max_{\\theta} \\sum_i \\sum_{z^{(i)}} Q_i (z^{(i)}) \\log \\frac{p(x^{(i)}, z^{(i)} ; \\theta)}{Q_i (z^{(i)})} \\] 使用NBMM（朴素贝叶斯的混合模型）中的\\(\\phi_z,\\phi_{j|z^{(i)}=1},\\phi_{j|z^{(i)}=0}\\)参数替换一般化的EM算法中的\\(\\theta\\)参数，然后依次求解\\(w_j^{(i)}\\)与\\(\\phi_z,\\phi_{j|z^{(i)}=1},\\phi_{j|z^{(i)}=0}\\)参数的更新问题。 NBMM的EM算法： E步骤：